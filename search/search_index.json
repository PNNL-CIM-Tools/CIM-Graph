{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CIMantic Graphs Library Documentation","text":"<p>CIMantic Graphs is an open-source library for creating, parsing, and editing CIM power system models using in-memory knowledge graphs to reduce the burden and learning curve associated with using the Common Information Model.</p> <p></p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Single API method to obtain data for any CIM class. No more custom database queries.</li> <li>Single API method to obtain data for EMS node-breaker transmission models, bus-branch planning models, and distribution feeder models.</li> <li>Single API method for both centralized and distributed architectures.</li> <li>Multiple database support with no changes to upper-level graph data or API calls. Only need to change host/port specified in ConnectionParameters data object.</li> <li>Create CIM models from scratch with full object-oriented interface.</li> <li>Open-source data engineering tool for management of CIM models.</li> <li>Knowledge graph approach based on semantic understanding of CIM.</li> <li>Object-oriented data structure with enforcement of CIM Schema.</li> <li>Data profiles generated directly from Enterprise Architect UML.</li> <li>Custom profile support using CIMTool.</li> <li>Direct creation/editing/parsing of CIM XML, JSON-LD.</li> <li>API support for centralized/distributed transmission + distribution models.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install CIMantic Graphs, clone the github repository or use pip install:</p> <pre><code>pip install cim-graph\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import cimgraph.data_profile.cim17v40 as cim\nfrom cimgraph.databases.blazegraph import BlazegraphConnection\nfrom cimgraph.models import FeederModel\n\n# Connect to database\ndatabase = BlazegraphConnection()\n\n# Create a feeder model\nfeeder = database.get_object(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\")\nnetwork = FeederModel(connection=database, container=feeder, distributed=False)\n\n# Query for all line data\nnetwork.get_all_edges(cim.ACLineSegment)\n\n# Access graph data\nfor line in network.graph[cim.ACLineSegment].values():\n    print(f\"Line: {line.name}, Length: {line.length}\")\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#overview","title":"Overview","text":"<p>Get started with CIMantic Graphs, learn about installation, project structure, and how to contribute.</p>"},{"location":"#cim-profiles","title":"CIM Profiles","text":"<p>Learn how to work with different CIM profiles, build custom profiles, and use CIM objects.</p>"},{"location":"#databases","title":"Databases","text":"<p>Connect to various databases including Blazegraph, Neo4j, GraphDB, MySQL, and GridAPPS-D. Also learn how to parse XML and JSON-LD files.</p>"},{"location":"#graph-models","title":"Graph Models","text":"<p>Understand the different graph model types: FeederModel for distribution, NodeBreakerModel for transmission, and BusBranchModel for planning studies.</p>"},{"location":"#utils-shortcuts","title":"Utils &amp; Shortcuts","text":"<p>Discover utility functions for file writing, bulk data queries, and automatic mermaid diagram generation.</p>"},{"location":"#support-contributing","title":"Support &amp; Contributing","text":"<ul> <li>GitHub Repository: PNNL-CIM-Tools/CIM-Graph</li> <li>PyPI Package: cim-graph</li> <li>Issue Tracker: GitHub Issues</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is maintained by Pacific Northwest National Laboratory and is available under the terms specified in the repository license.</p> <p></p>"},{"location":"conf/","title":"Conf","text":"<p>Configuration file for the Sphinx documentation builder.</p> <p>This file only contains a selection of the most common options. For a full list see the documentation: https://www.sphinx-doc.org/en/master/usage/configuration.html</p> <p>-- Path setup --------------------------------------------------------------</p> <p>If extensions (or modules to document with autodoc) are in another directory, add these directories to sys.path here. If the directory is relative to the documentation root, use os.path.abspath to make it absolute, like shown here.</p> <p>import os import sys sys.path.insert(0, os.path.abspath('.'))</p> <p>-- Project information -----------------------------------------------------</p> In\u00a0[\u00a0]: Copied! <pre># General information about the project.\nproject = 'CIMantic Graphs'\ncopyright = '2025, Battelle Memorial Institute, All rights reserved.'\nauthor = 'Alex Anderson &amp; CIMantic Graphs Team'\n</pre> # General information about the project. project = 'CIMantic Graphs' copyright = '2025, Battelle Memorial Institute, All rights reserved.' author = 'Alex Anderson &amp; CIMantic Graphs Team' In\u00a0[\u00a0]: Copied! <pre># The full version, including alpha/beta/rc tags\nrelease = '0.3.1a0'\n</pre> # The full version, including alpha/beta/rc tags release = '0.3.1a0' <p>-- General configuration ---------------------------------------------------</p> In\u00a0[\u00a0]: Copied! <pre># Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'nbsphinx',\n    'sphinx.ext.autodoc',\n    'sphinx.ext.intersphinx',\n    'sphinx.ext.todo',\n    'sphinx.ext.coverage',\n    'sphinx.ext.mathjax',\n    'sphinx.ext.ifconfig',\n    'sphinx.ext.viewcode',\n    'sphinx.ext.githubpages',\n    'myst_parser']\n</pre> # Add any Sphinx extension module names here, as strings. They can be # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom # ones. extensions = [     'nbsphinx',     'sphinx.ext.autodoc',     'sphinx.ext.intersphinx',     'sphinx.ext.todo',     'sphinx.ext.coverage',     'sphinx.ext.mathjax',     'sphinx.ext.ifconfig',     'sphinx.ext.viewcode',     'sphinx.ext.githubpages',     'myst_parser'] In\u00a0[\u00a0]: Copied! <pre># Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n</pre> # Add any paths that contain templates here, relative to this directory. templates_path = ['_templates'] In\u00a0[\u00a0]: Copied! <pre># List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = []\n</pre> # List of patterns, relative to source directory, that match files and # directories to ignore when looking for source files. # This pattern also affects html_static_path and html_extra_path. exclude_patterns = [] In\u00a0[\u00a0]: Copied! <pre># The master toctree document.\nmaster_doc = 'index'\n</pre> # The master toctree document. master_doc = 'index' <p>-- Options for HTML output -------------------------------------------------</p> In\u00a0[\u00a0]: Copied! <pre># The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'sphinx_rtd_theme'\n</pre> # The theme to use for HTML and HTML Help pages.  See the documentation for # a list of builtin themes. # html_theme = 'sphinx_rtd_theme' In\u00a0[\u00a0]: Copied! <pre># Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n</pre> # Add any paths that contain custom static files (such as style sheets) here, # relative to this directory. They are copied after the builtin static files, # so a file named \"default.css\" will overwrite the builtin \"default.css\". html_static_path = ['_static'] In\u00a0[\u00a0]: Copied! <pre># Don't execute notebook contents when writing to html\nnbsphinx_allow_errors = True\nnbsphinx_execute = 'never'\n</pre> # Don't execute notebook contents when writing to html nbsphinx_allow_errors = True nbsphinx_execute = 'never' In\u00a0[\u00a0]: Copied! <pre># Use LuaLaTex\nlatex_engine = 'lualatex'\n</pre> # Use LuaLaTex latex_engine = 'lualatex' In\u00a0[\u00a0]: Copied! <pre># Configure nbsphinx\nnbsphinx_execute = 'auto'  # Set to 'auto', 'always', or 'never' as needed\n</pre> # Configure nbsphinx nbsphinx_execute = 'auto'  # Set to 'auto', 'always', or 'never' as needed In\u00a0[\u00a0]: Copied! <pre># Add CSS to hide cells with hide_input tag\nnbsphinx_prolog = \"\"\"\n{% set docname = env.doc2path(env.docname, base=None) %}\n\n.. raw:: html\n\n    &lt;style&gt;\n        /* Hide input cells with hide_input tag */\n        div.nbinput.container div.prompt.container.hide_input + div.input_area {\n            display: none;\n        }\n\n        /* Alternative selector that should work with newer nbsphinx */\n        .tag_hide_input .jp-CodeCell-inputWrapper {\n            display: none !important;\n        }\n\n        /* For nbsphinx 0.8.0+ */\n        .tag_hide_input .nbinput {\n            display: none !important;\n        }\n    &lt;/style&gt;\n\"\"\"\n</pre> # Add CSS to hide cells with hide_input tag nbsphinx_prolog = \"\"\" {% set docname = env.doc2path(env.docname, base=None) %}  .. raw:: html       \"\"\" In\u00a0[\u00a0]: Copied! <pre># Configure tag-based cell filtering\nnbsphinx_preprocessor_config = {\n    'TagRemovePreprocessor': {\n        'enabled': True,\n        'remove_input_tags': {'hide_input'},\n    }\n}\n</pre> # Configure tag-based cell filtering nbsphinx_preprocessor_config = {     'TagRemovePreprocessor': {         'enabled': True,         'remove_input_tags': {'hide_input'},     } } In\u00a0[\u00a0]: Copied! <pre># Additional options for fine-grained control\nnbsphinx_execute_arguments = [\n    '--TagRemovePreprocessor.enabled=True',\n    \"--TagRemovePreprocessor.remove_cell_tags={'hide_cell'}\", # Hide the entire cell\n    \"--TagRemovePreprocessor.remove_input_tags={'hide_input'}\", # Hide only the input\n    \"--TagRemovePreprocessor.remove_output_tags={'hide_output'}\", # Hide only the output\n]\n</pre> # Additional options for fine-grained control nbsphinx_execute_arguments = [     '--TagRemovePreprocessor.enabled=True',     \"--TagRemovePreprocessor.remove_cell_tags={'hide_cell'}\", # Hide the entire cell     \"--TagRemovePreprocessor.remove_input_tags={'hide_input'}\", # Hide only the input     \"--TagRemovePreprocessor.remove_output_tags={'hide_output'}\", # Hide only the output ]"},{"location":"01_overview/1_1_overview/","title":"Overview & Quick Start","text":"<p>This tutorial provides an introduction to usage of the CIMantic Graphs library (aka CIM-Graph).</p> <p>CIMantic Graphs is an open-source library for creating in-memory labeled property graphs for creating, parsing, and editing CIM power system models. It creates Python object instances in memory using a data profile exported from a specified CIM profile (e.g. IEC61970cim17v40 or GridAPPS-D RC4_2021).</p> <p>To install CIMantic Graphs clone the github repository or use pip install: <code>pip install cim-graph</code></p> <p></p> <p>Method 1: Directly import the desired CIM profile:</p> In\u00a0[1]: Copied! <pre>import cimgraph.data_profile.cim17v40 as cim\n</pre> import cimgraph.data_profile.cim17v40 as cim <p>Method 2: Use <code>importlib</code>:</p> In\u00a0[2]: Copied! <pre>import importlib\ncim_profile = 'cimhub_2023'\ncim = importlib.import_module('cimgraph.data_profile.' + cim_profile)\n</pre> import importlib cim_profile = 'cimhub_2023' cim = importlib.import_module('cimgraph.data_profile.' + cim_profile) <p>After importing the data profile, it is possible to create an instance of a class or view the attributes of any class.</p> <p>Example 1: Create a new breaker with a name. If an mRID string is not provided, a UUID is automatically created based on the name or a random seed. Attributes of the class can be assigned</p> In\u00a0[3]: Copied! <pre>breaker = cim.Breaker(name = \"breaker_01\", open=True)\nbreaker.NormalOpen = False\nbreaker.pprint()\n</pre> breaker = cim.Breaker(name = \"breaker_01\", open=True) breaker.NormalOpen = False breaker.pprint() <pre>{\n    \"@id\": \"7e72cb38-275c-4369-9c3b-e8b5a42a8703\",\n    \"@type\": \"Breaker\",\n    \"name\": \"breaker_01\",\n    \"open\": \"True\",\n    \"NormalOpen\": false\n}\n</pre> <p>Example 2: Associate two CIM objects based on their associations</p> In\u00a0[4]: Copied! <pre>substation = cim.Substation(name = \"sub_1\")\nbreaker.EquipmentContainer = substation\nsubstation.Equipments.append(breaker)\nbreaker.pprint()\nsubstation.pprint()\n</pre> substation = cim.Substation(name = \"sub_1\") breaker.EquipmentContainer = substation substation.Equipments.append(breaker) breaker.pprint() substation.pprint() <pre>{\n    \"@id\": \"7e72cb38-275c-4369-9c3b-e8b5a42a8703\",\n    \"@type\": \"Breaker\",\n    \"name\": \"breaker_01\",\n    \"EquipmentContainer\": {\n        \"@id\": \"5d58b92a-5734-4ae7-8f3c-1357e662cf16\",\n        \"@type\": \"Substation\"\n    },\n    \"open\": \"True\",\n    \"NormalOpen\": false\n}\n{\n    \"@id\": \"5d58b92a-5734-4ae7-8f3c-1357e662cf16\",\n    \"@type\": \"Substation\",\n    \"name\": \"sub_1\",\n    \"Equipments\": [\n        {\n            \"@id\": \"7e72cb38-275c-4369-9c3b-e8b5a42a8703\",\n            \"@type\": \"Breaker\"\n        }\n    ]\n}\n</pre> <p>Example 3: View documentation of the ACLineSegment class</p> In\u00a0[5]: Copied! <pre>print(cim.ACLineSegment.__doc__)\n</pre> print(cim.ACLineSegment.__doc__) <pre>\n    A wire or combination of wires, with consistent electrical characteristics,\n    building a single electrical system, used to carry alternating current\n    between points in the power system.\n    For symmetrical, transposed 3ph lines, it is sufficient to use attributes\n    of the line segment, which describe impedances and admittances for the\n    entire length of the segment. Additionally impedances can be computed by\n    using length and associated per length impedances.\n    The BaseVoltage at the two ends of ACLineSegments in a Line shall have\n    the same BaseVoltage.nominalVoltage. However, boundary lines may have slightly\n    different BaseVoltage.nominalVoltages and variation is allowed. Larger\n    voltage difference in general requires use of an equivalent branch.\n    \n</pre> <p>An example of the complete set of all environment variables used by the GridAPPS-D platform is shown below</p> In\u00a0[6]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nos.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql'\nos.environ['CIMG_DATABASE'] = 'powergridmodel'\nos.environ['CIMG_HOST'] = 'localhost'\nos.environ['CIMG_PORT'] = '61613'\nos.environ['CIMG_USERNAME'] = 'test_app_user'\nos.environ['CIMG_PASSWORD'] = '4Test'\nos.environ['CIMG_NAMESPACE'] = 'http://iec.ch/TC57/CIM100#'\nos.environ['CIMG_IEC61970_301'] = '8'\nos.environ['CIMG_USE_UNITS'] = 'False'\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' os.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql' os.environ['CIMG_DATABASE'] = 'powergridmodel' os.environ['CIMG_HOST'] = 'localhost' os.environ['CIMG_PORT'] = '61613' os.environ['CIMG_USERNAME'] = 'test_app_user' os.environ['CIMG_PASSWORD'] = '4Test' os.environ['CIMG_NAMESPACE'] = 'http://iec.ch/TC57/CIM100#' os.environ['CIMG_IEC61970_301'] = '8' os.environ['CIMG_USE_UNITS'] = 'False' <p>The required and optional arguments for the <code>ConnectionParameters</code> class are described in detail in Environment Variables</p> In\u00a0[7]: Copied! <pre>from cimgraph.databases.blazegraph import BlazegraphConnection\ndatabase = BlazegraphConnection()\n</pre> from cimgraph.databases.blazegraph import BlazegraphConnection database = BlazegraphConnection() In\u00a0[8]: Copied! <pre>from cimgraph.models import FeederModel\n</pre> from cimgraph.models import FeederModel <p>The power system network is then created by passing the database connection, container object, and a boolean flag whether a centralized or distributed model should be built.</p> In\u00a0[9]: Copied! <pre>feeder = database.get_object(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\") #ieee 13 bus\nnetwork = FeederModel(connection=database, container=feeder, distributed=False)\n</pre> feeder = database.get_object(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\") #ieee 13 bus network = FeederModel(connection=database, container=feeder, distributed=False) <p>The network is populated by default with all ConductingEquipment, ConnectivityNode, and Terminal class instances. The knowledge graph is indexed by the class type and then the device mRID.</p> <p>To view all instances of a particular class, use the <code>.pprint(cim.ClassName)</code> method. The default python print method and individual .pprint() statements can also be used on <code>network.graph</code> and individual objects.</p> <p>By default, only equipment classes and basic connectivity information (nodes and terminals) are loaded with just the UUIDs of each class to optimize memory usage.</p> In\u00a0[10]: Copied! <pre>network.pprint(cim.Breaker) # View all instance data of type Breaker\n</pre> network.pprint(cim.Breaker) # View all instance data of type Breaker <pre>[\n    {\n        \"@id\": \"52de9189-20dc-4c73-bdee-e960fe1f9493\",\n        \"@type\": \"Breaker\",\n        \"Terminals\": [\n            {\n                \"@id\": \"1d81c7fe-e88f-41e3-a900-476ca6476ccd\",\n                \"@type\": \"Terminal\"\n            },\n            {\n                \"@id\": \"2847e06b-c8ed-41e6-b515-c61c9e8eb4b4\",\n                \"@type\": \"Terminal\"\n            }\n        ]\n    }\n]\n</pre> <pre>\nmindmap\n    52de9189((**Breaker**\n        name: None))\n        [\"Terminals\"]\n            1d81c7fe(**Terminal**\n                name: None)\n            2847e06b(**Terminal**\n                name: None)\n</pre> In\u00a0[11]: Copied! <pre>network.get_all_edges(cim.Breaker)\nnetwork.get_all_edges(cim.Terminal)\nnetwork.get_all_edges(cim.ConnectivityNode)\n</pre> network.get_all_edges(cim.Breaker) network.get_all_edges(cim.Terminal) network.get_all_edges(cim.ConnectivityNode) <pre>\nmindmap\n    52de9189((**Breaker**\n        name: brkr1\n        normalOpen: False\n        open: False\n        retained: True\n        ratedCurrent: 400.0\n        breakingCapacity: 400.0))\n        [Location]\n            085bbe1f(**Location**\n                name: None)\n        [EquipmentContainer]\n            49AD8E07(**Feeder**\n                name: None)\n        [BaseVoltage]\n            2a158e0c(**BaseVoltage**\n                name: None)\n        [\"Terminals\"]\n            1d81c7fe(**Terminal**\n                name: brkr1_T1\n                sequenceNumber: 1)\n            2847e06b(**Terminal**\n                name: brkr1_T2\n                sequenceNumber: 2)\n</pre> <p>To view the attributes of particular object instance, directly invoke the attribute from the UML class diagram.</p> In\u00a0[12]: Copied! <pre>from uuid import UUID\nbreaker = network.graph[cim.Breaker][UUID(\"52de9189-20dc-4c73-bdee-e960fe1f9493\")]\nprint(breaker.normalOpen)\n</pre> from uuid import UUID breaker = network.graph[cim.Breaker][UUID(\"52de9189-20dc-4c73-bdee-e960fe1f9493\")] print(breaker.normalOpen) <pre>False\n</pre> <p>To traverse the knowledge graph, no custom queries are required. Instead, directly invoke the UML association names that serves as references between objects in the graph:</p> In\u00a0[13]: Copied! <pre>bus1_name = breaker.Terminals[0].ConnectivityNode.name\nbus2_name = breaker.Terminals[1].ConnectivityNode.name\n\nprint(breaker.name,'connects nodes',bus1_name,bus2_name)\n</pre> bus1_name = breaker.Terminals[0].ConnectivityNode.name bus2_name = breaker.Terminals[1].ConnectivityNode.name  print(breaker.name,'connects nodes',bus1_name,bus2_name) <pre>brkr1 connects nodes 650 brkr\n</pre> <pre>\n%%{init: {\"theme\":\"neutral\"}}%%\nflowchart LR\n    52de9189(\"**Breaker**\n        name: brkr1\")\n    52de9189 -- Terminals[0] --&gt; 1d81c7fe\n    1d81c7fe(\"**Terminal**\n        name: brkr1_T1\")\n    1d81c7fe -- ConnectivityNode --&gt; 7beddadd\n    7beddadd(\"**ConnectivityNode**\n        name: 650\")\n    52de9189(\"**Breaker**\n        name: brkr1\")\n    52de9189 -- Terminals[1] --&gt; 2847e06b\n    2847e06b(\"**Terminal**\n        name: brkr1_T2\")\n    2847e06b -- ConnectivityNode --&gt; 94f822e0\n    94f822e0(\"**ConnectivityNode**\n        name: brkr\")\n</pre> <p>No separate queries or mapping are required for measurment objects. Call the <code>.get_all_edges</code> method for each measurement class, and then obtain the measurements from the equipment object</p> In\u00a0[14]: Copied! <pre>network.get_all_edges(cim.Analog)\nnetwork.get_all_edges(cim.Discrete)\n</pre> network.get_all_edges(cim.Analog) network.get_all_edges(cim.Discrete) In\u00a0[15]: Copied! <pre>for meas in breaker.Measurements:\n    p = meas.phases\n    print(\"name:\", meas.name, \"  phase:\" , meas.phases, \"  bus:\", meas.Terminal.ConnectivityNode.name)\n</pre> for meas in breaker.Measurements:     p = meas.phases     print(\"name:\", meas.name, \"  phase:\" , meas.phases, \"  bus:\", meas.Terminal.ConnectivityNode.name) <pre>name: Breaker_brkr1_A_1_C   phase: PhaseCode.C   bus: 650\nname: Breaker_brkr1_A_1_A   phase: PhaseCode.A   bus: 650\nname: Breaker_brkr1_A_1_B   phase: PhaseCode.B   bus: 650\nname: Breaker_brkr1_Pos_1_A   phase: PhaseCode.A   bus: 650\nname: Breaker_brkr1_Pos_1_B   phase: PhaseCode.B   bus: 650\nname: Breaker_brkr1_Pos_1_C   phase: PhaseCode.C   bus: 650\n</pre> In\u00a0[16]: Copied! <pre>from cimgraph import utils\n</pre> from cimgraph import utils In\u00a0[17]: Copied! <pre>utils.get_all_line_data(network)\n</pre> utils.get_all_line_data(network) In\u00a0[18]: Copied! <pre>utils.write_json_ld(network, 'my_model.json')\n</pre> utils.write_json_ld(network, 'my_model.json') In\u00a0[19]: Copied! <pre>from mermaid import Mermaid\n</pre> from mermaid import Mermaid <p>As an example of the diagramming capabilities offered, an arbitrary UML diagram can be create by passing in a list of CIM classes to be displayed. The diagrams presented above were also auto-generated using the utils module.</p> In\u00a0[20]: Copied! <pre>diagram_text = utils.get_mermaid([cim.ACLineSegment,\n                          cim.ACLineSegmentPhase,\n                          cim.PerLengthImpedance,\n                          cim.PerLengthPhaseImpedance,\n                          cim.PhaseImpedanceData,\n                          cim.WireSpacingInfo])\nMermaid(diagram_text)\n</pre> diagram_text = utils.get_mermaid([cim.ACLineSegment,                           cim.ACLineSegmentPhase,                           cim.PerLengthImpedance,                           cim.PerLengthPhaseImpedance,                           cim.PhaseImpedanceData,                           cim.WireSpacingInfo]) Mermaid(diagram_text) Out[20]:"},{"location":"01_overview/1_1_overview/#overview-quick-start","title":"Overview &amp; Quick Start\u00b6","text":""},{"location":"01_overview/1_1_overview/#table-of-contents","title":"Table of Contents:\u00b6","text":"<ul> <li><p>1. CIMantic Graphs Structure</p> </li> <li><p>2. Importing CIMantic Graphs</p> </li> <li><p>3. Specifying Connection Parameters</p> </li> <li><p>4. Connecting to the Data Source</p> </li> <li><p>5. Creating a Container and Graph Model</p> </li> <li><p>6. Automated Database Query Generation</p> </li> <li><p>7. Traversing the Knowledge Graph</p> </li> <li><p>8. Utils Shortcut Methods</p> </li> </ul>"},{"location":"01_overview/1_1_overview/#cimantic-graphs-structure","title":"CIMantic Graphs Structure\u00b6","text":"<p>CIMantic Graphs uses the layered architecture shown below:</p>"},{"location":"01_overview/1_1_overview/#database-layer","title":"Database Layer\u00b6","text":"<p>CIMantic Graphs currently supports the following databases and interfaces:</p> <ul> <li><p>Blazegraph Database</p> </li> <li><p>GraphDB Database</p> </li> <li><p>Neo4J Database</p> </li> <li><p>MySQL Database (in progress)</p> </li> <li><p>GridAPPS-D Platform</p> </li> <li><p>AVEVA PI Asset Framework (in progress)</p> </li> <li><p>RDFLib File Parser</p> </li> <li><p>XML Flat Files</p> </li> <li><p>JSON-LD Flat Files (in progress)</p> </li> <li><p>CSV Flat Files (in progress)</p> </li> </ul> <p>The library uses a unified syntax for all upper-level calls and routines. The databases can be swapped interchangeably by changing the environment variables specified during application startup, with no other changes to any other application syntax or methods</p>"},{"location":"01_overview/1_1_overview/#data-profile-layer","title":"Data Profile Layer\u00b6","text":"<p>CIMantic Graphs is able to support any standard or custom CIM profile. The CIM profile needs to be exported as an XSD data profile / schema. CIMantic Graphs is then able to ingest the data profile and convert all UML classes and attributes to python dataclasses, which power all of the routines and unified API syntax</p>"},{"location":"01_overview/1_1_overview/#api-layer","title":"API Layer\u00b6","text":"<p>CIMantic Graphs offers a breakthrough in terms of ease-of-use through a unified API with two core methods.</p> <p>Access to labeled property graph objects:</p> <ul> <li><code>network.graph[cim.ClassName]</code>: This offers access to a catalog of CIM object instances stored in memory and sorted by class type and mRID forming the named property graph.</li> </ul> <p>Universal database query method:</p> <ul> <li><code>network.get_all_edges(cim.ClassName)</code>: This is a universal query method that gets all attributes and all objects one edge away from instances of the specified class. This method works for all CIM classes, CIM profiles, serialization formats, and supported databases.</li> </ul>"},{"location":"01_overview/1_1_overview/#knowledge-graph-layer","title":"Knowledge Graph Layer\u00b6","text":"<p>CIMantic Graphs offers three core knowledge graph classes for handing various kinds of power system models:</p> <ul> <li><p><code>BusBranchModel</code>: Transmission bus-branch models commonly used for planning and power flow studies</p> </li> <li><p><code>NodeBreakerModel</code>: Transmission node-breaker models commonly used inside energy management systems</p> </li> <li><p><code>FeederModel</code>: Distribution feeder models with support for single-phase unbalanced networks used in North America.</p> </li> </ul> <p>Centralized or distributed representations of the power system network model can be used. Centralized models use a single labeled property graph for the network. Distributed models use nested <code>DistributedArea</code> class instances to represent the grouping of equipment inside a Substation, VoltageLevel, Bay, Feeder, and switch-delimited topological area inside a combined T+D model.</p>"},{"location":"01_overview/1_1_overview/#application-layer","title":"Application Layer\u00b6","text":"<p>T+D applications are able to access all of the power system objects through knowledge graph, without any need to connect to the database or perform any custom i/o operations.</p>"},{"location":"01_overview/1_1_overview/#importing-cimantic-graphs","title":"Importing CIMantic Graphs\u00b6","text":"<p>CIMantic Graphs contains several modules within the core library:</p> <ul> <li><p><code>data_profiles</code>: This package contains full CIM profiles exported through CIMTool and provides direct access to CIM dataclasses, their attributes, and usage documentation.</p> </li> <li><p><code>databases</code>: This package contains database i/o connections and backend query handling for multiple databases (e.g. Blazegraph, GraphDB, Neo4J, MySQL, etc.).</p> </li> <li><p><code>models</code>: This package contains knowledge graph models for transmission node-breaker, transmission bus-branch, and distribution feeder models.</p> </li> <li><p><code>queries</code>: This package contains generic queries that are built at runtime for any CIM profile and CIM class.</p> </li> <li><p><code>utils</code>: This package contains shortcut methods for common routines, such as writing out new files.</p> </li> </ul>"},{"location":"01_overview/1_1_overview/#importing-the-cim-profile","title":"Importing the CIM Profile\u00b6","text":"<p>The first step in using CIMantic Graphs is to import the python data profile for desired CIM profile. The data profile provides the ability to invoke CIM classes directly based on their name.</p>"},{"location":"01_overview/1_1_overview/#invoking-cim-classes","title":"Invoking CIM classes\u00b6","text":""},{"location":"01_overview/1_1_overview/#specifying-environment-variables","title":"Specifying Environment Variables\u00b6","text":"<p>The next step in using any of the CIMantic Graphs library classes to establish the connection parameters for reading or writing the CIM model through a set of environment variables. The specific set of environment variables depends on the particular database used.</p>"},{"location":"01_overview/1_1_overview/#connecting-to-the-data-source","title":"Connecting to the Data Source\u00b6","text":"<p>The next step is to connect to the database or file source that will be used for CIM model. A complete list of connection types currently supported are described in Supported Databases</p>"},{"location":"01_overview/1_1_overview/#creating-a-container-and-graph-model","title":"Creating a Container and Graph Model\u00b6","text":"<p>CIMantic Graphs uses an EquipmentContainer class as the starting point for building a knowledge graph of the power system model. The supported classes are <code>BusBranchModel</code>, <code>NodeBreakerModel</code>, and <code>FeederModel</code>.</p>"},{"location":"01_overview/1_1_overview/#automated-database-queries","title":"Automated Database Queries\u00b6","text":"<p>CIMantic Graphs contains automatic query generation routines for all classes and all supported databases using the <code>.get_all_edges(cim.ClassName)</code> method. This query obtains all attributes for all objects of that class type and expands the knowledge graph by one edge with default instances of all associated objects.</p>"},{"location":"01_overview/1_1_overview/#traversing-the-knowledge-graph","title":"Traversing the Knowledge Graph\u00b6","text":"<p>CIMantic Graphs associates CIM classes by creating direct references between in-memory object instances based on the naming and hierarchy of the underlying information model.</p>"},{"location":"01_overview/1_1_overview/#utils-shortcuts","title":"Utils Shortcuts\u00b6","text":"<p>CIM-Graph provides several shortcut methods using the utils library for file writing, simplified queries, diagram creation, and class visualization.</p> <p>The utils module can be imported using</p>"},{"location":"01_overview/1_1_overview/#shortcuts-for-bulk-queries","title":"Shortcuts for Bulk Queries\u00b6","text":"<p>The utils module offers several shortcut methods for querying for all relevant classes involving lines, transformers, capacitors, or everything in the model. These methods are documented in Utils Get All Data. Due to the size of the queries (which are parsing tens of thousands of objects), completion can take a few seconds to a minute for large models.</p> <p>For example, the method to get all line data (including phasing, asset info, lower triangulare impedances, etc.) is</p>"},{"location":"01_overview/1_1_overview/#shortcuts-for-file-writers","title":"Shortcuts for File Writers\u00b6","text":"<p>The utils module offers writers for XML, JSON-LD, and CSV formats for new and existing models. The arguments for the writers are the network GraphModel and filename / file directory:</p>"},{"location":"01_overview/1_1_overview/#shortcuts-for-visualization","title":"Shortcuts for Visualization\u00b6","text":"<p>CIM-Graph offers automatic diagram creation for classes, object instances, and graph traversal paths using mermaid.js. The diagrams are plain text (enabling git tracking) and can be rendered in markdown and most web tools. Full documentation on use of the utils module to create diagrams is provided in Mermaid Diagramming.</p> <p>When running in a Jupyter notebook, the <code>mermaid-python</code> library can be used to display the generated diagrams and can be imported using</p>"},{"location":"01_overview/1_2_installation/","title":"Installation","text":"In\u00a0[\u00a0]: Copied! <pre>import cimgraph\nimport cimgraph.data_profile.rc4_2021 as cim\n\n# Create a simple CIM object\nbreaker = cim.Breaker(name=\"test_breaker\", open=False)\nprint(f\"Created breaker: {breaker.name}\")\nprint(f\"Status: {'Open' if breaker.open else 'Closed'}\")\n</pre> import cimgraph import cimgraph.data_profile.rc4_2021 as cim  # Create a simple CIM object breaker = cim.Breaker(name=\"test_breaker\", open=False) print(f\"Created breaker: {breaker.name}\") print(f\"Status: {'Open' if breaker.open else 'Closed'}\") In\u00a0[\u00a0]: Copied! <pre># Run this after activating your virtual environment\nimport cimgraph\nimport cimgraph.data_profile.cimhub_2023 as cim\n\n# Test creating objects\nsubstation = cim.Substation(name=\"Test Substation\")\nbreaker = cim.Breaker(name=\"Breaker 1\", open=False)\nbreaker.EquipmentContainer = substation\n\nprint(f\"Substation: {substation.name}\")\nprint(f\"Breaker: {breaker.name}\")\nprint(f\"Breaker container: {breaker.EquipmentContainer.name}\")\n</pre> # Run this after activating your virtual environment import cimgraph import cimgraph.data_profile.cimhub_2023 as cim  # Test creating objects substation = cim.Substation(name=\"Test Substation\") breaker = cim.Breaker(name=\"Breaker 1\", open=False) breaker.EquipmentContainer = substation  print(f\"Substation: {substation.name}\") print(f\"Breaker: {breaker.name}\") print(f\"Breaker container: {breaker.EquipmentContainer.name}\")"},{"location":"01_overview/1_2_installation/#installation","title":"Installation\u00b6","text":"<p>This guide will walk you through installing CIMantic Graphs either from PyPI or from source using UV.</p>"},{"location":"01_overview/1_2_installation/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Before you start, make sure you have:</p> <ul> <li>Python 3.10+ - Download Python</li> <li>pip - Included with Python 3.4+</li> </ul>"},{"location":"01_overview/1_2_installation/#optional-external-databases","title":"Optional: External Databases\u00b6","text":"<p>CIMantic Graphs can work with several external databases:</p> <ul> <li>Blazegraph - RDF triple store</li> <li>Neo4j - Graph database</li> <li>GraphDB - RDF database</li> <li>MySQL - Relational database</li> </ul> <p>These databases are optional - CIMantic Graphs can also work with local files (XML, JSON-LD, RDF) without any database.</p> <p>A sample Docker Compose file is provided in the CIM-Graph repository to quickly set up the databases with correct configurations:</p> <pre>docker-compose up -d\n</pre>"},{"location":"01_overview/1_2_installation/#installing-from-pypi","title":"Installing from PyPI\u00b6","text":"<p>The easiest way to install CIMantic Graphs is from PyPI using pip:</p> <pre>pip install cim-graph\n</pre> <p>To install with development dependencies:</p> <pre>pip install cim-graph[dev]\n</pre>"},{"location":"01_overview/1_2_installation/#verify-installation","title":"Verify Installation\u00b6","text":"<p>After installation, verify it works:</p>"},{"location":"01_overview/1_2_installation/#installing-from-source","title":"Installing from Source\u00b6","text":"<p>For development or to use the latest unreleased features, you can install from source using UV.</p>"},{"location":"01_overview/1_2_installation/#why-uv","title":"Why UV?\u00b6","text":"<p>UV is a fast Python package installer and resolver written in Rust. It's:</p> <ul> <li>10-100x faster than pip</li> <li>Drop-in replacement for pip and pip-tools</li> <li>Built-in virtual environment management</li> <li>Reproducible installs with lock files</li> </ul> <p>CIMantic Graphs uses UV as its primary build tool.</p>"},{"location":"01_overview/1_2_installation/#installing-uv","title":"Installing UV\u00b6","text":""},{"location":"01_overview/1_2_installation/#install-with-pip","title":"Install with pip\u00b6","text":"<pre>pip install uv\n</pre> <p>Verify UV is installed:</p> <pre>uv --version\n</pre>"},{"location":"01_overview/1_2_installation/#clone-the-repository","title":"Clone the Repository\u00b6","text":"<p>First, clone the CIM-Graph repository:</p> <pre>git clone https://github.com/PNNL-CIM-Tools/CIM-Graph.git\ncd CIM-Graph\n</pre> <p>To clone a specific branch (e.g., <code>develop</code>):</p> <pre>git clone https://github.com/PNNL-CIM-Tools/CIM-Graph.git -b develop\ncd CIM-Graph\n</pre>"},{"location":"01_overview/1_2_installation/#install-with-uv","title":"Install with UV\u00b6","text":"<p>UV automatically creates a virtual environment and installs all dependencies.</p>"},{"location":"01_overview/1_2_installation/#basic-installation","title":"Basic Installation\u00b6","text":"<p>Install CIMantic Graphs and all dependencies:</p> <pre>uv sync\n</pre> <p>This command:</p> <ol> <li>Creates a virtual environment in <code>.venv/</code> (if it doesn't exist)</li> <li>Installs all dependencies from <code>pyproject.toml</code></li> <li>Installs CIMantic Graphs in editable mode</li> </ol>"},{"location":"01_overview/1_2_installation/#install-with-development-dependencies","title":"Install with Development Dependencies\u00b6","text":"<p>To also install development tools (pytest, pre-commit, etc.):</p> <pre>uv sync --extra dev\n</pre> <p>Or use the shorthand:</p> <pre>uv sync --all-extras\n</pre>"},{"location":"01_overview/1_2_installation/#activate-the-virtual-environment","title":"Activate the Virtual Environment\u00b6","text":"<p>After running <code>uv sync</code>, activate the virtual environment:</p>"},{"location":"01_overview/1_2_installation/#linux-macos-and-wsl2","title":"Linux, macOS, and WSL2\u00b6","text":"<pre>source .venv/bin/activate\n</pre>"},{"location":"01_overview/1_2_installation/#windows-powershell","title":"Windows PowerShell\u00b6","text":"<pre>.venv\\Scripts\\Activate.ps1\n</pre>"},{"location":"01_overview/1_2_installation/#windows-command-prompt","title":"Windows Command Prompt\u00b6","text":"<pre><code>cmd\n.venv\\Scripts\\activate.bat\n</code></pre> <p>You should see <code>(.venv)</code> at the beginning of your command prompt.</p>"},{"location":"01_overview/1_2_installation/#common-uv-commands","title":"Common UV Commands\u00b6","text":"<p>Here are some useful UV commands for working with CIMantic Graphs:</p>"},{"location":"01_overview/1_2_installation/#add-a-new-dependency","title":"Add a New Dependency\u00b6","text":"<pre>uv add &lt;package-name&gt;\n</pre>"},{"location":"01_overview/1_2_installation/#add-a-development-dependency","title":"Add a Development Dependency\u00b6","text":"<pre>uv add --dev &lt;package-name&gt;\n</pre>"},{"location":"01_overview/1_2_installation/#update-dependencies","title":"Update Dependencies\u00b6","text":"<pre>uv sync --upgrade\n</pre>"},{"location":"01_overview/1_2_installation/#run-a-command-in-the-virtual-environment","title":"Run a Command in the Virtual Environment\u00b6","text":"<pre>uv run python script.py\nuv run pytest\n</pre>"},{"location":"01_overview/1_2_installation/#build-distribution-packages","title":"Build Distribution Packages\u00b6","text":"<pre>uv build\n</pre> <p>This creates wheel and source distribution in <code>dist/</code> directory.</p>"},{"location":"01_overview/1_2_installation/#install-built-package-elsewhere","title":"Install Built Package Elsewhere\u00b6","text":"<p>After building, you can install the wheel in another environment:</p> <pre># From another environment\npip install /path/to/CIM-Graph/dist/cim_graph-0.4.3a8-py3-none-any.whl\n</pre>"},{"location":"01_overview/1_2_installation/#verify-source-installation","title":"Verify Source Installation\u00b6","text":"<p>After installing from source, verify everything works:</p>"},{"location":"01_overview/1_2_installation/#next-steps","title":"Next Steps\u00b6","text":"<p>Now that you have CIMantic Graphs installed, you can:</p> <ol> <li>Learn the library structure - See Structure</li> <li>Connect to databases - See Databases Overview</li> <li>Work with CIM profiles - See Profiles Overview</li> <li>Build graph models - See Graph Models</li> <li>Try the Quick Start - See Overview</li> </ol>"},{"location":"01_overview/1_2_installation/#common-issues","title":"Common Issues\u00b6","text":"<p>ModuleNotFoundError: No module named 'cimgraph'</p> <ul> <li>Make sure you activated the virtual environment</li> <li>Try running <code>uv sync</code> again</li> </ul> <p>UV command not found</p> <ul> <li>Add UV to your PATH or restart your terminal</li> <li>Try reinstalling UV</li> </ul> <p>Import errors with dependencies</p> <ul> <li>Run <code>uv sync --upgrade</code> to update all dependencies</li> <li>Check that you have Python 3.10 or higher</li> </ul>"},{"location":"01_overview/1_3_structure/","title":"Structure","text":"<p>CIMantic Graphs uses the layered architecture shown below:</p> <p></p>"},{"location":"01_overview/1_3_structure/#cim-graph-library-structure","title":"CIM-Graph Library Structure\u00b6","text":""},{"location":"01_overview/1_3_structure/#database-layer","title":"Database Layer\u00b6","text":"<p>CIMantic Graphs currently supports the following databases and interfaces:</p> <ul> <li><p>Blazegraph Database</p> </li> <li><p>GraphDB Database</p> </li> <li><p>Neo4J Database</p> </li> <li><p>MySQL Database (in progress)</p> </li> <li><p>GridAPPS-D Platform</p> </li> <li><p>AVEVA PI Asset Framework (in progress)</p> </li> <li><p>RDFLib File Parser</p> </li> <li><p>XML Flat Files</p> </li> <li><p>JSON-LD Flat Files (in progress)</p> </li> <li><p>CSV Flat Files (in progress)</p> </li> </ul> <p>The library uses a unified syntax for all upper-level calls and routines. The databases can be swapped interchangeably by changing the environment variables specified during application startup, with no other changes to any other application syntax or methods</p>"},{"location":"01_overview/1_3_structure/#data-profile-layer","title":"Data Profile Layer\u00b6","text":"<p>CIMantic Graphs is able to support any standard or custom CIM profile. The CIM profile needs to be exported as an XSD data profile / schema. CIMantic Graphs is then able to ingest the data profile and convert all UML classes and attributes to python dataclasses, which power all of the routines and unified API syntax</p>"},{"location":"01_overview/1_3_structure/#api-layer","title":"API Layer\u00b6","text":"<p>CIMantic Graphs offers a breakthrough in terms of ease-of-use through a unified API with two core methods.</p> <p>Access to labeled property graph objects:</p> <ul> <li><code>network.graph[cim.ClassName]</code>: This offers access to a catalog of CIM object instances stored in memory and sorted by class type and mRID forming the named property graph.</li> </ul> <p>Universal database query method:</p> <ul> <li><code>network.get_all_edges(cim.ClassName)</code>: This is a universal query method that gets all attributes and all objects one edge away from instances of the specified class. This method works for all CIM classes, CIM profiles, serialization formats, and supported databases.</li> </ul>"},{"location":"01_overview/1_3_structure/#knowledge-graph-layer","title":"Knowledge Graph Layer\u00b6","text":"<p>CIMantic Graphs offers three core knowledge graph classes for handing various kinds of power system models:</p> <ul> <li><p><code>BusBranchModel</code>: Transmission bus-branch models commonly used for planning and power flow studies</p> </li> <li><p><code>NodeBreakerModel</code>: Transmission node-breaker models commonly used inside energy management systems</p> </li> <li><p><code>FeederModel</code>: Distribution feeder models with support for single-phase unbalanced networks used in North America.</p> </li> </ul> <p>Centralized or distributed representations of the power system network model can be used. Centralized models use a single labeled property graph for the network. Distributed models use nested <code>DistributedArea</code> class instances to represent the grouping of equipment inside a Substation, VoltageLevel, Bay, Feeder, and switch-delimited topological area inside a combined T+D model.</p>"},{"location":"01_overview/1_3_structure/#application-layer","title":"Application Layer\u00b6","text":"<p>T+D applications are able to access all of the power system objects through knowledge graph, without any need to connect to the database or perform any custom i/o operations.</p>"},{"location":"01_overview/1_4_contributing/","title":"Contributing","text":""},{"location":"01_overview/1_4_contributing/#contribution-guidelines","title":"Contribution Guidelines\u00b6","text":"<p>We welcome contributions to our project! To maintain a high standard of quality, we have a set of guidelines and processes for making contributions. Please follow these guidelines to ensure your contributions can be easily reviewed and accepted.</p>"},{"location":"01_overview/1_4_contributing/#table-of-contents","title":"Table of Contents\u00b6","text":"<ol> <li>Getting Started</li> <li>How to Contribute<ul> <li>Fork the Repository</li> <li>Create a Branch</li> <li>Make Changes</li> <li>Commit Changes</li> <li>Push to GitHub</li> <li>Submit a Pull Request</li> </ul> </li> <li>Coding Standards</li> <li>Review Process</li> <li>Code of Conduct</li> </ol>"},{"location":"01_overview/1_4_contributing/#getting-started","title":"Getting Started\u00b6","text":"<p>To get started with contributing to our project, you should have the following:</p> <ol> <li>A GitHub account.</li> <li>Git installed on your local machine.</li> <li>A text editor or IDE of your choice (we recommend VSCode or PyCharm).</li> </ol>"},{"location":"01_overview/1_4_contributing/#how-to-contribute","title":"How to Contribute\u00b6","text":""},{"location":"01_overview/1_4_contributing/#fork-the-repository","title":"Fork the Repository\u00b6","text":"<ol> <li>Go to the repository on GitHub.</li> <li>Click on the <code>Fork</code> button at the top right of the page.</li> <li>This will create a copy of the repository in your GitHub account.</li> </ol>"},{"location":"01_overview/1_4_contributing/#create-a-branch","title":"Create a Branch\u00b6","text":"<ol> <li>Clone the forked repository to your local machine:<pre>git clone https://github.com/YOUR_USERNAME/REPOSITORY_NAME.git\n</pre> </li> <li>Navigate to the repository directory:<pre>cd REPOSITORY_NAME\n</pre> </li> <li>Create a new branch for your changes:<pre>git checkout -b feature/your-feature-name\n</pre> </li> </ol>"},{"location":"01_overview/1_4_contributing/#make-changes","title":"Make Changes\u00b6","text":"<ol> <li>Make the necessary changes in your local repository.</li> <li>Ensure that your code adheres to the Coding Standards.</li> </ol>"},{"location":"01_overview/1_4_contributing/#commit-changes","title":"Commit Changes\u00b6","text":"<ol> <li><p>Stage your changes:</p> <pre>git add .\n</pre> </li> <li><p>Commit your changes with a descriptive message:</p> <pre>git commit -S -m \"Add feature: Description of your feature\"\n</pre> <p>Note: All commits must be signed. You can configure commit signing by following these instructions.</p> </li> </ol>"},{"location":"01_overview/1_4_contributing/#push-to-github","title":"Push to GitHub\u00b6","text":"<ol> <li>Push your branch to GitHub:<pre>git push origin feature/your-feature-name\n</pre> </li> </ol>"},{"location":"01_overview/1_4_contributing/#submit-a-pull-request","title":"Submit a Pull Request\u00b6","text":"<ol> <li>Go to the original repository on GitHub.</li> <li>Click on the <code>Pull Requests</code> tab.</li> <li>Click on the <code>New Pull Request</code> button.</li> <li>Select your branch from the dropdown menu.</li> <li>Submit the pull request with a clear and descriptive title and description.</li> </ol>"},{"location":"01_overview/1_4_contributing/#coding-standards","title":"Coding Standards\u00b6","text":"<p>To ensure consistency and maintainability, please follow these coding standards:</p> <ol> <li>PEP 8: Follow the PEP 8 style guide for Python code.</li> <li>Docstrings: Use clear and descriptive docstrings for all functions and classes.</li> <li>Type Annotations: Use type annotations to specify the expected data types of function arguments and return values.</li> <li>Testing: Write unit tests for your code and ensure all tests pass before submitting a pull request.</li> </ol>"},{"location":"01_overview/1_4_contributing/#review-process","title":"Review Process\u00b6","text":"<ol> <li>Once you submit a pull request, it will be reviewed by one of the maintainers.</li> <li>Maintain a positive attitude and be open to feedback. Review comments may request changes to your code.</li> <li>Make the necessary changes and update the pull request. Ensure all commits are signed.</li> <li>Once the pull request is approved, it will be merged into the main branch.</li> </ol>"},{"location":"01_overview/1_4_contributing/#code-of-conduct","title":"Code of Conduct\u00b6","text":"<p>We are committed to fostering a welcoming and inclusive community. By participating in this project, you agree to abide by our standards of professional engagement adopted from the IEEE Code of Conduct.</p> <p>Thank you for your contributions! We appreciate your efforts to improve our project.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/","title":"Profiles Overview","text":"<p>One of the common misconceptions regarding the CIM is that the entire information model must be adopted and implemented. As an enterprise-focused canonical information model, the full CIM covers an extremely broad range of aspects of modeling, operations, billing, asset management, and energy markets. Any given application or even an entire data-rich environment will only need a small subset of the full common information model.</p> <p>When choosing CIM for a particular project, application, and data integration effort, it is important to consider the particular use case, what functional objectives must be met, and what is the minimum number of attributes that must be modeled to meet the identified requirements. This section will briefly discuss some of the consideration involved in selecting a CIM profile, building a data profile, populating that profile with power system data, and then selecting a database structure to contain that data.</p> In\u00a0[\u00a0]: Copied! <pre># Inspect attributes of a specific class\nfrom dataclasses import fields\n\nprint(\"\\\\nACLineSegment attributes:\")\nfor field in fields(cim.ACLineSegment):\n    field_type = field.metadata.get('type', 'unknown')\n    print(f\"  - {field.name}: {field_type}\")\n    if field_type == 'Association':\n        inverse = field.metadata.get('inverse', '')\n        print(f\"      (inverse: {inverse})\")\n</pre> # Inspect attributes of a specific class from dataclasses import fields  print(\"\\\\nACLineSegment attributes:\") for field in fields(cim.ACLineSegment):     field_type = field.metadata.get('type', 'unknown')     print(f\"  - {field.name}: {field_type}\")     if field_type == 'Association':         inverse = field.metadata.get('inverse', '')         print(f\"      (inverse: {inverse})\") In\u00a0[\u00a0]: Copied! <pre># Import a CIM profile (CIM 17 version 40)\nimport cimgraph.data_profile.cim17v40 as cim\n\n# Inspect what classes are available\nprint(\"Sample classes in this profile:\")\nprint(f\"  - {cim.ACLineSegment}\")\nprint(f\"  - {cim.PowerTransformer}\")\nprint(f\"  - {cim.EnergyConsumer}\")\nprint(f\"  - {cim.Terminal}\")\nprint(f\"  - {cim.ConnectivityNode}\")\n</pre> # Import a CIM profile (CIM 17 version 40) import cimgraph.data_profile.cim17v40 as cim  # Inspect what classes are available print(\"Sample classes in this profile:\") print(f\"  - {cim.ACLineSegment}\") print(f\"  - {cim.PowerTransformer}\") print(f\"  - {cim.EnergyConsumer}\") print(f\"  - {cim.Terminal}\") print(f\"  - {cim.ConnectivityNode}\")"},{"location":"02_cim_profiles/2_1_profiles_overview/#overview-of-cim-profiles","title":"Overview of CIM Profiles\u00b6","text":""},{"location":"02_cim_profiles/2_1_profiles_overview/#what-is-a-cim-profile","title":"What is a CIM Profile?\u00b6","text":"<p>Before introducing physical models, a clear understanding of profiles is essential. Profiles are defined as secondary models derived from the information model. Profiles must be based on classes, attributes, and associations contained in the CIM information model. They can never introduce anything new beyond what exists in the CIM UML (formed from canonical classes and custom user extension classes)</p> <p>The purpose of profiles is to identify a subset of the information model to meet a particular need. Profiles can:</p> <ul> <li>Constrain cardinality of attributes</li> <li>Remove unwanted attributes and classes</li> <li>Represent structures required for specific applications</li> <li>Focus on particular domains (equipment, topology, geography, state estimation, etc.)</li> </ul> <p>After completing the logical model in UML, profiles can be derived to depict structures that support specific topics such as equipment profiles, geographical profiles, single state hypothesis profiles, and topology profiles.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#summary-and-next-steps","title":"Summary and Next Steps\u00b6","text":"<p>This overview introduced the key concepts of CIM profiling:</p> <ol> <li>Profiles are subsets of the full CIM information model tailored to specific use cases</li> <li>Data profiles are physical serializations of CIM profiles (XML, JSON, Python dataclasses)</li> <li>Profile selection involves understanding business processes, use cases, and minimum required information</li> <li>mRIDs (Master Resource Identifiers) are critical for consistent cross-application integration</li> <li>CIMantic Graphs uses Python dataclass schemas as data profiles for native Python integration</li> </ol>"},{"location":"02_cim_profiles/2_1_profiles_overview/#whats-next","title":"What's Next:\u00b6","text":"<ul> <li>Building Profiles - Learn how to create custom profiles using CIMTool</li> <li>Using Objects - Work with CIM dataclass objects in Python</li> <li>Incrementals - Manage model changes and updates</li> <li>Units - Handle physical quantities with proper unit conversion</li> </ul> <p>The following notebooks will dive deeper into each of these topics with practical examples.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#example-importing-a-cim-profile","title":"Example: Importing a CIM Profile\u00b6","text":"<p>Let's see how to import and inspect a CIM profile in CIMantic Graphs:</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#cimantic-graphs-and-python-data-profiles","title":"CIMantic Graphs and Python Data Profiles\u00b6","text":"<p>CIMantic Graphs provides a Python-native approach to working with CIM profiles. Instead of XML or JSON schemas, it uses Python dataclass schemas as the data profile format.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#advantages-of-python-dataclasses","title":"Advantages of Python Dataclasses:\u00b6","text":"<ol> <li>Native Python Integration - Classes can be imported and used directly in Python code</li> <li>Type Hints - Full support for Python type checking and IDE autocomplete</li> <li>Introspection - Easy to programmatically inspect attributes, types, and metadata</li> <li>In-Memory Graphs - Efficient knowledge graph representation in memory</li> <li>Auto-Generated Queries - Database queries generated directly from dataclass structure</li> </ol>"},{"location":"02_cim_profiles/2_1_profiles_overview/#the-cimtool-builder-workflow","title":"The CIMTool Builder Workflow:\u00b6","text":"<ol> <li>Create or select a CIM Profile in CIMTool (UML-based)</li> <li>Use the cimantic-graphs.xsl builder to generate Python dataclass schema</li> <li>Use the cimantic-graphs-init.xsl builder to generate <code>__init__.py</code></li> <li>Place generated files in <code>cimgraph/data_profile/your_profile_name/</code></li> <li>Import and use: <code>import cimgraph.data_profile.your_profile_name as cim</code></li> </ol> <p>This approach maintains all the benefits of CIM profiling while providing a Pythonic development experience.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#7-the-critical-role-of-mrids-master-resource-identifiers","title":"7. The Critical Role of mRIDs (Master Resource Identifiers)\u00b6","text":"<p>One of the most critical aspects of populating CIM models is establishing persistent Universally Unique Identifiers (UUIDs) to be used as Master Resource Identifiers (mRIDs) for all network parameters, asset characteristics, and SCADA measurements.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#why-mrids-matter","title":"Why mRIDs Matter:\u00b6","text":"<ol> <li><p>Cross-Application Consistency - All applications in the data integration effort must refer to equipment by the same mRID. Inconsistent mRIDs require mapping tables, defeating the purpose of CIM-based integration.</p> </li> <li><p>Data Mapping Stability - Changes to mRIDs affect other data mappings (e.g., SCADA measurements to assets). Persistent mRIDs ensure edits to network models don't break other data mappings.</p> </li> <li><p>Inter-Utility Exchange - When exchanging data between utilities:</p> <ul> <li>Option 1: Use the same mRIDs across both utilities (requires coordination and master lists)</li> <li>Option 2: Create reference tables converting mRIDs between utilities</li> </ul> </li> </ol> <p>Best Practice: Use UUID format (RFC 4122) for mRIDs to ensure global uniqueness.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#measurement-mrids","title":"Measurement mRIDs\u00b6","text":"<p>CIM requires every measurement or data source be assigned a unique mRID associated with one terminal of equipment:</p> <ul> <li>PT voltage measurement \u2192 unique mRID \u2192 associated with Terminal</li> <li>CT current measurement \u2192 unique mRID \u2192 associated with Terminal</li> <li>Calculated MW/MVAr/MVA \u2192 unique mRIDs \u2192 associated with Terminal</li> </ul> <p>This approach simplifies real-time publishing: measurements can be sent as simple <code>{\"meas-mrid-1234\": value}</code> pairs without additional metadata, since all context is in the network model.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#6-populate-the-data-profile-with-network-model-data","title":"6. Populate the Data Profile with Network Model Data\u00b6","text":"<p>Populating the data profile with actual power system data typically requires custom scripts that:</p> <ol> <li>Interpret the empty data profile structure</li> <li>Read source data from existing tools (PSLF, OpenDSS, etc.)</li> <li>Build XML, JSON, or other format files containing actual network model data</li> </ol> <p>Validation: Multiple validation levels ensure data quality:</p> <ul> <li>Syntactic validation - XML parsers check if files are \"well-formed\"</li> <li>Semantic validation - XSD/JSON schemas ensure objects and attributes are defined correctly</li> <li>Ontological validation - RDFS and OWL ensure the model follows CIM vocabulary</li> </ul> <p>To date, no convenient tools exist for building distribution feeders or transmission networks natively in CIM format. The practical approach is to build models in existing tools and convert them to CIM.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#5-create-a-data-profile","title":"5. Create a Data Profile\u00b6","text":"<p>Once a CIM Profile has been selected or created, create a data profile to contain the power system network model. Remember: the data profile is not the data itself\u2014it's an empty file structure specifying how data should be organized.</p> <p>Data profiles may be derived directly from UML information models or UML profiles. Common formats include:</p> <ul> <li>XML Schema Definition (XSD) - Popular for validating XML files</li> <li>JSON Schema - Identical in structure to Python dictionaries, easily parsed</li> <li>Relational DDL - For SQL databases</li> <li>RDF Serialization - For semantic web applications</li> <li>Python Dataclasses - Used by CIMantic Graphs</li> </ul>"},{"location":"02_cim_profiles/2_1_profiles_overview/#layered-data-profiles","title":"Layered Data Profiles\u00b6","text":"<p>Data profiles can be layered like GIS layers to build up complete power system representations:</p> <ol> <li>Topology Profile - Describes how buses, switches, and branches connect (connectivity using CIM vocabulary)</li> <li>Equipment Profile - Contains nameplate info, physical characteristics, line impedances</li> <li>Geographical Profile - Provides geospatial information about asset locations</li> <li>State Profile - Represents dynamic operational states and measurements</li> </ol> <p>This layered approach provides flexibility in what information is exchanged and stored.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#4-identify-the-required-classes-and-attributes","title":"4. Identify the Required Classes and Attributes\u00b6","text":"<p>Once the minimum required information has been identified, reduce the CIM information model to a much smaller profile with only the classes, attributes, and associations that are needed. This custom subset is your CIM Profile.</p> <p>Example: For DER-to-substation topology mapping, an extremely small profile suffices:</p> <ul> <li><code>ACLineSegment</code></li> <li><code>LoadBreakSwitch</code></li> <li><code>PowerTransformerEnd</code></li> <li><code>SynchronousMachine</code></li> <li><code>PowerElectronicsConnection</code></li> <li><code>ConnectivityNode</code></li> <li><code>ACDCTerminal</code></li> </ul> <p>If power flow solutions aren't needed, classes like <code>PhaseImpedanceData</code>, <code>TransformerMeshImpedance</code>, and <code>RatioTapChanger</code> can be omitted.</p> <p>You can build a custom CIM profile using open-source tools like CIMTool or adopt an existing tested profile. If extensions beyond the base CIM are needed (e.g., home appliances, DER control attributes), involve a domain expert with expertise in both power systems and information modeling.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#3-identify-the-required-information-to-be-modeled","title":"3. Identify the Required Information to be Modeled\u00b6","text":"<p>Although it's possible to use the entire CIM to represent every object and attribute in the power system, it's more practical to reduce the modeling scope to the minimum information required to accomplish the functional objectives. This requires careful consideration of:</p> <ul> <li>What data needs to be exchanged</li> <li>Whether a full power flow solution is needed</li> <li>The level of modeling accuracy required</li> </ul> <p>Example: For a DER-to-substation mapping application, the minimum required information is simply a topology model of the network connectivity (lines, transformers, switches, DERs). Detailed modeling of line geometry, transformer impedances, tap settings, and reactive control modes is unnecessary since these don't impact connectivity.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#2-identify-the-use-case-for-cim","title":"2. Identify the Use Case for CIM\u00b6","text":"<p>The next step is identifying the particular use case for adopting CIM and the scope of data integration required. Possible approaches include:</p> <ul> <li>Project-Level: Strictly using CIM to exchange base power system models between applications</li> <li>Platform-Level: Integrating applications through a common message bus with CIM-compliant messaging and models</li> <li>Integrated Environment: Creating a data-rich environment using CIM classes, attributes, and message formats to the greatest extent possible</li> </ul> <p>The decision depends on the particular use case and types of data that need to be exchanged. For real-time applications requiring topology mapping with SCADA data, DER dispatch commands, and dynamic switch positions, a CIM-based message bus is more practical than point-to-point exchanges.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#steps-for-selecting-and-creating-a-cim-profile","title":"Steps for Selecting and Creating a CIM Profile\u00b6","text":""},{"location":"02_cim_profiles/2_1_profiles_overview/#1-understand-business-planning-and-operations-processes","title":"1. Understand Business, Planning, and Operations Processes\u00b6","text":"<p>Adoption of the CIM cannot occur in a vacuum and should consider the set of operational procedures and business processes that will be impacted. This process involves:</p> <ul> <li>Understanding organizational units and groups involved</li> <li>Documenting existing operational procedures</li> <li>Identifying current data storage formats</li> <li>Mapping legacy application interfaces and data streams</li> <li>Translating requirements into functional objectives and performance specifications</li> </ul> <p>Important Consideration: If the project involves operations or planning decisions, ensure data is presented in a format meaningful to operators and dispatchers. Many CIM components are not human-readable in traditional operations contexts, so proper human factors engineering is essential to avoid adding cognitive workload in high-stress control room environments.</p>"},{"location":"02_cim_profiles/2_1_profiles_overview/#cim-profile-vs-data-profile","title":"CIM Profile vs Data Profile\u00b6","text":"<p>It's important to distinguish between these two related but distinct concepts:</p> <p>CIM Profile: A UML-based subset of the CIM information model defining which classes, attributes, and associations are needed for a specific application or use case.</p> <p>Data Profile: A serialization of a CIM Profile into a specific physical data structure (repository or stream). Examples include:</p> <ul> <li>JavaScript Object Notation (JSON) schema</li> <li>eXtensible Schema Definition (XSD) schema</li> <li>Relational data definition language (DDL)</li> <li>Resource Description Framework (RDF) serialization</li> <li>Python dataclass schemas (used by CIMantic Graphs)</li> </ul> <p>The data profile is not the power system data itself\u2014it's an empty file structure specifying how network model data should be organized.</p>"},{"location":"02_cim_profiles/2_2_building_profiles/","title":"Building Profiles","text":"In\u00a0[\u00a0]: Copied! <pre># Import your custom profile\nimport cimgraph.data_profile.my_custom_profile as cim\n\n# Or set it as the default profile\nimport os\nos.environ['CIMG_CIM_PROFILE'] = 'my_custom_profile'\n\n# Create objects using your profile\nline = cim.ACLineSegment(\n    mRID='line-001',\n    name='Feeder_Line_1'\n)\n\nterminal = cim.Terminal(\n    mRID='term-001',\n    name='Line_Terminal_1'\n)\n\nprint(f\"Created {line.name} with mRID: {line.mRID}\")\nprint(f\"Created {terminal.name} with mRID: {terminal.mRID}\")\n</pre> # Import your custom profile import cimgraph.data_profile.my_custom_profile as cim  # Or set it as the default profile import os os.environ['CIMG_CIM_PROFILE'] = 'my_custom_profile'  # Create objects using your profile line = cim.ACLineSegment(     mRID='line-001',     name='Feeder_Line_1' )  terminal = cim.Terminal(     mRID='term-001',     name='Line_Terminal_1' )  print(f\"Created {line.name} with mRID: {line.mRID}\") print(f\"Created {terminal.name} with mRID: {terminal.mRID}\") In\u00a0[\u00a0]: Copied! <pre>from dataclasses import dataclass, field\nfrom typing import Optional\n\n@dataclass\nclass IdentifiedObject:\n    '''\n    Root class providing common identification for all classes needing\n    identification and naming attributes.\n    '''\n    mRID: Optional[str] = field(\n        default=None,\n        metadata={\n            'type': 'Attribute',\n            'minOccurs': '0',\n            'maxOccurs': '1'\n        })\n    '''\n    Master resource identifier issued by a model authority. The mRID is unique\n    within an exchange context. Global uniqueness is easily achieved by using\n    a UUID, as specified in RFC 4122, for the mRID.\n    '''\n    \n    name: Optional[str] = field(\n        default=None,\n        metadata={\n            'type': 'Attribute',\n            'minOccurs': '0',\n            'maxOccurs': '1'\n        })\n\n@dataclass\nclass ACDCTerminal(IdentifiedObject):\n    '''\n    An electrical connection point (AC or DC) to a piece of conducting equipment.\n    Terminals are connected at physical connection points called connectivity nodes.\n    '''\n    BusNameMarker: Optional[str] = field(\n        default=None,\n        metadata={\n            'type': 'Association',\n            'minOccurs': '0',\n            'maxOccurs': '1',\n            'inverse': 'BusNameMarker.Terminal'\n        })\n    '''The bus name marker used to name the bus (topological node).'''\n\n@dataclass\nclass Terminal(ACDCTerminal):\n    '''\n    An AC electrical connection point to a piece of conducting equipment.\n    Terminals are connected at physical connection points called connectivity nodes.\n    '''\n    phases: Optional[str] = field(\n        default=None,\n        metadata={\n            'type': 'enumeration',\n            'minOccurs': '0',\n            'maxOccurs': '1'\n        })\n    \n    ConnectivityNode: Optional[str] = field(\n        default=None,\n        metadata={\n            'type': 'Association',\n            'minOccurs': '0',\n            'maxOccurs': '1',\n            'inverse': 'ConnectivityNode.Terminals'\n        })\n    '''The connectivity node to which this terminal connects.'''\n</pre> from dataclasses import dataclass, field from typing import Optional  @dataclass class IdentifiedObject:     '''     Root class providing common identification for all classes needing     identification and naming attributes.     '''     mRID: Optional[str] = field(         default=None,         metadata={             'type': 'Attribute',             'minOccurs': '0',             'maxOccurs': '1'         })     '''     Master resource identifier issued by a model authority. The mRID is unique     within an exchange context. Global uniqueness is easily achieved by using     a UUID, as specified in RFC 4122, for the mRID.     '''          name: Optional[str] = field(         default=None,         metadata={             'type': 'Attribute',             'minOccurs': '0',             'maxOccurs': '1'         })  @dataclass class ACDCTerminal(IdentifiedObject):     '''     An electrical connection point (AC or DC) to a piece of conducting equipment.     Terminals are connected at physical connection points called connectivity nodes.     '''     BusNameMarker: Optional[str] = field(         default=None,         metadata={             'type': 'Association',             'minOccurs': '0',             'maxOccurs': '1',             'inverse': 'BusNameMarker.Terminal'         })     '''The bus name marker used to name the bus (topological node).'''  @dataclass class Terminal(ACDCTerminal):     '''     An AC electrical connection point to a piece of conducting equipment.     Terminals are connected at physical connection points called connectivity nodes.     '''     phases: Optional[str] = field(         default=None,         metadata={             'type': 'enumeration',             'minOccurs': '0',             'maxOccurs': '1'         })          ConnectivityNode: Optional[str] = field(         default=None,         metadata={             'type': 'Association',             'minOccurs': '0',             'maxOccurs': '1',             'inverse': 'ConnectivityNode.Terminals'         })     '''The connectivity node to which this terminal connects.'''"},{"location":"02_cim_profiles/2_2_building_profiles/#building-profiles-with-cimtool","title":"Building Profiles with CIMTool\u00b6","text":""},{"location":"02_cim_profiles/2_2_building_profiles/#what-is-cimtool","title":"What is CIMTool?\u00b6","text":"<p>CIMTool is an open source tool maintained by the UCAIug CIM User Group community for working with the CIM canonical model to produce design artifacts such as database schemas, message exchange syntax, source code classes, and reference documentation.</p> <p>CIMTool operates on Contextual Profiles - UML-based subsets of the full CIM that define which classes, attributes, and associations are needed for a specific application. These Contextual Profiles are then used by \"builders\" (XSLT transforms) to generate various output formats.</p>"},{"location":"02_cim_profiles/2_2_building_profiles/#cimtool-capabilities","title":"CIMTool Capabilities\u00b6","text":"<p>CIMTool provides comprehensive functionality for profile management:</p>"},{"location":"02_cim_profiles/2_2_building_profiles/#profile-creation-and-management","title":"Profile Creation and Management\u00b6","text":"<ul> <li>Create Contextual Profiles from the CIM Unified Model Language (UML)</li> <li>Import Contextual Profiles from spreadsheets</li> <li>Constrain cardinality of attributes</li> <li>Remove unwanted classes and attributes</li> <li>Document profile-specific usage notes</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#schema-generation","title":"Schema Generation\u00b6","text":"<ul> <li>Generate Resource Description Framework Schema (RDF Schema) from Contextual Profiles</li> <li>Create XML Schema Definition (XSD) files</li> <li>Produce JSON schemas</li> <li>Generate custom formats using XSLT builders</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#validation","title":"Validation\u00b6","text":"<ul> <li>Validate Contextual Profile schemas against CIM UML</li> <li>Validate data instances against a Contextual Profile schema</li> <li>Validate incremental data instances against an existing instance</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#extensibility","title":"Extensibility\u00b6","text":"<ul> <li>Create custom builders using XSLT transforms</li> <li>Import custom builders to generate specialized outputs:<ul> <li>Word documentation</li> <li>SQL database scripts</li> <li>Python dataclass schemas (CIMantic Graphs)</li> <li>Custom application code</li> </ul> </li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#the-cimantic-graphs-custom-builder","title":"The CIMantic Graphs Custom Builder\u00b6","text":"<p>While CIMTool provides several built-in builders (RDF Schema, XSD, etc.), CIMantic Graphs uses a custom XSLT builder to generate Python-specific output.</p> <p>The CIMantic Graphs builder actually consists of two companion builders:</p> <ol> <li>cimantic-graphs.xsl - Generates the main Python dataclass schema file</li> <li>cimantic-graphs-init.xsl - Generates the <code>__init__.py</code> file for proper Python imports</li> </ol> <p>These builders transform a CIMTool Contextual Profile into a hierarchical tree of Python dataclasses that serve as the \"single-source-of-truth\" for:</p> <ul> <li>Database query generation</li> <li>Graph traversal algorithms</li> <li>Type checking and validation</li> <li>IDE autocomplete and introspection</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#generated-python-dataclass-structure","title":"Generated Python Dataclass Structure\u00b6","text":"<p>The CIMantic Graphs builder produces Python dataclasses with rich metadata that preserves all the semantic information from the CIM UML model.</p>"},{"location":"02_cim_profiles/2_2_building_profiles/#key-features-of-generated-dataclasses","title":"Key Features of Generated Dataclasses:\u00b6","text":"<ol> <li>Inheritance Hierarchy - Preserves CIM class inheritance (e.g., <code>Terminal</code> \u2192 <code>ACDCTerminal</code> \u2192 <code>IdentifiedObject</code>)</li> <li>Type Annotations - Full Python type hints for all attributes</li> <li>Field Metadata - Embedded UML metadata including:<ul> <li>Field type (Attribute, Association, enumeration)</li> <li>Cardinality (minOccurs, maxOccurs)</li> <li>Inverse relationships for bidirectional associations</li> </ul> </li> <li>Docstrings - CIM documentation embedded in Python docstrings</li> </ol>"},{"location":"02_cim_profiles/2_2_building_profiles/#example-generated-code","title":"Example Generated Code:\u00b6","text":"<p>Below is an example of the hierarchical dataclass structure generated by the builder:</p>"},{"location":"02_cim_profiles/2_2_building_profiles/#summary","title":"Summary\u00b6","text":"<p>Building custom CIM profiles with CIMTool enables you to:</p> <ol> <li>Reduce Complexity - Work with only the CIM classes needed for your application</li> <li>Improve Performance - Smaller profiles mean faster parsing and validation</li> <li>Enhance Maintainability - Focused profiles are easier to understand and maintain</li> <li>Enable Type Safety - Python dataclasses provide IDE support and type checking</li> <li>Facilitate Integration - Custom profiles can bridge between different CIM versions or add extensions</li> </ol>"},{"location":"02_cim_profiles/2_2_building_profiles/#key-takeaways","title":"Key Takeaways:\u00b6","text":"<ul> <li>CIMTool Contextual Profiles define the UML subset</li> <li>XSLT builders transform profiles into usable formats</li> <li>CIMantic Graphs builders create Python dataclass schemas</li> <li>Start small and expand profiles iteratively</li> <li>Test early and often with real data</li> <li>Maintain profile documentation and version control</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#next-steps","title":"Next Steps:\u00b6","text":"<p>The following notebooks will show you how to:</p> <ul> <li>Work with CIM objects and their attributes</li> <li>Manage model changes using incrementals</li> <li>Handle physical quantities with proper units</li> </ul> <p>Now that you can build profiles, let's learn how to use them effectively!</p>"},{"location":"02_cim_profiles/2_2_building_profiles/#common-issues-and-troubleshooting","title":"Common Issues and Troubleshooting\u00b6","text":""},{"location":"02_cim_profiles/2_2_building_profiles/#import-errors-after-profile-generation","title":"Import Errors After Profile Generation\u00b6","text":"<p>Problem: <code>ModuleNotFoundError: No module named 'cimgraph.data_profile.my_profile'</code></p> <p>Solutions:</p> <ul> <li>Verify the profile directory exists in <code>cimgraph/data_profile/</code></li> <li>Check that both <code>.py</code> and <code>__init__.py</code> files are present</li> <li>Ensure the module name in <code>__init__.py</code> matches the directory name</li> <li>Restart Python interpreter to clear import cache</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#invalid-dataclass-definitions","title":"Invalid Dataclass Definitions\u00b6","text":"<p>Problem: Generated dataclasses have syntax errors or missing attributes</p> <p>Solutions:</p> <ul> <li>Verify CIMTool builder is XSLT 1.0 compliant</li> <li>Check that the CIM UML model is properly loaded in CIMTool</li> <li>Ensure all required classes have proper inheritance chains</li> <li>Re-generate the profile with updated builder versions</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#missing-associations","title":"Missing Associations\u00b6","text":"<p>Problem: Association attributes are missing or incomplete</p> <p>Solutions:</p> <ul> <li>Check that both ends of the association are included in the profile</li> <li>Verify inverse relationship is properly defined in CIMTool</li> <li>Ensure association cardinality is correctly specified</li> <li>Review profile constraints on associations</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#circular-import-issues","title":"Circular Import Issues\u00b6","text":"<p>Problem: Circular import errors when using the profile</p> <p>Solutions:</p> <ul> <li>Use string type hints for forward references (already handled by builder)</li> <li>Verify <code>from __future__ import annotations</code> is at top of generated file</li> <li>Check for custom modifications that may have broken imports</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#profile-doesnt-match-xml-data","title":"Profile Doesn't Match XML Data\u00b6","text":"<p>Problem: Cannot parse existing CIM XML with your profile</p> <p>Solutions:</p> <ul> <li>Ensure profile includes all classes present in the XML</li> <li>Check namespace URIs match between profile and XML</li> <li>Verify CIM version compatibility (CIM16 vs CIM17 vs CIM100)</li> <li>Use incremental validation to identify specific mismatches</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#best-practices-for-profile-development","title":"Best Practices for Profile Development\u00b6","text":""},{"location":"02_cim_profiles/2_2_building_profiles/#start-small-and-iterate","title":"Start Small and Iterate\u00b6","text":"<ul> <li>Begin with the absolute minimum classes needed</li> <li>Test with sample data early and often</li> <li>Expand the profile gradually as requirements become clear</li> <li>Avoid \"gold-plating\" with unnecessary classes</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#maintain-profile-documentation","title":"Maintain Profile Documentation\u00b6","text":"<ul> <li>Document the intended use case clearly</li> <li>Keep notes on why classes were included or excluded</li> <li>Track deviations from standard CIM patterns</li> <li>Maintain a changelog as the profile evolves</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#version-control-your-profiles","title":"Version Control Your Profiles\u00b6","text":"<ul> <li>Keep CIMTool <code>.owl</code> profile files in version control</li> <li>Tag stable versions (v1.0, v2.0, etc.)</li> <li>Document breaking changes between versions</li> <li>Consider semantic versioning</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#test-profile-compatibility","title":"Test Profile Compatibility\u00b6","text":"<ul> <li>Validate generated code imports correctly</li> <li>Test round-trip serialization (object \u2192 XML \u2192 object)</li> <li>Verify compatibility with target applications</li> <li>Check that all associations have proper inverses</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#coordinate-across-teams","title":"Coordinate Across Teams\u00b6","text":"<ul> <li>Share profiles with other teams using the same data</li> <li>Establish naming conventions for custom profiles</li> <li>Maintain a registry of available profiles</li> <li>Reuse existing profiles when possible instead of creating new ones</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#step-8-use-your-custom-profile","title":"Step 8: Use Your Custom Profile\u00b6","text":"<p>Once installed, import and use your custom profile just like the built-in profiles:</p>"},{"location":"02_cim_profiles/2_2_building_profiles/#step-5-configure-the-cimantic-graphs-builders","title":"Step 5: Configure the CIMantic Graphs Builders\u00b6","text":""},{"location":"02_cim_profiles/2_2_building_profiles/#import-the-builders","title":"Import the Builders\u00b6","text":"<ol> <li>In CIMTool, go to \"Maintain XSLT Transform Builders\"</li> <li>Import cimantic-graphs.xsl:<ul> <li>Set type: <code>TEXT</code></li> <li>Set extension: <code>py</code></li> </ul> </li> <li>Import cimantic-graphs-init.xsl:<ul> <li>Set type: <code>TEXT</code></li> <li>Set extension: <code>__init__.py</code></li> </ul> </li> </ol> <p>Important Note: CIMTool requires unique file extensions for each builder. The extension determines the output filename, so <code>__init__.py</code> ensures the initialization file is named correctly.</p>"},{"location":"02_cim_profiles/2_2_building_profiles/#configure-builder-settings","title":"Configure Builder Settings\u00b6","text":"<p>In the Profile Summary tab:</p> <ul> <li>Select both CIMantic Graphs builders</li> <li>Ensure XSLT version is set to 1.0 (compatible with both builders)</li> <li>Review output directory settings</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#step-6-generate-the-data-profile","title":"Step 6: Generate the Data Profile\u00b6","text":"<ol> <li>Click \"Save\" or \"Generate\" in CIMTool</li> <li>CIMTool will create two files:<ul> <li><code>&lt;profile_name&gt;.py</code> - Main dataclass schema</li> <li><code>&lt;profile_name&gt;.__init__.py</code> - Python package initialization</li> </ul> </li> </ol>"},{"location":"02_cim_profiles/2_2_building_profiles/#step-7-install-the-data-profile","title":"Step 7: Install the Data Profile\u00b6","text":"<ol> <li>Create a new directory: <code>cimgraph/data_profile/&lt;profile_name&gt;/</code></li> <li>Copy both generated files to this directory</li> <li>Rename if needed:<ul> <li>The main <code>.py</code> file should match your profile/namespace name</li> <li>Ensure the <code>__init__.py</code> file imports from the correct module name</li> </ul> </li> </ol> <p>Example structure:</p> <pre><code>cimgraph/\n  data_profile/\n    my_custom_profile/\n      __init__.py\n      my_custom_profile.py\n</code></pre>"},{"location":"02_cim_profiles/2_2_building_profiles/#step-by-step-building-a-profile-with-cimtool","title":"Step-by-Step: Building a Profile with CIMTool\u00b6","text":""},{"location":"02_cim_profiles/2_2_building_profiles/#prerequisites","title":"Prerequisites\u00b6","text":"<ol> <li>Install CIMTool - Download from UCAIug CIM User Group</li> <li>Obtain CIM UML Model - Download the base CIM UML (e.g., IEC 61970 CIM17v40)</li> <li>Install CIMantic Graphs Builders - Import the two XSLT builders into CIMTool</li> </ol>"},{"location":"02_cim_profiles/2_2_building_profiles/#step-1-create-or-open-a-contextual-profile","title":"Step 1: Create or Open a Contextual Profile\u00b6","text":"<p>In CIMTool:</p> <ul> <li>Create a new profile or open an existing <code>.owl</code> profile file</li> <li>Base it on the appropriate CIM UML version (e.g., CIM17, CIM100)</li> <li>Name your profile descriptively (e.g., \"DistributionTopology\", \"TransmissionPlanning\")</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#step-2-select-classes-and-attributes","title":"Step 2: Select Classes and Attributes\u00b6","text":"<p>Browse the CIM UML model and select:</p> <ul> <li>Required classes - Only classes needed for your use case</li> <li>Required attributes - Remove unnecessary attributes from selected classes</li> <li>Associations - Keep only relevant relationships between classes</li> </ul> <p>Best Practice: Start with the minimum classes needed. You can always expand later.</p>"},{"location":"02_cim_profiles/2_2_building_profiles/#step-3-configure-cardinality","title":"Step 3: Configure Cardinality\u00b6","text":"<p>For each attribute and association:</p> <ul> <li>Review default cardinality from base CIM</li> <li>Constrain if needed (e.g., make optional attributes required)</li> <li>Document any constraints in profile notes</li> </ul>"},{"location":"02_cim_profiles/2_2_building_profiles/#step-4-add-profile-documentation","title":"Step 4: Add Profile Documentation\u00b6","text":"<p>Document your profile with:</p> <ul> <li>Purpose and use case description</li> <li>Intended audience and applications</li> <li>Any deviations or constraints from base CIM</li> <li>Usage examples and patterns</li> </ul>"},{"location":"02_cim_profiles/2_3_using_objects/","title":"Using Objects","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <pre>import json\n\n# Create an object\ntransformer = cim.PowerTransformer(\n    mRID='_xfmr-001',\n    name='Substation_Transformer_1',\n    description='138kV/12.47kV substation transformer'\n)\n\n# JSON-LD representation using repr()\nprint(\"JSON-LD representation (repr):\")\nprint(repr(transformer))\n\n# Pretty print (formatted JSON-LD)\nprint(\"\\\\nFormatted JSON-LD (pprint):\")\ntransformer.pprint()\n\n# Convert to dictionary\nprint(\"\\\\nDictionary representation:\")\nobj_dict = transformer.__dict__()\nprint(json.dumps(obj_dict, indent=2))\n</pre> import json  # Create an object transformer = cim.PowerTransformer(     mRID='_xfmr-001',     name='Substation_Transformer_1',     description='138kV/12.47kV substation transformer' )  # JSON-LD representation using repr() print(\"JSON-LD representation (repr):\") print(repr(transformer))  # Pretty print (formatted JSON-LD) print(\"\\\\nFormatted JSON-LD (pprint):\") transformer.pprint()  # Convert to dictionary print(\"\\\\nDictionary representation:\") obj_dict = transformer.__dict__() print(json.dumps(obj_dict, indent=2)) In\u00a0[\u00a0]: Copied! <pre># Alternative: Use URI strings for associations\n# This is more efficient for large models\n\nline2 = cim.ACLineSegment(\n    mRID='_line-002',\n    name='Feeder_Line_2'\n)\n\nterm3 = cim.Terminal(\n    mRID='_term-003',\n    name='Line_Terminal_3',\n    sequenceNumber=1,\n    ConductingEquipment=line2.uri()  # Use URI string instead of object reference\n)\n\n# Add terminal to line using URI\nline2.Terminals = [term3.uri()]\n\nprint(\"Line created with URI-based associations:\")\nline2.pprint()\nprint(\"\\\\nTerminal 3:\")\nterm3.pprint()\n</pre> # Alternative: Use URI strings for associations # This is more efficient for large models  line2 = cim.ACLineSegment(     mRID='_line-002',     name='Feeder_Line_2' )  term3 = cim.Terminal(     mRID='_term-003',     name='Line_Terminal_3',     sequenceNumber=1,     ConductingEquipment=line2.uri()  # Use URI string instead of object reference )  # Add terminal to line using URI line2.Terminals = [term3.uri()]  print(\"Line created with URI-based associations:\") line2.pprint() print(\"\\\\nTerminal 3:\") term3.pprint() In\u00a0[\u00a0]: Copied! <pre># Create a line segment\nline = cim.ACLineSegment(\n    mRID='_line-001',\n    name='Feeder_Line_1'\n)\n\n# Create terminals for the line (one at each end)\nterm1 = cim.Terminal(\n    mRID='_term-001',\n    name='Line_Terminal_1',\n    sequenceNumber=1\n)\n\nterm2 = cim.Terminal(\n    mRID='_term-002',\n    name='Line_Terminal_2',\n    sequenceNumber=2\n)\n\n# Associate terminals with the line using object references\nline.Terminals = [term1, term2]\n\n# Associate line with terminals (inverse relationship)\nterm1.ConductingEquipment = line\nterm2.ConductingEquipment = line\n\nprint(\"Line created with terminals:\")\nline.pprint()\nprint(\"\\\\nTerminal 1:\")\nterm1.pprint()\n</pre> # Create a line segment line = cim.ACLineSegment(     mRID='_line-001',     name='Feeder_Line_1' )  # Create terminals for the line (one at each end) term1 = cim.Terminal(     mRID='_term-001',     name='Line_Terminal_1',     sequenceNumber=1 )  term2 = cim.Terminal(     mRID='_term-002',     name='Line_Terminal_2',     sequenceNumber=2 )  # Associate terminals with the line using object references line.Terminals = [term1, term2]  # Associate line with terminals (inverse relationship) term1.ConductingEquipment = line term2.ConductingEquipment = line  print(\"Line created with terminals:\") line.pprint() print(\"\\\\nTerminal 1:\") term1.pprint() In\u00a0[\u00a0]: Copied! <pre># Additional examples of attribute utilities\nfrom cimgraph.validators.attribute_utils import (\n    get_attr_datatype, \n    get_attr_uml_type, \n    get_attr_field_type, \n    get_attr_inverse\n)\n\n# Inspect a simple attribute\nprint(\"Attribute inspection for ACLineSegment.name:\")\nprint(f\"  Field type: {get_attr_field_type(cim_class=cim.ACLineSegment, attribute='name')}\")\nprint(f\"  UML type: {get_attr_uml_type(cim_class=cim.ACLineSegment, attribute='name')}\")\nprint(f\"  Datatype: {get_attr_datatype(cim_class=cim.ACLineSegment, attribute='name')}\")\n\nprint(\"\\\\nAssociation inspection for Terminal.Measurements:\")\nfield_type = get_attr_field_type(cim_class=cim.Terminal, attribute='Measurements')\numl_type = get_attr_uml_type(cim_class=cim.Terminal, attribute='Measurements')\ndatatype = get_attr_datatype(cim_class=cim.Terminal, attribute='Measurements')\ninverse = get_attr_inverse(cim_class=cim.Terminal, attribute='Measurements')\n\nprint(f\"  Field type: {field_type}\")  # list\nprint(f\"  UML type: {uml_type}\")      # Association\nprint(f\"  Datatype: {datatype}\")      # ['Measurement']\nprint(f\"  Inverse: {inverse}\")        # Measurement.Terminal\n</pre> # Additional examples of attribute utilities from cimgraph.validators.attribute_utils import (     get_attr_datatype,      get_attr_uml_type,      get_attr_field_type,      get_attr_inverse )  # Inspect a simple attribute print(\"Attribute inspection for ACLineSegment.name:\") print(f\"  Field type: {get_attr_field_type(cim_class=cim.ACLineSegment, attribute='name')}\") print(f\"  UML type: {get_attr_uml_type(cim_class=cim.ACLineSegment, attribute='name')}\") print(f\"  Datatype: {get_attr_datatype(cim_class=cim.ACLineSegment, attribute='name')}\")  print(\"\\\\nAssociation inspection for Terminal.Measurements:\") field_type = get_attr_field_type(cim_class=cim.Terminal, attribute='Measurements') uml_type = get_attr_uml_type(cim_class=cim.Terminal, attribute='Measurements') datatype = get_attr_datatype(cim_class=cim.Terminal, attribute='Measurements') inverse = get_attr_inverse(cim_class=cim.Terminal, attribute='Measurements')  print(f\"  Field type: {field_type}\")  # list print(f\"  UML type: {uml_type}\")      # Association print(f\"  Datatype: {datatype}\")      # ['Measurement'] print(f\"  Inverse: {inverse}\")        # Measurement.Terminal In\u00a0[\u00a0]: Copied! <pre># Create an object with a specific mRID\n# When mRID is provided, UUID is deterministically generated from it\nline2 = cim.ACLineSegment(\n    mRID='_12345678-1234-1234-1234-123456789abc',\n    name='Line_002',\n    description='Main feeder line from substation A to load center B'\n)\n\nprint(\"\\\\nObject created with specific mRID:\")\nline2.pprint()\n\n# Access the URI\nprint(f\"\\\\nObject URI: {line2.uri()}\")\nprint(f\"Object mRID: {line2.mRID}\")\nprint(f\"Object name: {line2.name}\")\n</pre> # Create an object with a specific mRID # When mRID is provided, UUID is deterministically generated from it line2 = cim.ACLineSegment(     mRID='_12345678-1234-1234-1234-123456789abc',     name='Line_002',     description='Main feeder line from substation A to load center B' )  print(\"\\\\nObject created with specific mRID:\") line2.pprint()  # Access the URI print(f\"\\\\nObject URI: {line2.uri()}\") print(f\"Object mRID: {line2.mRID}\") print(f\"Object name: {line2.name}\") In\u00a0[\u00a0]: Copied! <pre># Import a CIM profile\nimport cimgraph.data_profile.cim17v40 as cim\n\n# Create a simple object without mRID (UUID auto-generated)\nline1 = cim.ACLineSegment(name='Line_001')\n\nprint(\"Object created with auto-generated UUID:\")\nline1.pprint()\n</pre> # Import a CIM profile import cimgraph.data_profile.cim17v40 as cim  # Create a simple object without mRID (UUID auto-generated) line1 = cim.ACLineSegment(name='Line_001')  print(\"Object created with auto-generated UUID:\") line1.pprint() <pre>\nclassDiagram\n    class Identity{\n        + identifier: uuid\n        # \\_\\_uuid\\_\\_: class UUID_Meta\n        # \\_\\_json_ld\\_\\_: str~repr~\n\n        + pprint()\n        + uri() str~UUID~\n        ~ uuid(mRID,name,str)\n\n        # \\_\\_repr\\_\\_() str~JSON-LD~\n        # \\_\\_dict\\_\\_() dict\n        # \\_\\_str\\_\\_() str~dict~\n\n\n\n    }\n</pre> In\u00a0[\u00a0]: Copied! <pre>from cimgraph.validators.attribute_utils import get_attr_datatype, get_attr_uml_type, get_attr_field_type, get_attr_inverse\nfield_type = get_attr_field_type(cim_class = cim.Terminal, attribute='Measurements') # field = 'list'\numl_type = get_attr_uml_type(cim_class=cim.Terminal, attribute='Measurements')  # uml_type = 'Association'\ndatatype = get_attr_datatype(cim_class=cim.Terminal, attribute='Measurements')  # datatype = ['Measurement']\ninverse = get_attr_inverse(cim_class=cim.Terminal, attribute='Measurements')  # inverse = 'Measurement.Terminal'\n</pre> from cimgraph.validators.attribute_utils import get_attr_datatype, get_attr_uml_type, get_attr_field_type, get_attr_inverse field_type = get_attr_field_type(cim_class = cim.Terminal, attribute='Measurements') # field = 'list' uml_type = get_attr_uml_type(cim_class=cim.Terminal, attribute='Measurements')  # uml_type = 'Association' datatype = get_attr_datatype(cim_class=cim.Terminal, attribute='Measurements')  # datatype = ['Measurement'] inverse = get_attr_inverse(cim_class=cim.Terminal, attribute='Measurements')  # inverse = 'Measurement.Terminal'"},{"location":"02_cim_profiles/2_3_using_objects/#using-cim-objects","title":"Using CIM Objects\u00b6","text":"<p>Once you have a CIM profile imported into your Python environment, you can create, manipulate, and query CIM objects. This notebook explores the fundamental operations for working with CIM dataclass objects in CIMantic Graphs.</p> <p>All CIM objects in CIMantic Graphs inherit from the Identity base class, which provides essential functionality for object identification, UUID management, and JSON-LD serialization.</p>"},{"location":"02_cim_profiles/2_3_using_objects/#the-identity-base-class","title":"The Identity Base Class\u00b6","text":"<p>Every CIM object in CIMantic Graphs inherits from the Identity class, which provides core functionality:</p>"},{"location":"02_cim_profiles/2_3_using_objects/#key-features","title":"Key Features:\u00b6","text":"<ol> <li>UUID Management - Automatic generation and management of RFC 4122 UUIDs</li> <li>URI Generation - Creates unique URIs for use in RDF and graph databases</li> <li>JSON-LD Serialization - Native support for JSON-LD format with <code>@id</code> and <code>@type</code></li> <li>Pretty Printing - Human-readable display of objects</li> <li>Dictionary Conversion - Easy conversion to/from Python dictionaries</li> </ol>"},{"location":"02_cim_profiles/2_3_using_objects/#identity-class-hierarchy","title":"Identity Class Hierarchy:\u00b6","text":""},{"location":"02_cim_profiles/2_3_using_objects/#creating-cim-objects","title":"Creating CIM Objects\u00b6","text":"<p>Let's start by importing a profile and creating some basic objects:</p>"},{"location":"02_cim_profiles/2_3_using_objects/#using-attribute-utilities","title":"Using Attribute Utilities\u00b6","text":"<p>CIMantic Graphs provides utility functions to inspect attribute metadata programmatically. These are especially useful when building generic tools that work with any CIM profile:</p> <ul> <li><code>get_attr_field_type()</code> - Returns the Python field type (str, list, Optional, etc.)</li> <li><code>get_attr_uml_type()</code> - Returns the UML type (Attribute, Association, enumeration)</li> <li><code>get_attr_datatype()</code> - Returns the CIM datatype(s) for the attribute</li> <li><code>get_attr_inverse()</code> - Returns the inverse relationship for associations</li> </ul> <p>Let's see these in action:</p>"},{"location":"02_cim_profiles/2_3_using_objects/#working-with-attributes","title":"Working with Attributes\u00b6","text":"<p>CIM dataclasses have three types of fields:</p> <ol> <li>Attributes - Simple data values (strings, numbers, booleans)</li> <li>Associations - References to other CIM objects</li> <li>Enumerations - Predefined sets of values</li> </ol> <p>Each field includes metadata describing its UML type, cardinality, and inverse relationships (for associations).</p>"},{"location":"02_cim_profiles/2_3_using_objects/#summary","title":"Summary\u00b6","text":"<p>This notebook covered the fundamentals of working with CIM objects in CIMantic Graphs:</p>"},{"location":"02_cim_profiles/2_3_using_objects/#key-concepts","title":"Key Concepts:\u00b6","text":"<ol> <li><p>Identity Base Class - All CIM objects inherit from Identity, providing UUID management, URI generation, and JSON-LD serialization</p> </li> <li><p>Object Creation - Create objects with or without mRIDs; mRIDs should be provided for persistent data</p> </li> <li><p>Attributes and Metadata - Each field includes metadata about its UML type, cardinality, and inverse relationships</p> </li> <li><p>Associations - Relationships between objects can use object references or URI strings</p> </li> <li><p>Serialization - Objects support JSON-LD format and dictionary conversion</p> </li> <li><p>Inspection Tools - Validator utilities enable generic code that works with any profile</p> </li> </ol>"},{"location":"02_cim_profiles/2_3_using_objects/#next-steps","title":"Next Steps:\u00b6","text":"<ul> <li>Incrementals - Learn how to track and manage model changes</li> <li>Units - Work with physical quantities and unit conversion</li> <li>FeederModel - Build complete network models with databases</li> </ul> <p>With these object fundamentals in place, you're ready to build and manipulate complete CIM power system models!</p>"},{"location":"02_cim_profiles/2_3_using_objects/#best-practices-for-working-with-cim-objects","title":"Best Practices for Working with CIM Objects\u00b6","text":""},{"location":"02_cim_profiles/2_3_using_objects/#1-always-provide-mrids-for-persistent-objects","title":"1. Always Provide mRIDs for Persistent Objects\u00b6","text":"<p>For objects that will be saved to databases or exchanged between systems, always provide explicit mRIDs:</p> <pre># Good - explicit mRID ensures persistence\nline = cim.ACLineSegment(mRID='_line-001', name='Feeder_1')\n\n# Avoid for persistent data - UUID will change between runs\nline = cim.ACLineSegment(name='Feeder_1')  \n</pre>"},{"location":"02_cim_profiles/2_3_using_objects/#2-use-consistent-mrid-formatting","title":"2. Use Consistent mRID Formatting\u00b6","text":"<p>Follow a consistent format for mRIDs across your organization:</p> <ul> <li>Leading underscore: <code>_line-001</code></li> <li>UUID format: <code>_12345678-1234-1234-1234-123456789abc</code></li> <li>Hierarchical: <code>_substation-A_feeder-1_line-001</code></li> </ul>"},{"location":"02_cim_profiles/2_3_using_objects/#3-maintain-bidirectional-associations","title":"3. Maintain Bidirectional Associations\u00b6","text":"<p>When creating associations, remember to set both directions:</p> <pre># Set both sides of the relationship\nterminal.ConductingEquipment = line  # Forward\nline.Terminals.append(terminal)       # Inverse\n</pre>"},{"location":"02_cim_profiles/2_3_using_objects/#4-choose-the-right-association-format","title":"4. Choose the Right Association Format\u00b6","text":"<ul> <li>Use object references for small, in-memory models (easier to navigate)</li> <li>Use URI strings for large models (more memory efficient)</li> <li>Be consistent within a single model</li> </ul>"},{"location":"02_cim_profiles/2_3_using_objects/#5-leverage-type-hints-and-ides","title":"5. Leverage Type Hints and IDEs\u00b6","text":"<p>The generated dataclasses include full type hints. Use a modern IDE (VS Code, PyCharm) to get:</p> <ul> <li>Autocomplete for attributes</li> <li>Type checking warnings</li> <li>Inline documentation from docstrings</li> </ul>"},{"location":"02_cim_profiles/2_3_using_objects/#6-use-validator-utilities-for-generic-code","title":"6. Use Validator Utilities for Generic Code\u00b6","text":"<p>When writing tools that work with any CIM profile, use the attribute utility functions instead of hardcoding field names:</p> <pre># Generic code that works with any class\nfrom cimgraph.validators.attribute_utils import get_attr_uml_type\n\ndef find_associations(cim_obj):\n    for field in fields(cim_obj):\n        if get_attr_uml_type(type(cim_obj), field.name) == 'Association':\n            print(f\"Found association: {field.name}\")\n</pre>"},{"location":"02_cim_profiles/2_3_using_objects/#object-serialization","title":"Object Serialization\u00b6","text":"<p>CIM objects can be easily serialized to various formats:</p>"},{"location":"02_cim_profiles/2_3_using_objects/#json-ld-format","title":"JSON-LD Format\u00b6","text":"<p>All CIM objects support JSON-LD serialization with <code>@id</code> and <code>@type</code> fields. This format is compatible with RDF and semantic web technologies.</p>"},{"location":"02_cim_profiles/2_3_using_objects/#working-with-associations","title":"Working with Associations\u00b6","text":"<p>Associations represent relationships between CIM objects. In CIMantic Graphs, associations can reference objects in two ways:</p> <ol> <li>By URI string - Using the object's UUID string</li> <li>By object reference - Using the actual Python object</li> </ol> <p>Both approaches are supported. Using URI strings is more efficient for large models, while object references are more convenient for small, in-memory graphs.</p>"},{"location":"02_cim_profiles/2_4_using_incrementals/","title":"Using Incrementals","text":"In\u00a0[1]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nimport cimgraph.data_profile.cimhub_2023 as cim\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' import cimgraph.data_profile.cimhub_2023 as cim In\u00a0[2]: Copied! <pre>from cimgraph.databases import XMLFile\nfile = XMLFile(filename='../../sample_models/ieee13.xml')\n</pre> from cimgraph.databases import XMLFile file = XMLFile(filename='../../sample_models/ieee13.xml') <p>Now load a CIM XML file into a database connection:</p> In\u00a0[3]: Copied! <pre>from cimgraph.models import FeederModel\nnetwork = FeederModel(container=cim.Feeder(), connection=file)\n</pre> from cimgraph.models import FeederModel network = FeederModel(container=cim.Feeder(), connection=file) <p>Create a FeederModel that will automatically track all changes:</p> In\u00a0[4]: Copied! <pre>line = network.create(cim.ACLineSegment, name='new_line')\nline.pprint()\n</pre> line = network.create(cim.ACLineSegment, name='new_line') line.pprint() <pre>{\n    \"@id\": \"4d29f925-8390-4e1d-a877-fdcf5ac624b1\",\n    \"@type\": \"ACLineSegment\",\n    \"name\": \"new_line\"\n}\n</pre> In\u00a0[6]: Copied! <pre>network.incrementals['forwardDifferences'][cim.ACLineSegment][line.uri()]\n</pre> network.incrementals['forwardDifferences'][cim.ACLineSegment][line.uri()] Out[6]: <pre>{'mRID': '4d29f925-8390-4e1d-a877-fdcf5ac624b1', 'name': 'new_line'}</pre> In\u00a0[\u00a0]: Copied! <pre># Delete the line\nnetwork.delete(line)\n\n# Forward difference shows None (deletion marker)\nprint(\"Forward difference (deletion):\")\nfwd_diff = network.incrementals['forwardDifferences'][cim.ACLineSegment].get(line.uri())\nprint(f\"  {line.uri()}: {fwd_diff}\")\n\n# Reverse difference contains full object state for restoration\nprint(\"\\\\nReverse difference (full object for restoration):\")\nrev_diff = network.incrementals['reverseDifferences'][cim.ACLineSegment].get(line.uri())\nif rev_diff:\n    print(f\"  Can restore: {rev_diff}\")\n</pre> # Delete the line network.delete(line)  # Forward difference shows None (deletion marker) print(\"Forward difference (deletion):\") fwd_diff = network.incrementals['forwardDifferences'][cim.ACLineSegment].get(line.uri()) print(f\"  {line.uri()}: {fwd_diff}\")  # Reverse difference contains full object state for restoration print(\"\\\\nReverse difference (full object for restoration):\") rev_diff = network.incrementals['reverseDifferences'][cim.ACLineSegment].get(line.uri()) if rev_diff:     print(f\"  Can restore: {rev_diff}\") In\u00a0[\u00a0]: Copied! <pre># Modify the line we just created\nnetwork.update(line, name='modified_line_name', description='Updated description')\n\n# Check forward differences (new values)\nprint(\"Forward difference (new value):\")\nprint(network.incrementals['forwardDifferences'][cim.ACLineSegment][line.uri()])\n\n# Check reverse differences (old values for undo)\nprint(\"\\\\nReverse difference (old value for undo):\")\nprint(network.incrementals['reverseDifferences'][cim.ACLineSegment][line.uri()])\n</pre> # Modify the line we just created network.update(line, name='modified_line_name', description='Updated description')  # Check forward differences (new values) print(\"Forward difference (new value):\") print(network.incrementals['forwardDifferences'][cim.ACLineSegment][line.uri()])  # Check reverse differences (old values for undo) print(\"\\\\nReverse difference (old value for undo):\") print(network.incrementals['reverseDifferences'][cim.ACLineSegment][line.uri()])"},{"location":"02_cim_profiles/2_4_using_incrementals/#using-cim-incrementals","title":"Using CIM Incrementals\u00b6","text":"<p>In power system operations and planning, network models are constantly evolving. Equipment is added, removed, or modified; switch states change; and operational parameters are updated. Rather than exchanging complete network models every time a change occurs, CIM supports incremental updates - transmitting only what has changed.</p> <p>CIMantic Graphs automatically tracks all model changes in an incrementals dictionary, enabling efficient model synchronization, change auditing, and state management.</p>"},{"location":"02_cim_profiles/2_4_using_incrementals/#what-are-incrementals","title":"What Are Incrementals?\u00b6","text":"<p>Incrementals (also called \"difference models\" or \"delta models\") represent changes to a CIM model without requiring the entire model to be re-transmitted. They are essential for:</p>"},{"location":"02_cim_profiles/2_4_using_incrementals/#use-cases","title":"Use Cases:\u00b6","text":"<ol> <li>Real-Time Operations - SCADA systems update switch positions, measurements change, and topology evolves</li> <li>Model Synchronization - Multiple applications need to stay synchronized with a master model</li> <li>Change Tracking - Audit trails of who changed what and when</li> <li>Efficient Communication - Minimize bandwidth by sending only changes, not full models</li> <li>Conflict Resolution - Detect and resolve conflicting changes from multiple sources</li> <li>Undo/Redo - Maintain change history for rollback capabilities</li> </ol>"},{"location":"02_cim_profiles/2_4_using_incrementals/#types-of-incrementals","title":"Types of Incrementals:\u00b6","text":"<p>CIMantic Graphs tracks two types of incremental changes:</p> <ol> <li><p>Forward Differences - Changes to apply to transform model from state A to state B</p> <ul> <li>New objects created</li> <li>Attribute values changed</li> <li>Objects deleted</li> </ul> </li> <li><p>Reverse Differences - Changes to apply to transform model from state B back to state A</p> <ul> <li>Inverse of forward differences</li> <li>Enables undo operations</li> <li>Supports conflict detection</li> </ul> </li> </ol>"},{"location":"02_cim_profiles/2_4_using_incrementals/#example-tracking-changes-with-incrementals","title":"Example: Tracking Changes with Incrementals\u00b6","text":"<p>Let's load an existing model and create some new objects to see how incrementals are automatically tracked.</p> <p>First, set up the environment and load a model:</p>"},{"location":"02_cim_profiles/2_4_using_incrementals/#creating-new-objects","title":"Creating New Objects\u00b6","text":"<p>When you use the <code>network.create()</code> method, the object is automatically added to the forward differences:</p>"},{"location":"02_cim_profiles/2_4_using_incrementals/#summary","title":"Summary\u00b6","text":"<p>Incrementals are a powerful feature of CIM that enable efficient model synchronization and change management:</p>"},{"location":"02_cim_profiles/2_4_using_incrementals/#key-concepts","title":"Key Concepts:\u00b6","text":"<ol> <li>Automatic Tracking - CIMantic Graphs automatically tracks all model changes</li> <li>Forward Differences - Changes to apply (old state \u2192 new state)</li> <li>Reverse Differences - Changes to undo (new state \u2192 old state)</li> <li>Efficient Communication - Send only what changed, not entire models</li> <li>Change Audit - Complete history of what changed and when</li> </ol>"},{"location":"02_cim_profiles/2_4_using_incrementals/#incremental-types","title":"Incremental Types:\u00b6","text":"<ul> <li>Create - New objects appear in forward differences with all attributes</li> <li>Modify - Changed attributes in forward, old values in reverse</li> <li>Delete - None in forward, full object in reverse for restoration</li> </ul>"},{"location":"02_cim_profiles/2_4_using_incrementals/#common-use-cases","title":"Common Use Cases:\u00b6","text":"<ul> <li>Real-time SCADA updates</li> <li>Model synchronization across applications</li> <li>Conflict detection and resolution</li> <li>Undo/redo functionality</li> <li>Change auditing and logging</li> <li>Efficient network bandwidth usage</li> </ul>"},{"location":"02_cim_profiles/2_4_using_incrementals/#next-steps","title":"Next Steps:\u00b6","text":"<p>The final notebook in this series covers Units and Quantities - how CIM handles physical measurements with automatic unit conversion.</p> <p>With incrementals, you now have the tools to build sophisticated, real-time power system applications that efficiently manage model state!</p>"},{"location":"02_cim_profiles/2_4_using_incrementals/#best-practices-for-incrementals","title":"Best Practices for Incrementals\u00b6","text":""},{"location":"02_cim_profiles/2_4_using_incrementals/#1-use-incrementals-for-real-time-updates","title":"1. Use Incrementals for Real-Time Updates\u00b6","text":"<p>Instead of re-sending entire network models, send only what changed:</p> <pre># After SCADA updates switch position\nswitch.open = False\nnetwork.update(switch, open=False)\n\n# Send just the incremental\nsend_to_subscribers(network.incrementals['forwardDifferences'])\n\n# Clear after sending\nnetwork.incrementals['forwardDifferences'].clear()\n</pre>"},{"location":"02_cim_profiles/2_4_using_incrementals/#2-timestamp-your-incrementals","title":"2. Timestamp Your Incrementals\u00b6","text":"<p>Add metadata to track when changes occurred:</p> <pre>from datetime import datetime\n\nincremental_message = {\n    'timestamp': datetime.utcnow().isoformat(),\n    'source': 'SCADA_System_A',\n    'changes': network.incrementals['forwardDifferences']\n}\n</pre>"},{"location":"02_cim_profiles/2_4_using_incrementals/#3-validate-before-applying","title":"3. Validate Before Applying\u00b6","text":"<p>Validate received incrementals before applying to your model:</p> <pre>def validate_incremental(incremental, profile):\n    \"\"\"Validate incremental matches profile schema\"\"\"\n    for cim_class, objects in incremental.items():\n        # Check class exists in profile\n        if not hasattr(profile, cim_class.__name__):\n            raise ValueError(f\"Unknown class: {cim_class}\")\n        \n        # Validate attributes\n        for uri, attributes in objects.items():\n            if attributes is not None:\n                # Check all attributes are valid for this class\n                valid_attrs = {f.name for f in fields(cim_class)}\n                for attr in attributes.keys():\n                    if attr not in valid_attrs:\n                        raise ValueError(f\"Invalid attribute {attr} for {cim_class}\")\n</pre>"},{"location":"02_cim_profiles/2_4_using_incrementals/#4-handle-conflicts","title":"4. Handle Conflicts\u00b6","text":"<p>When multiple sources update the same object, detect and resolve conflicts:</p> <pre>def detect_conflicts(local_incremental, received_incremental):\n    \"\"\"Detect if same objects modified in both incrementals\"\"\"\n    conflicts = []\n    \n    for cim_class in received_incremental:\n        if cim_class in local_incremental:\n            # Check for overlapping URIs\n            local_uris = set(local_incremental[cim_class].keys())\n            received_uris = set(received_incremental[cim_class].keys())\n            \n            conflicts.extend(local_uris &amp; received_uris)\n    \n    return conflicts\n</pre>"},{"location":"02_cim_profiles/2_4_using_incrementals/#5-use-reverse-differences-for-undo","title":"5. Use Reverse Differences for Undo\u00b6","text":"<p>Implement undo functionality using reverse differences:</p> <pre>def undo_last_change(network):\n    \"\"\"Undo the last set of changes\"\"\"\n    reverse = network.incrementals['reverseDifferences']\n    \n    # Apply reverse differences\n    for cim_class, objects in reverse.items():\n        for uri, attributes in objects.items():\n            if attributes is None:\n                # Was a creation, now delete\n                network.delete_by_uri(uri)\n            else:\n                # Restore old values\n                network.update_by_uri(uri, **attributes)\n    \n    # Swap forward and reverse\n    network.incrementals['forwardDifferences'], \\\n    network.incrementals['reverseDifferences'] = \\\n    network.incrementals['reverseDifferences'], \\\n    network.incrementals['forwardDifferences']\n</pre>"},{"location":"02_cim_profiles/2_4_using_incrementals/#working-with-incrementals","title":"Working with Incrementals\u00b6","text":""},{"location":"02_cim_profiles/2_4_using_incrementals/#clearing-incrementals","title":"Clearing Incrementals\u00b6","text":"<p>After processing or exporting incrementals, clear them to start tracking a new set of changes:</p> <pre># Clear all tracked changes\nnetwork.incrementals['forwardDifferences'].clear()\nnetwork.incrementals['reverseDifferences'].clear()\n</pre>"},{"location":"02_cim_profiles/2_4_using_incrementals/#exporting-incrementals","title":"Exporting Incrementals\u00b6","text":"<p>Export incrementals to XML or JSON for transmission to other systems:</p> <pre># Export forward differences to XML\nfrom cimgraph.databases import XMLFile\n\nincremental_file = XMLFile(filename='model_changes.xml')\nincremental_file.export_incrementals(\n    incrementals=network.incrementals['forwardDifferences'],\n    profile=cim\n)\n</pre>"},{"location":"02_cim_profiles/2_4_using_incrementals/#applying-incrementals","title":"Applying Incrementals\u00b6","text":"<p>Receive incrementals from another system and apply them to your model:</p> <pre># Load incrementals from file\nreceived_changes = incremental_file.import_incrementals()\n\n# Apply changes to network\nfor cim_class, objects in received_changes.items():\n    for uri, attributes in objects.items():\n        if attributes is None:\n            # Deletion\n            network.delete_by_uri(uri)\n        else:\n            # Create or update\n            network.update_by_uri(uri, **attributes)\n</pre>"},{"location":"02_cim_profiles/2_4_using_incrementals/#deleting-objects","title":"Deleting Objects\u00b6","text":"<p>When you delete an object, the forward difference shows the deletion, and the reverse difference contains the full object state for restoration:</p>"},{"location":"02_cim_profiles/2_4_using_incrementals/#additional-examples","title":"Additional Examples\u00b6","text":""},{"location":"02_cim_profiles/2_4_using_incrementals/#modifying-existing-objects","title":"Modifying Existing Objects\u00b6","text":"<p>When you modify an existing object, both forward and reverse differences are tracked:</p>"},{"location":"02_cim_profiles/2_4_using_incrementals/#incrementals-dictionary-structure","title":"Incrementals Dictionary Structure\u00b6","text":"<p>The <code>network.incrementals</code> dictionary has the following structure:</p> <pre>{\n    'forwardDifferences': {\n        &lt;CIM_Class&gt;: {\n            &lt;object_uri&gt;: {&lt;attribute&gt;: &lt;value&gt;, ...},\n            ...\n        },\n        ...\n    },\n    'reverseDifferences': {\n        &lt;CIM_Class&gt;: {\n            &lt;object_uri&gt;: {&lt;attribute&gt;: &lt;value&gt;, ...},\n            ...\n        },\n        ...\n    }\n}\n</pre> <ul> <li>forwardDifferences: Changes to apply to get from old state \u2192 new state</li> <li>reverseDifferences: Changes to apply to get from new state \u2192 old state (undo)</li> <li>Objects are organized by class type</li> <li>Each object is identified by its URI</li> <li>Only changed attributes are included (not the full object)</li> </ul>"},{"location":"02_cim_profiles/2_4_using_incrementals/#inspecting-the-incrementals-dictionary","title":"Inspecting the Incrementals Dictionary\u00b6","text":"<p>The <code>network.incrementals</code> dictionary tracks all changes. Let's examine what was recorded:</p>"},{"location":"02_cim_profiles/2_5_using_units/","title":"Using Units","text":"In\u00a0[1]: Copied! <pre>from mermaid import Mermaid\nfrom cimgraph import utils\nimport cimgraph.data_profile.cim17v40 as cim\n</pre> from mermaid import Mermaid from cimgraph import utils import cimgraph.data_profile.cim17v40 as cim In\u00a0[2]: Copied! <pre>Mermaid(utils.get_mermaid(cim.Voltage))\n</pre> Mermaid(utils.get_mermaid(cim.Voltage)) Out[2]: In\u00a0[3]: Copied! <pre>cim.Voltage(value=230.0, input_unit='kV')\n</pre> cim.Voltage(value=230.0, input_unit='kV') Out[3]: <pre>230000.0 volt</pre> In\u00a0[\u00a0]: Copied! <pre># Create a line with resistance and reactance\nline = cim.ACLineSegment(\n    mRID='_line-001',\n    name='Feeder_Line_1',\n    r=cim.Resistance(value=0.185, input_unit='ohm'),  # 0.185 \u03a9\n    x=cim.Reactance(value=0.382, input_unit='ohm'),   # 0.382 \u03a9\n    length=cim.Length(value=2.5, input_unit='km')     # 2.5 km\n)\n\nprint(\"Line created with units:\")\nprint(f\"  Resistance: {line.r.to('ohm')}\")\nprint(f\"  Reactance: {line.x.to('ohm')}\")\nprint(f\"  Length: {line.length.to('km')}\")\nprint(f\"  Length in miles: {line.length.to('mi')}\")\n\n# Create a transformer with rated values\ntransformer = cim.PowerTransformer(\n    mRID='_xfmr-001',\n    name='Substation_Transformer',\n    ratedU=cim.Voltage(value=138.0, input_unit='kV'),\n    ratedS=cim.ApparentPower(value=50.0, input_unit='MVA')\n)\n\nprint(f\"\\\\nTransformer ratings:\")\nprint(f\"  Voltage: {transformer.ratedU.to('kV')}\")\nprint(f\"  Power: {transformer.ratedS.to('MVA')}\")\n</pre> # Create a line with resistance and reactance line = cim.ACLineSegment(     mRID='_line-001',     name='Feeder_Line_1',     r=cim.Resistance(value=0.185, input_unit='ohm'),  # 0.185 \u03a9     x=cim.Reactance(value=0.382, input_unit='ohm'),   # 0.382 \u03a9     length=cim.Length(value=2.5, input_unit='km')     # 2.5 km )  print(\"Line created with units:\") print(f\"  Resistance: {line.r.to('ohm')}\") print(f\"  Reactance: {line.x.to('ohm')}\") print(f\"  Length: {line.length.to('km')}\") print(f\"  Length in miles: {line.length.to('mi')}\")  # Create a transformer with rated values transformer = cim.PowerTransformer(     mRID='_xfmr-001',     name='Substation_Transformer',     ratedU=cim.Voltage(value=138.0, input_unit='kV'),     ratedS=cim.ApparentPower(value=50.0, input_unit='MVA') )  print(f\"\\\\nTransformer ratings:\") print(f\"  Voltage: {transformer.ratedU.to('kV')}\") print(f\"  Power: {transformer.ratedS.to('MVA')}\") In\u00a0[\u00a0]: Copied! <pre># Addition with automatic unit conversion\nv1 = cim.Voltage(value=12.47, input_unit='kV')\nv2 = cim.Voltage(value=7200, input_unit='V')  # 7.2 kV\n\nv_total = v1 + v2\nprint(f\"{v1} + {v2} = {v_total}\")\nprint(f\"Total in kV: {v_total.to('kV')}\")\n\n# Multiplication (Ohm's law: V = I * R)\ncurrent = cim.CurrentFlow(value=100.0, input_unit='A')\nresistance = cim.Resistance(value=0.5, input_unit='ohm')\n\nvoltage_drop = current * resistance\nprint(f\"\\\\nVoltage drop: {current} \u00d7 {resistance} = {voltage_drop}\")\n\n# Division\npower = cim.ActivePower(value=100.0, input_unit='kW')\nvoltage = cim.Voltage(value=480.0, input_unit='V')\n\n# Note: CIM has separate Power and Current types\n# This shows how Pint handles dimensional analysis\nprint(f\"\\\\n{power} \u00f7 {voltage} = {(power / voltage).to('A')}\")\n</pre> # Addition with automatic unit conversion v1 = cim.Voltage(value=12.47, input_unit='kV') v2 = cim.Voltage(value=7200, input_unit='V')  # 7.2 kV  v_total = v1 + v2 print(f\"{v1} + {v2} = {v_total}\") print(f\"Total in kV: {v_total.to('kV')}\")  # Multiplication (Ohm's law: V = I * R) current = cim.CurrentFlow(value=100.0, input_unit='A') resistance = cim.Resistance(value=0.5, input_unit='ohm')  voltage_drop = current * resistance print(f\"\\\\nVoltage drop: {current} \u00d7 {resistance} = {voltage_drop}\")  # Division power = cim.ActivePower(value=100.0, input_unit='kW') voltage = cim.Voltage(value=480.0, input_unit='V')  # Note: CIM has separate Power and Current types # This shows how Pint handles dimensional analysis print(f\"\\\\n{power} \u00f7 {voltage} = {(power / voltage).to('A')}\") In\u00a0[\u00a0]: Copied! <pre># Create a voltage in kV\nvoltage = cim.Voltage(value=138.0, input_unit='kV')\n\n# Convert to different units\nprint(f\"Original: {voltage}\")\nprint(f\"In volts: {voltage.to('V')}\")\nprint(f\"In megavolts: {voltage.to('MV')}\")\nprint(f\"In kilovolts: {voltage.to('kV')}\")\n\n# Get numeric value in specific unit\nkv_value = voltage.to('kV').magnitude\nprint(f\"\\\\nNumeric value in kV: {kv_value}\")\n\n# Create power quantities\npower = cim.ActivePower(value=50.0, input_unit='MW')\nprint(f\"\\\\nPower: {power}\")\nprint(f\"Power in kW: {power.to('kW')}\")\nprint(f\"Power in GW: {power.to('GW')}\")\n</pre> # Create a voltage in kV voltage = cim.Voltage(value=138.0, input_unit='kV')  # Convert to different units print(f\"Original: {voltage}\") print(f\"In volts: {voltage.to('V')}\") print(f\"In megavolts: {voltage.to('MV')}\") print(f\"In kilovolts: {voltage.to('kV')}\")  # Get numeric value in specific unit kv_value = voltage.to('kV').magnitude print(f\"\\\\nNumeric value in kV: {kv_value}\")  # Create power quantities power = cim.ActivePower(value=50.0, input_unit='MW') print(f\"\\\\nPower: {power}\") print(f\"Power in kW: {power.to('kW')}\") print(f\"Power in GW: {power.to('GW')}\") In\u00a0[\u00a0]: Copied! <pre># Method 1: Specify value and input unit\nv1 = cim.Voltage(value=230.0, input_unit='kV')\nprint(f\"Method 1: {v1}\")\n\n# Method 2: Just provide value (assumes base unit - volts)\nv2 = cim.Voltage(value=230000.0)\nprint(f\"Method 2: {v2}\")\n\n# Method 3: From string\nv3 = cim.Voltage(value=12.47, input_unit='kV')\nprint(f\"Method 3: {v3}\")\n\n# All are equivalent when compared\nprint(f\"\\\\nAll represent the same voltage: {v1.to('kV') == v3}\")\n</pre> # Method 1: Specify value and input unit v1 = cim.Voltage(value=230.0, input_unit='kV') print(f\"Method 1: {v1}\")  # Method 2: Just provide value (assumes base unit - volts) v2 = cim.Voltage(value=230000.0) print(f\"Method 2: {v2}\")  # Method 3: From string v3 = cim.Voltage(value=12.47, input_unit='kV') print(f\"Method 3: {v3}\")  # All are equivalent when compared print(f\"\\\\nAll represent the same voltage: {v1.to('kV') == v3}\") In\u00a0[\u00a0]: Copied! <pre># Example: Calculate energy consumption and costs\n# Load data\nload_power_mw = 25.0  # MW average load\nduration_hours = 24.0  # hours (one day)\ncost_per_kwh = 0.12   # $/kWh\n\n# Create CIM quantities\npower = cim.ActivePower(value=load_power_mw, input_unit='MW')\ntime = cim.Time(value=duration_hours, input_unit='h')\n\n# Calculate energy: E = P \u00d7 t\nenergy = power.quantity * time.quantity\nenergy_cim = cim.RealEnergy(energy)\n\nprint(f\"Load Profile:\")\nprint(f\"  Average Power: {power.to('MW')} MW\")\nprint(f\"  Duration: {time.to('h')} hours\")\nprint(f\"\\\\nEnergy Consumption:\")\nprint(f\"  {energy_cim.to('MWh'):.1f} MWh\")\nprint(f\"  {energy_cim.to('kWh'):.0f} kWh\")\nprint(f\"  {energy_cim.to('J'):.2e} J (Joules)\")\n\n# Calculate cost\nenergy_kwh = energy_cim.to('kWh')\ncost = energy_kwh * cost_per_kwh\nprint(f\"\\\\nCost: ${cost:,.2f}\")\n\n# Reactive energy example\nreactive_power = cim.ReactivePower(value=10.0, input_unit='MVAr')\nreactive_energy = reactive_power.quantity * time.quantity\nreactive_energy_cim = cim.ReactiveEnergy(reactive_energy)\n\nprint(f\"\\\\nReactive Energy:\")\nprint(f\"  {reactive_energy_cim.to('MVArh'):.1f} MVArh\")\nprint(f\"  {reactive_energy_cim.to('kVArh'):.0f} kVArh\")\n</pre> # Example: Calculate energy consumption and costs # Load data load_power_mw = 25.0  # MW average load duration_hours = 24.0  # hours (one day) cost_per_kwh = 0.12   # $/kWh  # Create CIM quantities power = cim.ActivePower(value=load_power_mw, input_unit='MW') time = cim.Time(value=duration_hours, input_unit='h')  # Calculate energy: E = P \u00d7 t energy = power.quantity * time.quantity energy_cim = cim.RealEnergy(energy)  print(f\"Load Profile:\") print(f\"  Average Power: {power.to('MW')} MW\") print(f\"  Duration: {time.to('h')} hours\") print(f\"\\\\nEnergy Consumption:\") print(f\"  {energy_cim.to('MWh'):.1f} MWh\") print(f\"  {energy_cim.to('kWh'):.0f} kWh\") print(f\"  {energy_cim.to('J'):.2e} J (Joules)\")  # Calculate cost energy_kwh = energy_cim.to('kWh') cost = energy_kwh * cost_per_kwh print(f\"\\\\nCost: ${cost:,.2f}\")  # Reactive energy example reactive_power = cim.ReactivePower(value=10.0, input_unit='MVAr') reactive_energy = reactive_power.quantity * time.quantity reactive_energy_cim = cim.ReactiveEnergy(reactive_energy)  print(f\"\\\\nReactive Energy:\") print(f\"  {reactive_energy_cim.to('MVArh'):.1f} MVArh\") print(f\"  {reactive_energy_cim.to('kVArh'):.0f} kVArh\") In\u00a0[\u00a0]: Copied! <pre># Example: Convert transformer impedance to per-unit\n# System base values\ns_base_mva = 100.0  # MVA\nv_base_kv = 138.0   # kV\n\n# Transformer data\ntransformer_z_ohm = 15.0  # \u03a9 (actual impedance)\n\n# Create CIM base quantities\ns_base = cim.ApparentPower(value=s_base_mva, input_unit='MVA')\nv_base = cim.Voltage(value=v_base_kv, input_unit='kV')\n\n# Calculate base impedance: Z_base = V\u00b2 / S\nz_base = (v_base.quantity ** 2) / s_base.quantity\nz_base_cim = cim.Resistance(z_base)\n\nprint(f\"System Base Values:\")\nprint(f\"  S_base = {s_base.to('MVA')} MVA\")\nprint(f\"  V_base = {v_base.to('kV')} kV\")\nprint(f\"  Z_base = {z_base_cim.to('ohm'):.2f} \u03a9\")\n\n# Transformer impedance\nz_actual = cim.Resistance(value=transformer_z_ohm, input_unit='ohm')\n\n# Calculate per-unit impedance (dimensionless)\nz_pu = z_actual.quantity / z_base\n\nprint(f\"\\\\nTransformer Impedance:\")\nprint(f\"  Z_actual = {z_actual.to('ohm')} \u03a9\")\nprint(f\"  Z_pu = {z_pu.magnitude:.4f} per-unit\")\n\n# Can also go backwards: convert per-unit to ohms\nz_pu_value = 0.1  # 10% impedance\nz_ohms = z_pu_value * z_base\nz_ohms_cim = cim.Resistance(z_ohms)\nprint(f\"\\\\nReverse Calculation:\")\nprint(f\"  Z_pu = {z_pu_value} per-unit\")\nprint(f\"  Z_ohms = {z_ohms_cim.to('ohm'):.2f} \u03a9\")\n</pre> # Example: Convert transformer impedance to per-unit # System base values s_base_mva = 100.0  # MVA v_base_kv = 138.0   # kV  # Transformer data transformer_z_ohm = 15.0  # \u03a9 (actual impedance)  # Create CIM base quantities s_base = cim.ApparentPower(value=s_base_mva, input_unit='MVA') v_base = cim.Voltage(value=v_base_kv, input_unit='kV')  # Calculate base impedance: Z_base = V\u00b2 / S z_base = (v_base.quantity ** 2) / s_base.quantity z_base_cim = cim.Resistance(z_base)  print(f\"System Base Values:\") print(f\"  S_base = {s_base.to('MVA')} MVA\") print(f\"  V_base = {v_base.to('kV')} kV\") print(f\"  Z_base = {z_base_cim.to('ohm'):.2f} \u03a9\")  # Transformer impedance z_actual = cim.Resistance(value=transformer_z_ohm, input_unit='ohm')  # Calculate per-unit impedance (dimensionless) z_pu = z_actual.quantity / z_base  print(f\"\\\\nTransformer Impedance:\") print(f\"  Z_actual = {z_actual.to('ohm')} \u03a9\") print(f\"  Z_pu = {z_pu.magnitude:.4f} per-unit\")  # Can also go backwards: convert per-unit to ohms z_pu_value = 0.1  # 10% impedance z_ohms = z_pu_value * z_base z_ohms_cim = cim.Resistance(z_ohms) print(f\"\\\\nReverse Calculation:\") print(f\"  Z_pu = {z_pu_value} per-unit\") print(f\"  Z_ohms = {z_ohms_cim.to('ohm'):.2f} \u03a9\") In\u00a0[\u00a0]: Copied! <pre># Example: Calculate per-unit-length impedance for a line segment\n# Line segment data\ntotal_resistance_ohm = 1.85  # \u03a9\ntotal_reactance_ohm = 3.82   # \u03a9\nline_length_km = 10.0        # km\n\n# Create CIM quantities\ntotal_r = cim.Resistance(value=total_resistance_ohm, input_unit='ohm')\ntotal_x = cim.Reactance(value=total_reactance_ohm, input_unit='ohm')\nlength = cim.Length(value=line_length_km, input_unit='km')\n\n# Calculate per-unit-length values\n# Division of \u03a9 by meters gives \u03a9/m\nr_per_length = total_r.quantity / length.quantity\nx_per_length = total_x.quantity / length.quantity\n\n# Wrap results in ResistancePerLength CIMUnit\nr_per_unit = cim.ResistancePerLength(r_per_length)\nx_per_unit = cim.ReactancePerLength(x_per_length)\n\nprint(f\"Total Line Impedance:\")\nprint(f\"  R = {total_r.to('ohm')} \u03a9\")\nprint(f\"  X = {total_x.to('ohm')} \u03a9\")\nprint(f\"  Length = {length.to('km')} km\")\nprint(f\"\\\\nPer-Unit-Length Impedance:\")\nprint(f\"  r = {r_per_unit.to('ohm/km'):.4f} \u03a9/km\")\nprint(f\"  x = {x_per_unit.to('ohm/km'):.4f} \u03a9/km\")\n</pre> # Example: Calculate per-unit-length impedance for a line segment # Line segment data total_resistance_ohm = 1.85  # \u03a9 total_reactance_ohm = 3.82   # \u03a9 line_length_km = 10.0        # km  # Create CIM quantities total_r = cim.Resistance(value=total_resistance_ohm, input_unit='ohm') total_x = cim.Reactance(value=total_reactance_ohm, input_unit='ohm') length = cim.Length(value=line_length_km, input_unit='km')  # Calculate per-unit-length values # Division of \u03a9 by meters gives \u03a9/m r_per_length = total_r.quantity / length.quantity x_per_length = total_x.quantity / length.quantity  # Wrap results in ResistancePerLength CIMUnit r_per_unit = cim.ResistancePerLength(r_per_length) x_per_unit = cim.ReactancePerLength(x_per_length)  print(f\"Total Line Impedance:\") print(f\"  R = {total_r.to('ohm')} \u03a9\") print(f\"  X = {total_x.to('ohm')} \u03a9\") print(f\"  Length = {length.to('km')} km\") print(f\"\\\\nPer-Unit-Length Impedance:\") print(f\"  r = {r_per_unit.to('ohm/km'):.4f} \u03a9/km\") print(f\"  x = {x_per_unit.to('ohm/km'):.4f} \u03a9/km\") In\u00a0[\u00a0]: Copied! <pre># Example: Calculate rated current for a transformer\nimport math\n\n# Transformer ratings\ntransformer_mva = 50.0  # MVA\nvoltage_kv = 138.0  # kV line-to-line\n\n# Create CIM quantities\napparent_power = cim.ApparentPower(value=transformer_mva, input_unit='MVA')\nvoltage = cim.Voltage(value=voltage_kv, input_unit='kV')\n\n# Calculate current: I = S / (\u221a3 \u00d7 V)\n# For three-phase systems\nsqrt3 = math.sqrt(3)\ni = apparent_power.quantity / (sqrt3 * voltage.quantity)\n\n# Wrap result in CurrentFlow CIMUnit\nrated_current = cim.CurrentFlow(i)\n\nprint(f\"Transformer Rating: {apparent_power.to('MVA')} MVA\")\nprint(f\"Voltage: {voltage.to('kV')} kV\")\nprint(f\"Rated Current: {rated_current.to('A'):.1f} A\")\nprint(f\"Rated Current: {rated_current.to('kA'):.3f} kA\")\n</pre> # Example: Calculate rated current for a transformer import math  # Transformer ratings transformer_mva = 50.0  # MVA voltage_kv = 138.0  # kV line-to-line  # Create CIM quantities apparent_power = cim.ApparentPower(value=transformer_mva, input_unit='MVA') voltage = cim.Voltage(value=voltage_kv, input_unit='kV')  # Calculate current: I = S / (\u221a3 \u00d7 V) # For three-phase systems sqrt3 = math.sqrt(3) i = apparent_power.quantity / (sqrt3 * voltage.quantity)  # Wrap result in CurrentFlow CIMUnit rated_current = cim.CurrentFlow(i)  print(f\"Transformer Rating: {apparent_power.to('MVA')} MVA\") print(f\"Voltage: {voltage.to('kV')} kV\") print(f\"Rated Current: {rated_current.to('A'):.1f} A\") print(f\"Rated Current: {rated_current.to('kA'):.3f} kA\") In\u00a0[\u00a0]: Copied! <pre># Example: Calculate capacitor susceptance from reactive power rating\n# Typical shunt capacitor bank data\ncapacitor_mvar = 1.2  # MVAr rating\nbase_voltage_kv = 12.47  # kV nominal voltage\n\n# Create CIM quantities\nreactive_power = cim.ReactivePower(value=capacitor_mvar, input_unit='MVAr')\nbase_voltage = cim.Voltage(value=base_voltage_kv, input_unit='kV')\n\n# Calculate susceptance: B = Q / V\u00b2\n# Access .quantity to perform Pint arithmetic\nb = reactive_power.quantity / (base_voltage.quantity ** 2)\n\n# Wrap result in Susceptance CIMUnit\ncapacitor_susceptance = cim.Susceptance(b)\n\nprint(f\"Capacitor Rating: {reactive_power}\")\nprint(f\"Base Voltage: {base_voltage.to('kV')} kV\")\nprint(f\"Calculated Susceptance: {capacitor_susceptance}\")\nprint(f\"Susceptance in microsiemens: {capacitor_susceptance.to('microsiemens'):.2f} \u00b5S\")\n</pre> # Example: Calculate capacitor susceptance from reactive power rating # Typical shunt capacitor bank data capacitor_mvar = 1.2  # MVAr rating base_voltage_kv = 12.47  # kV nominal voltage  # Create CIM quantities reactive_power = cim.ReactivePower(value=capacitor_mvar, input_unit='MVAr') base_voltage = cim.Voltage(value=base_voltage_kv, input_unit='kV')  # Calculate susceptance: B = Q / V\u00b2 # Access .quantity to perform Pint arithmetic b = reactive_power.quantity / (base_voltage.quantity ** 2)  # Wrap result in Susceptance CIMUnit capacitor_susceptance = cim.Susceptance(b)  print(f\"Capacitor Rating: {reactive_power}\") print(f\"Base Voltage: {base_voltage.to('kV')} kV\") print(f\"Calculated Susceptance: {capacitor_susceptance}\") print(f\"Susceptance in microsiemens: {capacitor_susceptance.to('microsiemens'):.2f} \u00b5S\") In\u00a0[\u00a0]: Copied! <pre># Create active and reactive power quantities\nactive_power = cim.ActivePower(value=10.0, input_unit='MW')\nreactive_power = cim.ReactivePower(value=5.0, input_unit='MVAr')\n\nprint(f\"Active Power: {active_power}\")\nprint(f\"Reactive Power: {reactive_power}\")\n\n# Calculate apparent power using Pythagorean theorem: S = sqrt(P\u00b2 + Q\u00b2)\n# Note: Direct arithmetic between P and Q requires accessing the quantity\nimport math\nP_magnitude = active_power.quantity.magnitude\nQ_magnitude = reactive_power.quantity.magnitude\nS_magnitude = math.sqrt(P_magnitude**2 + Q_magnitude**2)\n\napparent_power = cim.ApparentPower(value=S_magnitude, input_unit='MVA')\nprint(f\"\\\\nApparent Power: {apparent_power}\")\n\n# Calculate power factor: PF = P / S\npower_factor = P_magnitude / S_magnitude\nprint(f\"Power Factor: {power_factor:.3f}\")\n\n# Convert to different units\nprint(f\"\\\\nActive Power in kW: {active_power.to('kW')} kW\")\nprint(f\"Reactive Power in kVAr: {reactive_power.to('kVAr')} kVAr\")\nprint(f\"Apparent Power in VA: {apparent_power.to('VA')} VA\")\n</pre> # Create active and reactive power quantities active_power = cim.ActivePower(value=10.0, input_unit='MW') reactive_power = cim.ReactivePower(value=5.0, input_unit='MVAr')  print(f\"Active Power: {active_power}\") print(f\"Reactive Power: {reactive_power}\")  # Calculate apparent power using Pythagorean theorem: S = sqrt(P\u00b2 + Q\u00b2) # Note: Direct arithmetic between P and Q requires accessing the quantity import math P_magnitude = active_power.quantity.magnitude Q_magnitude = reactive_power.quantity.magnitude S_magnitude = math.sqrt(P_magnitude**2 + Q_magnitude**2)  apparent_power = cim.ApparentPower(value=S_magnitude, input_unit='MVA') print(f\"\\\\nApparent Power: {apparent_power}\")  # Calculate power factor: PF = P / S power_factor = P_magnitude / S_magnitude print(f\"Power Factor: {power_factor:.3f}\")  # Convert to different units print(f\"\\\\nActive Power in kW: {active_power.to('kW')} kW\") print(f\"Reactive Power in kVAr: {reactive_power.to('kVAr')} kVAr\") print(f\"Apparent Power in VA: {apparent_power.to('VA')} VA\")"},{"location":"02_cim_profiles/2_5_using_units/#units-and-quantities-in-cim","title":"Units and Quantities in CIM\u00b6","text":"<p>Power system analysis requires precise handling of physical quantities with proper units. A voltage might be expressed in volts, kilovolts, or megavolts. Power could be in watts, kilowatts, or megawatts. Mixing units or losing track of unit conversions can lead to catastrophic errors in power system analysis.</p> <p>The CIM addresses this by defining strictly typed physical quantities with automatic unit conversion. CIMantic Graphs integrates with Python's Pint library to provide seamless, type-safe unit handling throughout your CIM models.</p>"},{"location":"02_cim_profiles/2_5_using_units/#cim-datatypes-and-units","title":"CIM Datatypes and Units\u00b6","text":"<p>All quantities in CIM have a strictly defined datatype, which is a UML Primitive or SimpleType.</p>"},{"location":"02_cim_profiles/2_5_using_units/#cim-datatypes","title":"CIM Datatypes:\u00b6","text":"<ol> <li><p>Primitives - Basic types like String, Boolean, Integer, Float, DateTime</p> </li> <li><p>SimpleTypes - Physical quantities with units:</p> <ul> <li><code>Voltage</code> (V, kV, MV)</li> <li><code>ActivePower</code> (W, kW, MW, GW)</li> <li><code>ReactivePower</code> (VAr, kVAr, MVAr)</li> <li><code>Resistance</code> (\u03a9, m\u03a9)</li> <li><code>Reactance</code> (\u03a9, m\u03a9)</li> <li><code>Length</code> (m, km, ft, mi)</li> <li><code>Temperature</code> (\u00b0C, \u00b0F, K)</li> <li><code>Frequency</code> (Hz)</li> <li>And many more...</li> </ul> </li> <li><p>Enumerations - Fixed sets of values (PhaseCode, UnitSymbol, etc.)</p> </li> </ol> <p>Each SimpleType includes:</p> <ul> <li>A base unit (e.g., volts for Voltage)</li> <li>A multiplier (e.g., k for kilo, M for mega)</li> <li>Conversion rules between units</li> </ul>"},{"location":"02_cim_profiles/2_5_using_units/#units-implementation-in-cim-graph","title":"Units Implementation in CIM-Graph\u00b6","text":"<p>As part of the CIMTool data profile creation process, dataclasses for all relevant units are created for the custom profile and mapped to Python Pint quantity classes.</p>"},{"location":"02_cim_profiles/2_5_using_units/#pint-integration","title":"Pint Integration\u00b6","text":"<p>Python Pint is a package that defines, operates, and manipulates physical quantities. Key features:</p> <ul> <li>Unit-aware arithmetic - Automatically handles unit conversions in calculations</li> <li>Dimensional analysis - Prevents invalid operations (e.g., adding volts to amperes)</li> <li>Multiple unit systems - Support for SI, imperial, and custom units</li> <li>String parsing - Create quantities from strings like \"230 kV\"</li> <li>Output formatting - Display in any compatible unit</li> </ul>"},{"location":"02_cim_profiles/2_5_using_units/#how-it-works-in-cimantic-graphs","title":"How It Works in CIMantic Graphs:\u00b6","text":"<ol> <li>CIMTool builder generates unit dataclasses (e.g., <code>Voltage</code>, <code>ActivePower</code>)</li> <li>Each unit class wraps a Pint <code>Quantity</code></li> <li>You can create quantities using convenient constructors</li> <li>Values are automatically converted to base SI units internally</li> <li>You can retrieve values in any compatible unit</li> </ol>"},{"location":"02_cim_profiles/2_5_using_units/#working-with-units","title":"Working with Units\u00b6","text":"<p>Let's explore how to create and use unit quantities in CIMantic Graphs:</p>"},{"location":"02_cim_profiles/2_5_using_units/#inspecting-unit-classes","title":"Inspecting Unit Classes\u00b6","text":"<p>First, let's examine the structure of a unit class:</p>"},{"location":"02_cim_profiles/2_5_using_units/#using-units-in-cim-objects","title":"Using Units in CIM Objects\u00b6","text":"<p>When creating CIM equipment objects, use unit quantities for physical attributes:</p>"},{"location":"02_cim_profiles/2_5_using_units/#unit-aware-arithmetic","title":"Unit-Aware Arithmetic\u00b6","text":"<p>Pint automatically handles unit conversions in arithmetic operations:</p>"},{"location":"02_cim_profiles/2_5_using_units/#unit-conversion","title":"Unit Conversion\u00b6","text":"<p>Convert between compatible units easily:</p>"},{"location":"02_cim_profiles/2_5_using_units/#creating-quantities","title":"Creating Quantities\u00b6","text":"<p>There are multiple ways to create unit quantities:</p>"},{"location":"02_cim_profiles/2_5_using_units/#the-cimunit-base-class","title":"The CIMUnit Base Class\u00b6","text":"<p>All unit quantities in CIMantic Graphs inherit from the CIMUnit base class, which provides sophisticated Pint-based unit handling with CIM-specific extensions.</p>"},{"location":"02_cim_profiles/2_5_using_units/#cimunit-architecture","title":"CIMUnit Architecture:\u00b6","text":"<pre>class CIMUnit:\n    value: float                    # Magnitude in base unit\n    unit: UnitSymbol               # CIM unit symbol (V, W, Hz, etc.)\n    multiplier: UnitMultiplier     # k, M, G, etc.\n    quantity: pint.Quantity        # Full Pint quantity object\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#key-features","title":"Key Features:\u00b6","text":"<ol> <li><p>Custom CIM Unit Registry - Extends Pint with power engineering units:</p> <ul> <li><code>VAr</code> (Volt-Ampere Reactive) for reactive power</li> <li><code>VArh</code> (VAr-hours) for reactive energy</li> <li><code>Q</code> (reactive power using imaginary notation)</li> <li>Custom compound units for power systems</li> </ul> </li> <li><p>Automatic Conversion - The <code>__pint__</code> method handles:</p> <ul> <li>Input unit to base unit conversion</li> <li>Unit multiplier application (k, M, G, etc.)</li> <li>CIMUnit to CIMUnit conversion</li> <li>Pint Quantity to magnitude extraction</li> </ul> </li> <li><p>Flexible Initialization - Create units from:</p> <ul> <li>Value + input_unit: <code>Voltage(230.0, 'kV')</code></li> <li>Value + multiplier + unit: <code>Voltage(230.0, input_multiplier='k', input_unit='V')</code></li> <li>Another CIMUnit: <code>Voltage(other_voltage)</code></li> <li>Pint Quantity: <code>Voltage(ureg.Quantity(230, 'kV'))</code></li> </ul> </li> <li><p>Type Conversion - Supports Python numeric types:</p> <ul> <li><code>float(voltage)</code> \u2192 magnitude as float</li> <li><code>int(voltage)</code> \u2192 magnitude as int</li> <li><code>str(voltage)</code> \u2192 formatted with unit</li> <li><code>repr(voltage)</code> \u2192 Pint representation</li> </ul> </li> </ol>"},{"location":"02_cim_profiles/2_5_using_units/#key-patterns-for-unit-calculations","title":"Key Patterns for Unit Calculations\u00b6","text":"<p>The examples above demonstrate common patterns for working with CIM units:</p> <ol> <li><p>Create CIM quantities with appropriate units</p> <pre>power = cim.ActivePower(value=50.0, input_unit='MW')\nvoltage = cim.Voltage(value=138.0, input_unit='kV')\n</pre> </li> <li><p>Access <code>.quantity</code> for Pint arithmetic</p> <pre>result = power.quantity / voltage.quantity\n</pre> </li> <li><p>Pint handles dimensional analysis automatically</p> <ul> <li>MVAr / kV\u00b2 \u2192 Siemens (susceptance)</li> <li>MVA / kV \u2192 Amperes (current)</li> <li>\u03a9 / km \u2192 \u03a9/km (per-unit-length impedance)</li> <li>MW \u00d7 h \u2192 MWh (energy)</li> </ul> </li> <li><p>Wrap calculated results back in CIMUnit</p> <pre>susceptance = cim.Susceptance(calculated_value)\ncurrent = cim.CurrentFlow(calculated_value)\n</pre> </li> <li><p>Convert results to desired display units</p> <pre>print(f\"Current: {current.to('kA'):.2f} kA\")\nprint(f\"Energy: {energy.to('MWh'):.1f} MWh\")\n</pre> </li> </ol> <p>This approach ensures:</p> <ul> <li>Type safety - Wrong dimensions caught at calculation time</li> <li>Unit consistency - Automatic conversion prevents errors</li> <li>Code clarity - Units explicit in calculations</li> <li>Flexibility - Easy conversion for display or export</li> </ul>"},{"location":"02_cim_profiles/2_5_using_units/#energy-calculations-and-time-integration","title":"Energy Calculations and Time Integration\u00b6","text":"<p>Calculate energy from power over time, or convert between energy units:</p> <p>Formula: E = P \u00d7 t</p> <p>where E is energy (Wh), P is power (W), and t is time (h)</p>"},{"location":"02_cim_profiles/2_5_using_units/#per-unit-system-conversions","title":"Per-Unit System Conversions\u00b6","text":"<p>Convert physical quantities to per-unit (dimensionless) values:</p> <p>Formula: X_pu = X_actual / X_base</p> <p>Common base quantities:</p> <ul> <li>S_base: Base apparent power (VA)</li> <li>V_base: Base voltage (V)</li> <li>Z_base = V_base\u00b2 / S_base: Base impedance (\u03a9)</li> <li>I_base = S_base / V_base: Base current (A)</li> </ul>"},{"location":"02_cim_profiles/2_5_using_units/#calculating-line-impedance-per-unit-length","title":"Calculating Line Impedance Per Unit Length\u00b6","text":"<p>Convert total line impedance to per-unit-length values:</p> <p>Formula: r = R_total / length, x = X_total / length</p> <p>where r, x are resistance and reactance per unit length (\u03a9/m)</p>"},{"location":"02_cim_profiles/2_5_using_units/#calculating-current-from-power-and-voltage","title":"Calculating Current from Power and Voltage\u00b6","text":"<p>For three-phase systems, calculate current from apparent power:</p> <p>Formula: I = S / (\u221a3 \u00d7 V)</p> <p>where I is current (A), S is apparent power (VA), and V is line-to-line voltage (V)</p>"},{"location":"02_cim_profiles/2_5_using_units/#practical-power-system-calculations","title":"Practical Power System Calculations\u00b6","text":"<p>Real power system analysis often requires converting between different quantity types through calculations. Here are common examples:</p>"},{"location":"02_cim_profiles/2_5_using_units/#calculating-susceptance-from-reactive-power","title":"Calculating Susceptance from Reactive Power\u00b6","text":"<p>Shunt capacitor susceptance is calculated from reactive power and voltage:</p> <p>Formula: B = Q / V\u00b2</p> <p>where B is susceptance (Siemens), Q is reactive power (VAr), and V is voltage (V)</p>"},{"location":"02_cim_profiles/2_5_using_units/#summary","title":"Summary\u00b6","text":"<p>CIMantic Graphs provides sophisticated, type-safe unit handling for power system modeling:</p>"},{"location":"02_cim_profiles/2_5_using_units/#key-features","title":"Key Features:\u00b6","text":"<ol> <li>CIMUnit Base Class - All unit quantities inherit from CIMUnit with Pint integration</li> <li>Custom CIM Units - Extended Pint registry with power engineering units (VAr, VAh, Q, etc.)</li> <li>Automatic Conversion - Seamless conversion between compatible units</li> <li>Dimensional Analysis - Prevents mixing incompatible quantities (e.g., watts + vars)</li> <li>XML Serialization - Exports only magnitude in base units per CIM standard</li> <li>Type Safety - Full Python type hints and IDE support</li> </ol>"},{"location":"02_cim_profiles/2_5_using_units/#unit-architecture","title":"Unit Architecture:\u00b6","text":"<pre><code>CIMUnit (base class)\n\u251c\u2500\u2500 Pint UnitRegistry (custom CIM units)\n\u251c\u2500\u2500 UnitSymbol enum (V, W, Hz, VAr, etc.)\n\u251c\u2500\u2500 UnitMultiplier enum (k, M, G, etc.)\n\u2514\u2500\u2500 Generated unit classes (Voltage, ActivePower, etc.)\n</code></pre>"},{"location":"02_cim_profiles/2_5_using_units/#common-unit-types","title":"Common Unit Types:\u00b6","text":"<ul> <li>Voltage: V, kV, MV</li> <li>Active Power: W, kW, MW, GW</li> <li>Reactive Power: VAr, kVAr, MVAr</li> <li>Apparent Power: VA, kVA, MVA</li> <li>Current: A, kA</li> <li>Resistance/Reactance: ohm, m\u03a9</li> <li>Length: m, km, ft, mi</li> <li>Frequency: Hz, kHz</li> </ul>"},{"location":"02_cim_profiles/2_5_using_units/#benefits","title":"Benefits:\u00b6","text":"<ol> <li>Eliminates Unit Errors - Automatic conversion prevents manual mistakes</li> <li>Improves Code Clarity - Units are explicit in code: <code>Voltage(230, 'kV')</code></li> <li>Maintains CIM Compliance - Follows CIM standards for unit representation</li> <li>Enables Validation - Dimensional analysis catches logic errors early</li> <li>Supports Analysis - Proper handling of complex power (P, Q, S)</li> </ol>"},{"location":"02_cim_profiles/2_5_using_units/#going-forward","title":"Going Forward:\u00b6","text":"<p>With comprehensive unit support, you can now:</p> <ul> <li>Build accurate power system models</li> <li>Perform calculations with automatic unit conversion</li> <li>Exchange models with other CIM-compliant systems</li> <li>Avoid common unit conversion errors</li> <li>Leverage Pint's full capabilities for advanced analysis</li> </ul> <p>The combination of CIM profiles, incremental updates, and type-safe units provides a robust foundation for sophisticated power system applications!</p>"},{"location":"02_cim_profiles/2_5_using_units/#best-practices-for-units","title":"Best Practices for Units\u00b6","text":""},{"location":"02_cim_profiles/2_5_using_units/#1-always-use-appropriate-units-for-input","title":"1. Always Use Appropriate Units for Input\u00b6","text":"<p>Choose input units that match your data source:</p> <pre># Good - matches typical utility data\nvoltage = cim.Voltage(value=12.47, input_unit='kV')\npower = cim.ActivePower(value=5.5, input_unit='MW')\n\n# Avoid - requires unnecessary scaling\nvoltage = cim.Voltage(value=12470.0, input_unit='V')  # Less readable\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#2-let-pint-handle-conversions","title":"2. Let Pint Handle Conversions\u00b6","text":"<p>Don't manually convert units - let the library handle it:</p> <pre># Good - automatic conversion\nv_kV = cim.Voltage(value=138.0, input_unit='kV')\nv_V = v_kV.to('V')  # Pint handles conversion\n\n# Avoid - manual conversion prone to errors\nv_kV = 138.0\nv_V = v_kV * 1000  # Error-prone!\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#3-use-correct-power-types","title":"3. Use Correct Power Types\u00b6","text":"<p>Use the appropriate power type for your application:</p> <pre># Active power (real power) - watts\np = cim.ActivePower(value=100.0, input_unit='MW')\n\n# Reactive power - VARs\nq = cim.ReactivePower(value=50.0, input_unit='MVAr')\n\n# Apparent power - VA\ns = cim.ApparentPower(value=111.8, input_unit='MVA')\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#4-document-unit-assumptions","title":"4. Document Unit Assumptions\u00b6","text":"<p>When importing data, document unit assumptions:</p> <pre># Document expected units when importing external data\ndef import_transformer_data(kV_rating, MVA_rating):\n    \"\"\"\n    Import transformer ratings.\n    \n    Args:\n        kV_rating: Voltage rating in kilovolts\n        MVA_rating: Power rating in megavolt-amperes\n    \"\"\"\n    return cim.PowerTransformer(\n        ratedU=cim.Voltage(value=kV_rating, input_unit='kV'),\n        ratedS=cim.ApparentPower(value=MVA_rating, input_unit='MVA')\n    )\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#5-validate-unit-compatibility","title":"5. Validate Unit Compatibility\u00b6","text":"<p>When combining quantities, ensure dimensional compatibility:</p> <pre># Good - compatible dimensions\nv1 = cim.Voltage(value=12.47, input_unit='kV')\nv2 = cim.Voltage(value=4.16, input_unit='kV')\nv_total = cim.Voltage(value=v1.quantity + v2.quantity)\n\n# Pint will raise error for incompatible dimensions\n# This would fail: v1.quantity + active_power.quantity\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#6-access-magnitude-for-pure-calculations","title":"6. Access Magnitude for Pure Calculations\u00b6","text":"<p>For numerical computations, extract magnitude:</p> <pre>voltage = cim.Voltage(value=230.0, input_unit='kV')\ncurrent = cim.CurrentFlow(value=100.0, input_unit='A')\n\n# Extract magnitudes for calculation\nV = voltage.quantity.to('V').magnitude\nI = current.quantity.to('A').magnitude\n\n# Calculate (example)\npower_loss = V * I * 0.01  # 1% loss\n\n# Wrap result back in CIMUnit\nloss = cim.ActivePower(value=power_loss, input_unit='W')\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#advanced-unit-operations","title":"Advanced Unit Operations\u00b6","text":""},{"location":"02_cim_profiles/2_5_using_units/#accessing-the-underlying-pint-quantity","title":"Accessing the Underlying Pint Quantity\u00b6","text":"<p>For advanced operations, access the Pint <code>quantity</code> attribute directly:</p> <pre>voltage = cim.Voltage(value=138.0, input_unit='kV')\n\n# Access Pint quantity for full Pint capabilities\npint_qty = voltage.quantity\n\n# Pint operations\nprint(pint_qty.dimensionality)     # [length]^2 * [mass] / [current] / [time]^3\nprint(pint_qty.to_base_units())    # Convert to base SI\nprint(pint_qty.to_compact())       # Use most compact representation\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#converting-between-cimunit-types","title":"Converting Between CIMUnit Types\u00b6","text":"<p>You can convert between compatible CIMUnit types:</p> <pre># Create a voltage from another voltage\nv1 = cim.Voltage(value=12.47, input_unit='kV')\nv2 = cim.Voltage(value=v1)  # Copy with conversion\n\n# Convert units during copy\nv3 = cim.Voltage(value=v1.to('V'), input_unit='V')\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#using-multipliers-explicitly","title":"Using Multipliers Explicitly\u00b6","text":"<p>CIM multipliers can be specified separately:</p> <pre># These are equivalent:\nv1 = cim.Voltage(value=138.0, input_unit='kV')\nv2 = cim.Voltage(value=138.0, input_unit='V', input_multiplier='k')\n\n# Multiplier is stored in the object\nprint(v2.multiplier)  # UnitMultiplier.k\nprint(v2.unit)        # UnitSymbol.V\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#type-checking-and-validation","title":"Type Checking and Validation\u00b6","text":"<p>Use isinstance to check if a value is a unit:</p> <pre>from cimgraph.data_profile.units.units import CIMUnit\n\nvalue = cim.Voltage(value=230.0, input_unit='kV')\n\nif isinstance(value, CIMUnit):\n    print(f\"Unit value: {value}\")\n    print(f\"Magnitude: {value.quantity.magnitude}\")\n    print(f\"Base unit: {value.unit}\")\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#xml-serialization-and-units","title":"XML Serialization and Units\u00b6","text":"<p>When exporting CIM models to XML, units are handled specially to maintain CIM compliance and minimize file size.</p>"},{"location":"02_cim_profiles/2_5_using_units/#how-units-are-serialized","title":"How Units Are Serialized:\u00b6","text":"<p>When a CIMUnit attribute is encountered during XML export, only the magnitude in base units is written to the XML file:</p> <pre># In cimgraph/utils/write_xml.py (line 102-103)\nelif isinstance(edge, CIMUnit):\n    row = f'&lt;{ns_prefix}:{parent.__name__}.{attribute}&gt;{str(edge.quantity.magnitude)}&lt;/{ns_prefix}:{parent.__name__}.{attribute}&gt;\\n'\n    f.write(row)\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#example","title":"Example:\u00b6","text":"<pre># Python object\nline = cim.ACLineSegment(\n    mRID='_line-001',\n    r=cim.Resistance(value=0.185, input_unit='ohm'),\n    length=cim.Length(value=2.5, input_unit='km')\n)\n\n# XML output\n&lt;cim:ACLineSegment rdf:ID=\"_line-001\"&gt;\n  &lt;cim:ACLineSegment.r&gt;0.185&lt;/cim:ACLineSegment.r&gt;\n  &lt;cim:ACLineSegment.length&gt;2500.0&lt;/cim:ACLineSegment.length&gt;\n&lt;/cim:ACLineSegment&gt;\n</pre> <p>Notice:</p> <ul> <li>Resistance is written as <code>0.185</code> (in base ohms)</li> <li>Length is written as <code>2500.0</code> (converted from 2.5 km to base meters)</li> <li>No unit labels in XML - the CIM profile schema defines the expected units</li> </ul>"},{"location":"02_cim_profiles/2_5_using_units/#why-only-magnitude","title":"Why Only Magnitude?\u00b6","text":"<ol> <li>CIM Standard Compliance - CIM XML schema specifies units in the profile, not in instance data</li> <li>File Size - Avoids repetitive unit labels for every attribute</li> <li>Consistency - All values in a given attribute must use the same unit</li> <li>Simplicity - Parsers don't need to handle unit conversion during import</li> </ol>"},{"location":"02_cim_profiles/2_5_using_units/#import-behavior","title":"Import Behavior:\u00b6","text":"<p>When importing XML, CIMantic Graphs assumes values are in base SI units:</p> <pre># XML contains: &lt;cim:ACLineSegment.r&gt;0.185&lt;/cim:ACLineSegment.r&gt;\n\n# Imported as:\nline.r = cim.Resistance(value=0.185, input_unit='ohm')  # Base unit\n</pre> <p>If your XML uses different units, you must specify the import unit mapping or convert during import.</p>"},{"location":"02_cim_profiles/2_5_using_units/#working-with-reactive-power","title":"Working with Reactive Power\u00b6","text":"<p>Let's see how the custom VAr units work in practice:</p>"},{"location":"02_cim_profiles/2_5_using_units/#custom-cim-units-for-power-systems","title":"Custom CIM Units for Power Systems\u00b6","text":"<p>CIMantic Graphs extends Pint with custom power engineering units defined in <code>cim_units/units.txt</code>. These units are essential for power system analysis but not included in standard Pint.</p>"},{"location":"02_cim_profiles/2_5_using_units/#key-custom-units","title":"Key Custom Units:\u00b6","text":""},{"location":"02_cim_profiles/2_5_using_units/#reactive-power-and-energy","title":"Reactive Power and Energy:\u00b6","text":"<pre><code>VAr = watt * imaginary              # Volt-Ampere Reactive\nVArh = watt * hour * imaginary      # VAr-hours (reactive energy)\nQ = imaginary * watt                # Reactive power (Q notation)\nQh = imaginary * watt * hour        # Reactive energy\n</code></pre> <p>The <code>imaginary</code> dimension enables proper dimensional analysis for reactive power, treating it as distinct from active power while maintaining mathematical relationships.</p>"},{"location":"02_cim_profiles/2_5_using_units/#apparent-power","title":"Apparent Power:\u00b6","text":"<pre><code>VA = volt * amp                      # Volt-Ampere (apparent power)\nVAh = volt * amp * hour             # VA-hours (apparent energy)\n</code></pre>"},{"location":"02_cim_profiles/2_5_using_units/#complex-power-relationships","title":"Complex Power Relationships:\u00b6","text":"<pre><code>S = P + jQ\nwhere:\n  S = Apparent power (VA)\n  P = Active power (W)\n  Q = Reactive power (VAr)\n  j = imaginary unit\n</code></pre> <p>Pint's dimensional analysis ensures:</p> <ul> <li>You can't accidentally add watts to VARs</li> <li>Power factor calculations use correct units</li> <li>Energy conversions maintain proper dimensions</li> </ul>"},{"location":"02_cim_profiles/2_5_using_units/#other-power-engineering-units","title":"Other Power Engineering Units:\u00b6","text":"<ul> <li>Voltage Squared: <code>V2 = volt * volt</code> (for regulation calculations)</li> <li>Voltage-Hours: <code>Vh = volt * hour</code> (for energy storage)</li> <li>Per-Unit Quantities: <code>VPerV = volt / volt</code>, <code>WPerW = watt / watt</code></li> <li>Power Density: <code>WPerm2 = watt / meter / meter</code></li> <li>Various Ratios: <code>APerA</code>, <code>HzPerHz</code>, etc.</li> </ul>"},{"location":"02_cim_profiles/2_5_using_units/#unit-dataclass-structure","title":"Unit Dataclass Structure\u00b6","text":"<p>The CIMTool builder generates unit dataclasses for each physical quantity type in your profile. Here's the structure:</p> <pre>@stereotype(CIMStereotype.CIMDatatype)\n@dataclass(repr=False)\nclass Voltage(CIMUnit):\n    '''\n    Electrical voltage, can be both AC and DC.\n    '''\n    value: float = field(default=None)\n    multiplier: UnitMultiplier = field(default=UnitMultiplier.none)\n    \n    @property  # read-only\n    def unit(self):\n        return UnitSymbol.V\n    \n    def __init__(self, value, input_unit: str='V', input_multiplier: str=None):\n        self.__pint__(value=value, input_unit=input_unit, input_multiplier=input_multiplier)\n</pre>"},{"location":"02_cim_profiles/2_5_using_units/#key-components","title":"Key Components:\u00b6","text":"<ol> <li>@stereotype(CIMStereotype.CIMDatatype) - Marks this as a CIM datatype (not a class)</li> <li>@dataclass(repr=False) - Python dataclass with custom <code>__repr__</code></li> <li>value field - Stores the magnitude in base unit</li> <li>multiplier field - Stores the unit multiplier (k, M, G, etc.)</li> <li>unit property - Returns the base UnitSymbol (read-only)</li> <li>__init__ - Calls <code>__pint__</code> from CIMUnit to initialize the Pint quantity</li> </ol>"},{"location":"02_cim_profiles/2_5_using_units/#unit-symbols-and-multipliers","title":"Unit Symbols and Multipliers:\u00b6","text":"<p>CIM defines standard enumerations for units and multipliers:</p> <p>UnitSymbol - Base units like <code>V</code>, <code>W</code>, <code>Hz</code>, <code>ohm</code>, <code>A</code>, <code>VAr</code>, etc. UnitMultiplier - SI multipliers: <code>k</code>, <code>M</code>, <code>G</code>, <code>T</code>, <code>m</code>, <code>micro</code>, <code>n</code>, etc.</p>"},{"location":"03_databases/3_10_rdflib_parser/","title":"RDFLib Parser","text":"In\u00a0[\u00a0]: Copied! <pre>from cimgraph.databases.rdflib.rdflib import RDFlibConnection\n# RDFLib File Reader Connection\nparams = ConnectionParameters(filename=\"./maple10bus.xml\",\n                               cim_profile='rc4_2021', iec61970_301=7)\nrdf = RDFlibConnection(params)\n</pre> from cimgraph.databases.rdflib.rdflib import RDFlibConnection # RDFLib File Reader Connection params = ConnectionParameters(filename=\"./maple10bus.xml\",                                cim_profile='rc4_2021', iec61970_301=7) rdf = RDFlibConnection(params)"},{"location":"03_databases/3_10_rdflib_parser/#rdflib-file-parser","title":"RDFLib File Parser\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/","title":"Databases Overview","text":"In\u00a0[\u00a0]: Copied! <pre>from mermaid import Mermaid\n\ndiagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%%\nclassDiagram\n    class ConnectionInterface {\n        &lt;&lt;abstract&gt;&gt;\n        +Graph: TypeAlias\n        +cim_profile: str\n        +namespace: str\n        +iec61970_301: str\n        +log_level: int\n        +connect()*\n        +disconnect()*\n        +execute(query)* QueryResponse\n        +get_object(mRID, graph) object\n        +get_from_triple(subject, predicate, graph) list\n        +create_new_graph(container, graph) Graph\n        +create_distributed_graph(area, graph) Graph\n        +get_all_edges(graph, cim_class)*\n        +get_all_attributes(graph, cim_class)*\n        +upload(graph)*\n        #create_object(graph, class_type, uri) object\n        #create_edge(graph, cim_class, id, attr, edge_class, edge_mRID) object\n        #create_value(graph, cim_class, id, attr, value) value\n        #check_attribute(cim_class, attribute) str\n    }\n    \n    class SPARQLEndpointConnection {\n        &lt;&lt;abstract&gt;&gt;\n        +connection_obj: object\n        #_setup_connection()*\n        #_execute_raw_query(query)* QueryResponse\n        #_parse_result_field(result, field)* str\n        #_update_raw(update)* str\n        #_get_namespaces() list~str~\n        +parse_node_query(graph, output) Graph\n        +edge_query_parser(output, graph, class) list\n        +build_graph_from_list(graph, mrid_list) Graph\n    }\n    \n    class XMLFile {\n        +filename: str\n        +tree: ElementTree\n        +root: Element\n        +namespaces: dict\n        +parse_nodes(element) Identity\n        +parse_edges(element)\n        +parse_value(sub_element, class, id)\n        +extract_namespaces_from_header() dict\n    }\n    \n    class BlazegraphConnection {\n        +url: str\n        +namespaces: list~str~\n    }\n    \n    class GraphDBConnection {\n        +url: str\n        +repository: str\n    }\n    \n    class RDFlibConnection {\n        +store_type: str\n        +identifier: str\n    }\n    \n    class Neo4jConnection {\n        +host: str\n        +port: int\n        +database: str\n    }\n    \n    ConnectionInterface &lt;|-- SPARQLEndpointConnection\n    ConnectionInterface &lt;|-- XMLFile\n    SPARQLEndpointConnection &lt;|-- BlazegraphConnection\n    SPARQLEndpointConnection &lt;|-- GraphDBConnection\n    SPARQLEndpointConnection &lt;|-- RDFlibConnection\n    ConnectionInterface &lt;|-- Neo4jConnection\n\"\"\"\n\nMermaid(diagram_text)\n</pre> from mermaid import Mermaid  diagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%% classDiagram     class ConnectionInterface {         &lt;&gt;         +Graph: TypeAlias         +cim_profile: str         +namespace: str         +iec61970_301: str         +log_level: int         +connect()*         +disconnect()*         +execute(query)* QueryResponse         +get_object(mRID, graph) object         +get_from_triple(subject, predicate, graph) list         +create_new_graph(container, graph) Graph         +create_distributed_graph(area, graph) Graph         +get_all_edges(graph, cim_class)*         +get_all_attributes(graph, cim_class)*         +upload(graph)*         #create_object(graph, class_type, uri) object         #create_edge(graph, cim_class, id, attr, edge_class, edge_mRID) object         #create_value(graph, cim_class, id, attr, value) value         #check_attribute(cim_class, attribute) str     }          class SPARQLEndpointConnection {         &lt;&gt;         +connection_obj: object         #_setup_connection()*         #_execute_raw_query(query)* QueryResponse         #_parse_result_field(result, field)* str         #_update_raw(update)* str         #_get_namespaces() list~str~         +parse_node_query(graph, output) Graph         +edge_query_parser(output, graph, class) list         +build_graph_from_list(graph, mrid_list) Graph     }          class XMLFile {         +filename: str         +tree: ElementTree         +root: Element         +namespaces: dict         +parse_nodes(element) Identity         +parse_edges(element)         +parse_value(sub_element, class, id)         +extract_namespaces_from_header() dict     }          class BlazegraphConnection {         +url: str         +namespaces: list~str~     }          class GraphDBConnection {         +url: str         +repository: str     }          class RDFlibConnection {         +store_type: str         +identifier: str     }          class Neo4jConnection {         +host: str         +port: int         +database: str     }          ConnectionInterface &lt;|-- SPARQLEndpointConnection     ConnectionInterface &lt;|-- XMLFile     SPARQLEndpointConnection &lt;|-- BlazegraphConnection     SPARQLEndpointConnection &lt;|-- GraphDBConnection     SPARQLEndpointConnection &lt;|-- RDFlibConnection     ConnectionInterface &lt;|-- Neo4jConnection \"\"\"  Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>diagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%%\nsequenceDiagram\n    actor User\n    participant FeederModel\n    participant SPARQLEndpoint\n    participant QueryModule\n    participant Database\n    \n    note right of User: Load feeder from database\n    User -&gt;&gt;+ FeederModel: FeederModel(container, connection)\n    FeederModel -&gt;&gt;+ SPARQLEndpoint: create_new_graph(container)\n    SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: add_to_graph(container)\n    \n    SPARQLEndpoint -&gt;&gt;+ QueryModule: get_all_nodes_from_container(container)\n    QueryModule --&gt;&gt;- SPARQLEndpoint: SPARQL query string\n    \n    SPARQLEndpoint -&gt;&gt;+ SPARQLEndpoint: execute(query)\n    SPARQLEndpoint -&gt;&gt;+ Database: _execute_raw_query(query)\n    Database --&gt;&gt;- SPARQLEndpoint: query results (JSON)\n    SPARQLEndpoint --&gt;&gt;- SPARQLEndpoint: QueryResponse\n    \n    SPARQLEndpoint -&gt;&gt;+ SPARQLEndpoint: parse_node_query(graph, results)\n    loop for each result\n        SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: parse Equipment JSON-LD\n        SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create_object(Equipment)\n        SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create_object(Terminal)\n        SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create_object(ConnectivityNode)\n        SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: link Equipment \u2194 Terminal \u2194 Node\n    end\n    SPARQLEndpoint --&gt;&gt;- SPARQLEndpoint: updated graph\n    \n    SPARQLEndpoint --&gt;&gt;- FeederModel: Graph with base topology\n    FeederModel --&gt;&gt;- User: FeederModel instance\n\"\"\"\n\nMermaid(diagram_text)\n</pre> diagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%% sequenceDiagram     actor User     participant FeederModel     participant SPARQLEndpoint     participant QueryModule     participant Database          note right of User: Load feeder from database     User -&gt;&gt;+ FeederModel: FeederModel(container, connection)     FeederModel -&gt;&gt;+ SPARQLEndpoint: create_new_graph(container)     SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: add_to_graph(container)          SPARQLEndpoint -&gt;&gt;+ QueryModule: get_all_nodes_from_container(container)     QueryModule --&gt;&gt;- SPARQLEndpoint: SPARQL query string          SPARQLEndpoint -&gt;&gt;+ SPARQLEndpoint: execute(query)     SPARQLEndpoint -&gt;&gt;+ Database: _execute_raw_query(query)     Database --&gt;&gt;- SPARQLEndpoint: query results (JSON)     SPARQLEndpoint --&gt;&gt;- SPARQLEndpoint: QueryResponse          SPARQLEndpoint -&gt;&gt;+ SPARQLEndpoint: parse_node_query(graph, results)     loop for each result         SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: parse Equipment JSON-LD         SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create_object(Equipment)         SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create_object(Terminal)         SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create_object(ConnectivityNode)         SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: link Equipment \u2194 Terminal \u2194 Node     end     SPARQLEndpoint --&gt;&gt;- SPARQLEndpoint: updated graph          SPARQLEndpoint --&gt;&gt;- FeederModel: Graph with base topology     FeederModel --&gt;&gt;- User: FeederModel instance \"\"\"  Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>diagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%%\nsequenceDiagram\n    actor User\n    participant FeederModel\n    participant SPARQLEndpoint\n    participant QueryModule\n    participant Database\n    \n    note right of User: Expand breaker attributes\n    User -&gt;&gt;+ FeederModel: get_all_edges(cim.Breaker)\n    FeederModel -&gt;&gt;+ SPARQLEndpoint: get_all_edges(graph, cim.Breaker)\n    \n    SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: get UUIDs from graph[cim.Breaker]\n    SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: split into batches of 100\n    \n    par Parallel Batch Processing\n        loop for each batch\n            SPARQLEndpoint -&gt;&gt;+ QueryModule: get_all_edges_sparql(graph, cim.Breaker, batch)\n            QueryModule --&gt;&gt;- SPARQLEndpoint: SPARQL query\n            \n            SPARQLEndpoint -&gt;&gt;+ Database: execute(query)\n            Database --&gt;&gt;- SPARQLEndpoint: query results\n            \n            SPARQLEndpoint -&gt;&gt;+ SPARQLEndpoint: edge_query_parser(results)\n            loop for each result\n                alt Association (edge)\n                    SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create_edge() to linked object\n                else Enumeration\n                    SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create enum instance\n                else Primitive value\n                    SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create_value() with type conversion\n                end\n            end\n            SPARQLEndpoint --&gt;&gt;- SPARQLEndpoint: batch complete\n        end\n    end\n    \n    SPARQLEndpoint --&gt;&gt;- FeederModel: None (graph updated)\n    FeederModel --&gt;&gt;- User: None\n\"\"\"\n\nMermaid(diagram_text)\n</pre> diagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%% sequenceDiagram     actor User     participant FeederModel     participant SPARQLEndpoint     participant QueryModule     participant Database          note right of User: Expand breaker attributes     User -&gt;&gt;+ FeederModel: get_all_edges(cim.Breaker)     FeederModel -&gt;&gt;+ SPARQLEndpoint: get_all_edges(graph, cim.Breaker)          SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: get UUIDs from graph[cim.Breaker]     SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: split into batches of 100          par Parallel Batch Processing         loop for each batch             SPARQLEndpoint -&gt;&gt;+ QueryModule: get_all_edges_sparql(graph, cim.Breaker, batch)             QueryModule --&gt;&gt;- SPARQLEndpoint: SPARQL query                          SPARQLEndpoint -&gt;&gt;+ Database: execute(query)             Database --&gt;&gt;- SPARQLEndpoint: query results                          SPARQLEndpoint -&gt;&gt;+ SPARQLEndpoint: edge_query_parser(results)             loop for each result                 alt Association (edge)                     SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create_edge() to linked object                 else Enumeration                     SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create enum instance                 else Primitive value                     SPARQLEndpoint -&gt;&gt; SPARQLEndpoint: create_value() with type conversion                 end             end             SPARQLEndpoint --&gt;&gt;- SPARQLEndpoint: batch complete         end     end          SPARQLEndpoint --&gt;&gt;- FeederModel: None (graph updated)     FeederModel --&gt;&gt;- User: None \"\"\"  Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nimport cimgraph.data_profile.cimhub_2023 as cim\n\nfrom cimgraph.databases import XMLFile\nfrom cimgraph.models import FeederModel\n\n# Load from XML\nfile = XMLFile(filename='../../sample_models/ieee13.xml')\nnetwork = FeederModel(container=cim.Feeder(), connection=file)\n\nprint(f\"Loaded {len(network.graph[cim.ACLineSegment])} lines\")\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' import cimgraph.data_profile.cimhub_2023 as cim  from cimgraph.databases import XMLFile from cimgraph.models import FeederModel  # Load from XML file = XMLFile(filename='../../sample_models/ieee13.xml') network = FeederModel(container=cim.Feeder(), connection=file)  print(f\"Loaded {len(network.graph[cim.ACLineSegment])} lines\") In\u00a0[\u00a0]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nos.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql'\nimport cimgraph.data_profile.cimhub_2023 as cim\n\nfrom cimgraph.databases import BlazegraphConnection\nfrom cimgraph.models import FeederModel\n\n# Connect to Blazegraph\ndb = BlazegraphConnection()\n\n# Load feeder from database\nfeeder = cim.Feeder(mRID='49AD8E07-3BF9-A4E2-CB8F-C3722F837B62')\nnetwork = FeederModel(container=feeder, connection=db)\n\n# Expand breakers\nnetwork.get_all_edges(cim.Breaker)\n\nprint(f\"Loaded {len(network.graph[cim.Breaker])} breakers\")\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' os.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql' import cimgraph.data_profile.cimhub_2023 as cim  from cimgraph.databases import BlazegraphConnection from cimgraph.models import FeederModel  # Connect to Blazegraph db = BlazegraphConnection()  # Load feeder from database feeder = cim.Feeder(mRID='49AD8E07-3BF9-A4E2-CB8F-C3722F837B62') network = FeederModel(container=feeder, connection=db)  # Expand breakers network.get_all_edges(cim.Breaker)  print(f\"Loaded {len(network.graph[cim.Breaker])} breakers\") In\u00a0[\u00a0]: Copied! <pre># Same code works with any database backend!\nfrom cimgraph.databases import GraphDBConnection, RDFlibConnection\n\n# Option 1: GraphDB\n# db = GraphDBConnection()\n\n# Option 2: RDFlib\n# db = RDFlibConnection()\n\n# Option 3: Blazegraph\ndb = BlazegraphConnection()\n\n# Everything else stays the same\nfeeder = cim.Feeder(mRID='49AD8E07-3BF9-A4E2-CB8F-C3722F837B62')\nnetwork = FeederModel(container=feeder, connection=db)\n</pre> # Same code works with any database backend! from cimgraph.databases import GraphDBConnection, RDFlibConnection  # Option 1: GraphDB # db = GraphDBConnection()  # Option 2: RDFlib # db = RDFlibConnection()  # Option 3: Blazegraph db = BlazegraphConnection()  # Everything else stays the same feeder = cim.Feeder(mRID='49AD8E07-3BF9-A4E2-CB8F-C3722F837B62') network = FeederModel(container=feeder, connection=db)"},{"location":"03_databases/3_1_databases_overview/#databases-overview","title":"Databases Overview\u00b6","text":"<p>CIMantic Graphs provides a unified interface for accessing CIM power system models stored in multiple database backends and file formats. This flexibility allows users to choose the best storage solution for their specific use case, from simple XML files for small test cases to enterprise-grade graph databases for utility-scale networks.</p>"},{"location":"03_databases/3_1_databases_overview/#available-database-backends","title":"Available Database Backends\u00b6","text":"<p>CIMantic Graphs supports the following database connections:</p>"},{"location":"03_databases/3_1_databases_overview/#file-based-parsers","title":"File-Based Parsers\u00b6","text":"<ul> <li><p>XMLFile - CIM XML/RDF file parser (IEC 61970-301 compliant)</p> <ul> <li>Best for: Small test cases (IEEE 13, 123-bus)</li> <li>No database infrastructure required</li> <li>Documentation: XML File Parser</li> </ul> </li> <li><p>JSON-LD File Parser - JSON-LD file parser</p> <ul> <li>Best for: Web-based applications and REST APIs</li> <li>Modern JSON format with RDF semantics</li> <li>Documentation: JSON-LD Parser</li> </ul> </li> </ul>"},{"location":"03_databases/3_1_databases_overview/#sparql-triple-stores","title":"SPARQL Triple Stores\u00b6","text":"<ul> <li><p>Blazegraph - High-performance RDF database</p> <ul> <li>Best for: Large distribution models (IEEE 8500+)</li> <li>Fast query execution and bulk loading</li> <li>Documentation: Blazegraph</li> </ul> </li> <li><p>GraphDB - Enterprise semantic graph database (Ontotext)</p> <ul> <li>Best for: Enterprise deployments with reasoning requirements</li> <li>Advanced SPARQL features and reasoning engines</li> <li>Documentation: GraphDB</li> </ul> </li> <li><p>RDFlib - Pure Python RDF library with in-memory and persistent stores</p> <ul> <li>Best for: Python-native applications and testing</li> <li>No external database required</li> <li>Documentation: RDFlib</li> </ul> </li> </ul>"},{"location":"03_databases/3_1_databases_overview/#labeled-property-graph-databases","title":"Labeled Property Graph Databases\u00b6","text":"<ul> <li>Neo4j - Leading property graph database<ul> <li>Best for: Graph algorithms and path analysis</li> <li>Cypher query language</li> <li>Documentation: Neo4j</li> </ul> </li> </ul>"},{"location":"03_databases/3_1_databases_overview/#specialized-connections","title":"Specialized Connections\u00b6","text":"<ul> <li><p>GridAPPS-D - Integration with GridAPPS-D platform</p> <ul> <li>Best for: Distribution grid simulation workflows</li> <li>Direct integration with GOSS message bus</li> <li>Documentation: GridAPPS-D</li> </ul> </li> <li><p>MySQL - Relational database with JSON-LD storage</p> <ul> <li>Best for: Integration with existing SQL infrastructure</li> <li>Experimental support</li> <li>Documentation: MySQL</li> </ul> </li> </ul>"},{"location":"03_databases/3_1_databases_overview/#architecture","title":"Architecture\u00b6","text":"<p>All database connections in CIMantic Graphs implement the <code>ConnectionInterface</code> abstract base class, which defines a consistent API for:</p> <ul> <li>Connection Management: <code>connect()</code>, <code>disconnect()</code></li> <li>Query Execution: <code>execute()</code>, <code>update()</code></li> <li>Object Retrieval: <code>get_object()</code>, <code>get_from_triple()</code></li> <li>Graph Creation: <code>create_new_graph()</code>, <code>create_distributed_graph()</code></li> <li>Graph Expansion: <code>get_all_edges()</code>, <code>get_all_attributes()</code></li> <li>Data Upload: <code>upload()</code></li> </ul> <p>This abstraction allows users to switch between database backends without changing their application code.</p>"},{"location":"03_databases/3_1_databases_overview/#connectioninterface-class-diagram","title":"ConnectionInterface Class Diagram\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#sparql-endpoint-architecture","title":"SPARQL Endpoint Architecture\u00b6","text":"<p>The majority of database backends (Blazegraph, GraphDB, RDFlib) share a common SPARQL-based implementation through the <code>SPARQLEndpointConnection</code> abstract class. This unified architecture provides:</p> <ul> <li>Common query generation via the <code>cimgraph.queries.sparql</code> module</li> <li>Shared parsing logic for SPARQL query results</li> <li>Parallel query execution with batching for performance</li> <li>Template method pattern where subclasses implement only database-specific connection details</li> </ul>"},{"location":"03_databases/3_1_databases_overview/#database-specific-implementation-requirements","title":"Database-Specific Implementation Requirements\u00b6","text":"<p>Each SPARQL database backend must implement four abstract methods:</p> <ol> <li><code>_setup_connection()</code> - Initialize the database-specific connection object</li> <li><code>_execute_raw_query(query_message)</code> - Execute a SPARQL query and return raw results</li> <li><code>_parse_result_field(result, field_name)</code> - Extract field values from query results</li> <li><code>_update_raw(update_message)</code> - Execute a SPARQL update statement</li> </ol>"},{"location":"03_databases/3_1_databases_overview/#optional-customization","title":"Optional Customization\u00b6","text":"<p>Subclasses may optionally override:</p> <ul> <li><code>_get_namespaces()</code> - Return list of namespaces for enumeration parsing (e.g., Blazegraph supports multiple namespaces)</li> </ul>"},{"location":"03_databases/3_1_databases_overview/#common-sparql-endpoint-methods","title":"Common SPARQL Endpoint Methods\u00b6","text":"<p>Note: This section documents the methods shared by all SPARQL-based database backends (Blazegraph, GraphDB, RDFlib). Individual database documentation will reference this section rather than duplicating the content.</p> <p>The following methods are implemented in <code>SPARQLEndpointConnection</code> and available to all SPARQL databases.</p>"},{"location":"03_databases/3_1_databases_overview/#connection-management","title":"Connection Management\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#connect","title":"connect()\u00b6","text":"<p>Establishes a connection to the SPARQL endpoint.</p> <p>Parameters: None</p> <p>Returns: None</p> <p>Behavior:</p> <ul> <li>Checks if <code>connection_obj</code> is already initialized</li> <li>If not, calls <code>_setup_connection()</code> to create database-specific connection</li> <li>Called automatically by query methods if connection not established</li> </ul> <p>Usage:</p> <pre>from cimgraph.databases import BlazegraphConnection\ndb = BlazegraphConnection()\ndb.connect()  # Usually called automatically\n</pre> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:118</code></p>"},{"location":"03_databases/3_1_databases_overview/#disconnect","title":"disconnect()\u00b6","text":"<p>Disconnects from the SPARQL endpoint by releasing the connection object.</p> <p>Parameters: None</p> <p>Returns: None</p> <p>Behavior:</p> <ul> <li>Sets <code>connection_obj</code> to <code>None</code></li> <li>Releases database connection resources</li> </ul> <p>Usage:</p> <pre>db.disconnect()\n</pre> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:123</code></p>"},{"location":"03_databases/3_1_databases_overview/#query-execution","title":"Query Execution\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#executequery_message","title":"execute(query_message)\u00b6","text":"<p>Executes a SPARQL SELECT query on the endpoint.</p> <p>Parameters:</p> <ul> <li><code>query_message</code> (str): The SPARQL query string to execute</li> </ul> <p>Returns:</p> <ul> <li><code>QueryResponse</code>: Dictionary containing query results in SPARQL JSON format</li> </ul> <p>Behavior:</p> <ul> <li>Ensures connection is established via <code>connect()</code></li> <li>Delegates to database-specific <code>_execute_raw_query()</code></li> <li>Returns results in standard SPARQL JSON format</li> </ul> <p>Usage:</p> <pre>query = \"SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 10\"\nresults = db.execute(query)\n</pre> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:131</code></p>"},{"location":"03_databases/3_1_databases_overview/#updateupdate_message","title":"update(update_message)\u00b6","text":"<p>Executes a SPARQL UPDATE statement (INSERT, DELETE, etc.).</p> <p>Parameters:</p> <ul> <li><code>update_message</code> (str): The SPARQL update statement to execute</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: Response message from the database</li> </ul> <p>Behavior:</p> <ul> <li>Ensures connection is established via <code>connect()</code></li> <li>Delegates to database-specific <code>_update_raw()</code></li> <li>Used internally by <code>upload()</code> method</li> </ul> <p>Usage:</p> <pre>update = \"DELETE { ?s ?p ?o } WHERE { ?s ?p ?o }\"\nresponse = db.update(update)\n</pre> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:145</code></p>"},{"location":"03_databases/3_1_databases_overview/#object-retrieval","title":"Object Retrieval\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#get_objectmrid-graphnone","title":"get_object(mRID, graph=None)\u00b6","text":"<p>Retrieves a single CIM object from the database by its mRID.</p> <p>Parameters:</p> <ul> <li><code>mRID</code> (str): The master resource identifier (UUID) of the object</li> <li><code>graph</code> (dict): Optional existing graph (creates new if <code>None</code>)</li> </ul> <p>Returns:</p> <ul> <li><code>object</code>: The retrieved CIM object, or <code>None</code> if not found</li> </ul> <p>Behavior:</p> <ul> <li>Generates SPARQL query using <code>sparql.get_object_sparql(mRID)</code></li> <li>Executes query and parses results</li> <li>Creates object instance and adds to graph</li> <li>Validates object class against loaded CIM profile</li> </ul> <p>Usage:</p> <pre>breaker = db.get_object(mRID='4c04f838-62aa-475e-aefa-a63b7c889c13')\nprint(breaker)\n</pre> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:163</code></p>"},{"location":"03_databases/3_1_databases_overview/#get_from_triplesubject-predicate-graphnone","title":"get_from_triple(subject, predicate, graph=None)\u00b6","text":"<p>Retrieves the values of a specific attribute for a CIM object.</p> <p>Parameters:</p> <ul> <li><code>subject</code> (object): The CIM object instance to query</li> <li><code>predicate</code> (str): The attribute name (e.g., <code>'name'</code>, <code>'Terminals'</code>)</li> <li><code>graph</code> (Graph): Optional existing graph</li> </ul> <p>Returns:</p> <ul> <li><code>list[str] | list[object]</code>: List of values (strings for primitives, objects for associations)</li> </ul> <p>Behavior:</p> <ul> <li>Adds subject to graph if not already present</li> <li>Generates SPARQL query using <code>sparql.get_triple_sparql(subject, predicate)</code></li> <li>Parses results using <code>edge_query_parser()</code></li> <li>Returns both primitive values and associated objects</li> </ul> <p>Usage:</p> <pre>breaker = network.first(cim.Breaker)\nterminals = db.get_from_triple(breaker, 'Terminals')\nname = db.get_from_triple(breaker, 'name')\n</pre> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:196</code></p>"},{"location":"03_databases/3_1_databases_overview/#graph-creation","title":"Graph Creation\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#create_new_graphcontainer-graphnone","title":"create_new_graph(container, graph=None)\u00b6","text":"<p>Creates the base typed property graph for a CIM EquipmentContainer.</p> <p>Parameters:</p> <ul> <li><code>container</code> (object): The CIM container object (typically <code>Feeder</code> or <code>Substation</code>)</li> <li><code>graph</code> (dict): Optional existing graph (creates new if <code>None</code>)</li> </ul> <p>Returns:</p> <ul> <li><code>Graph</code>: The populated typed property graph with Equipment, ConnectivityNodes, and Terminals</li> </ul> <p>Behavior:</p> <ul> <li>Adds container to graph</li> <li>Generates SPARQL query using <code>sparql.get_all_nodes_from_container(container)</code></li> <li>Query retrieves all Equipment, Terminals, ConnectivityNodes, and optionally Measurements</li> <li>Creates base topology without detailed attributes (UUIDs only)</li> <li>Parses results using <code>parse_node_query()</code></li> </ul> <p>Usage:</p> <pre>feeder = cim.Feeder(mRID='49AD8E07-3BF9-A4E2-CB8F-C3722F837B62')\ngraph = db.create_new_graph(container=feeder)\n</pre> <p>Note: This method is typically called internally by <code>FeederModel</code> or <code>GraphModel</code> subclasses.</p> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:220</code></p>"},{"location":"03_databases/3_1_databases_overview/#create_distributed_grapharea-graphnone","title":"create_distributed_graph(area, graph=None)\u00b6","text":"<p>Creates a distributed graph for a SubSchedulingArea.</p> <p>Parameters:</p> <ul> <li><code>area</code> (object): The <code>SubSchedulingArea</code> object defining the distributed region</li> <li><code>graph</code> (dict): Optional existing graph</li> </ul> <p>Returns:</p> <ul> <li><code>Graph</code>: The populated graph for the distributed area</li> </ul> <p>Behavior:</p> <ul> <li>Validates that <code>area</code> is a <code>SubSchedulingArea</code> instance</li> <li>Adds area to graph</li> <li>Generates SPARQL query using <code>sparql.get_all_nodes_from_area(area)</code></li> <li>Retrieves all equipment within the scheduling area</li> <li>Parses results using <code>parse_node_query()</code></li> </ul> <p>Usage:</p> <pre>area = cim.SubSchedulingArea(mRID='area-uuid')\ngraph = db.create_distributed_graph(area=area)\n</pre> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:244</code></p>"},{"location":"03_databases/3_1_databases_overview/#build_graph_from_listgraph-mrid_list","title":"build_graph_from_list(graph, mrid_list)\u00b6","text":"<p>Builds a graph from an explicit list of equipment mRIDs.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (Graph): Existing graph structure to populate</li> <li><code>mrid_list</code> (list[str]): List of mRIDs for equipment to include</li> </ul> <p>Returns:</p> <ul> <li><code>Graph</code>: Updated graph with specified equipment</li> </ul> <p>Behavior:</p> <ul> <li>Processes mRIDs in batches of 100 for performance</li> <li>Generates SPARQL query using <code>sparql.get_all_nodes_from_list(eq_mrids, namespace)</code></li> <li>Retrieves Equipment, Terminals, and ConnectivityNodes for specified mRIDs</li> <li>Parses results using <code>parse_node_query()</code></li> </ul> <p>Usage:</p> <pre>equipment_list = ['mrid-1', 'mrid-2', 'mrid-3']\ngraph = db.build_graph_from_list(graph, equipment_list)\n</pre> <p>Note: Originally designed for GridAPPS-D Topology Processor integration.</p> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:268</code></p>"},{"location":"03_databases/3_1_databases_overview/#graph-expansion","title":"Graph Expansion\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#get_all_edgesgraph-cim_class","title":"get_all_edges(graph, cim_class)\u00b6","text":"<p>Expands the knowledge graph by retrieving all attributes and associations for a CIM class.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (Graph): The typed property graph containing objects to expand</li> <li><code>cim_class</code> (type): The CIM class type to expand (e.g., <code>cim.Breaker</code>)</li> </ul> <p>Returns: None (modifies graph in-place)</p> <p>Behavior:</p> <ul> <li>Retrieves all instances of <code>cim_class</code> from graph</li> <li>Processes in parallel batches of 100 UUIDs</li> <li>For each batch:<ul> <li>Generates SPARQL query using <code>sparql.get_all_edges_sparql(graph, cim_class, eq_mrids)</code></li> <li>Executes query and parses results with <code>edge_query_parser()</code></li> <li>Creates new objects for associated classes and adds to graph</li> </ul> </li> <li>Uses <code>ThreadPoolExecutor</code> with <code>os.cpu_count()</code> workers for parallel execution</li> </ul> <p>Usage:</p> <pre># Expand all breakers in the graph\nnetwork.get_all_edges(cim.Breaker)\n\n# Now breakers have all attributes populated\nbreaker = network.first(cim.Breaker)\nprint(breaker.name, breaker.ratedCurrent)\n</pre> <p>Performance: For 1000 objects, expect ~5-10 queries with parallel execution.</p> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:444</code></p>"},{"location":"03_databases/3_1_databases_overview/#get_all_attributesgraph-cim_class","title":"get_all_attributes(graph, cim_class)\u00b6","text":"<p>Retrieves all attributes for a CIM class without expanding associations.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (Graph): The typed property graph containing objects</li> <li><code>cim_class</code> (type): The CIM class type to query</li> </ul> <p>Returns: None (modifies graph in-place)</p> <p>Behavior:</p> <ul> <li>Similar to <code>get_all_edges()</code> but with <code>expand_graph=False</code></li> <li>Retrieves primitive attributes (name, voltage, etc.)</li> <li>Associations stored as string URIs instead of creating new objects</li> <li>Processes in batches of 100 for performance</li> <li>Uses <code>sparql.get_all_attributes_sparql()</code> for query generation</li> </ul> <p>Usage:</p> <pre># Get attributes without expanding edges\nnetwork.get_all_attributes(cim.ACLineSegment)\n\n# Lines now have name, length, etc. but associated objects are strings\nline = network.first(cim.ACLineSegment)\nprint(line.name, line.length)\n</pre> <p>Use Case: Useful when you need object properties but don't want to expand the entire graph.</p> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:471</code></p>"},{"location":"03_databases/3_1_databases_overview/#get_edges_querygraph-cim_class","title":"get_edges_query(graph, cim_class)\u00b6","text":"<p>Generates the SPARQL query string for edge retrieval (debugging utility).</p> <p>Parameters:</p> <ul> <li><code>graph</code> (Graph): The typed property graph</li> <li><code>cim_class</code> (type): The CIM class type</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: The SPARQL query string</li> </ul> <p>Behavior:</p> <ul> <li>Generates query for first 100 objects of <code>cim_class</code></li> <li>Returns query string without executing</li> <li>Useful for debugging and understanding query structure</li> </ul> <p>Usage:</p> <pre>query = db.get_edges_query(network.graph, cim.Breaker)\nprint(query)\n</pre> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:427</code></p>"},{"location":"03_databases/3_1_databases_overview/#query-parsing","title":"Query Parsing\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#parse_node_querygraph-query_output","title":"parse_node_query(graph, query_output)\u00b6","text":"<p>Parses SPARQL query results to build the base network topology.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (dict): Graph structure to update</li> <li><code>query_output</code> (dict): SPARQL JSON results from node query</li> </ul> <p>Returns:</p> <ul> <li><code>Graph</code>: Updated graph with parsed nodes</li> </ul> <p>Behavior:</p> <ul> <li>Iterates through query result bindings</li> <li>Parses JSON-LD strings for Equipment and Measurements</li> <li>Extracts <code>@id</code> and <code>@type</code> from JSON-LD</li> <li>Creates Equipment, Terminal, and ConnectivityNode objects</li> <li>Establishes bidirectional associations:<ul> <li>Equipment \u2194 Terminal</li> <li>ConnectivityNode \u2194 Terminal</li> </ul> </li> <li>Optionally parses Measurement associations</li> <li>Validates classes against CIM profile</li> </ul> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:294</code></p>"},{"location":"03_databases/3_1_databases_overview/#edge_query_parserquery_output-graph-cim_class-expand_graphtrue","title":"edge_query_parser(query_output, graph, cim_class, expand_graph=True)\u00b6","text":"<p>Parses SPARQL edge query results to populate object attributes and associations.</p> <p>Parameters:</p> <ul> <li><code>query_output</code> (QueryResponse): SPARQL JSON results from edge query</li> <li><code>graph</code> (Graph): Graph structure to update</li> <li><code>cim_class</code> (type): The CIM class being expanded</li> <li><code>expand_graph</code> (bool): Whether to create new objects for associations (default: <code>True</code>)</li> </ul> <p>Returns:</p> <ul> <li><code>list[object]</code>: List of newly created edges/values</li> </ul> <p>Behavior:</p> <ul> <li>Iterates through query result bindings</li> <li>For each result:<ol> <li>Check for association (edge): If JSON-LD edge present:<ul> <li>Parses edge class and mRID</li> <li>If <code>expand_graph=True</code>: creates new object via <code>create_edge()</code></li> <li>If <code>expand_graph=False</code>: stores as string via <code>create_value()</code></li> </ul> </li> <li>Check for enumeration: If value contains namespace URI:<ul> <li>Extracts enum class and value (e.g., <code>PhaseCode.ABC</code>)</li> <li>Creates enum instance and sets on object</li> </ul> </li> <li>Handle primitive value: Otherwise:<ul> <li>Calls <code>create_value()</code> for type conversion</li> <li>Sets primitive attribute (string, int, float, bool)</li> </ul> </li> </ol> </li> <li>Returns list of all created edges for reference</li> </ul> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:350</code></p>"},{"location":"03_databases/3_1_databases_overview/#data-upload","title":"Data Upload\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#uploadgraph","title":"upload(graph)\u00b6","text":"<p>Uploads a typed property graph to the database.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (Graph): The typed property graph to upload</li> </ul> <p>Returns: None</p> <p>Behavior:</p> <ul> <li>Iterates through all classes in graph</li> <li>For each object:<ul> <li>Generates SPARQL INSERT triples using <code>sparql.upload_triples_sparql(obj)</code></li> <li>Executes update via <code>update()</code> method</li> </ul> </li> <li>Uploads all object attributes and associations as RDF triples</li> <li>Preserves object types, UUIDs, and relationships</li> </ul> <p>Usage:</p> <pre># Modify graph\nbreaker = network.first(cim.Breaker)\nbreaker.name = 'Modified Breaker'\n\n# Upload changes\ndb.upload(network.graph)\n</pre> <p>Performance: Large graphs may take significant time to upload.</p> <p>Source: <code>cimgraph/databases/sparql_endpoint.py:493</code></p>"},{"location":"03_databases/3_1_databases_overview/#common-sparql-query-generation","title":"Common SPARQL Query Generation\u00b6","text":"<p>All SPARQL endpoints share a common query generation module (<code>cimgraph.queries.sparql</code>) that provides:</p> <ul> <li><code>get_object_sparql(mRID)</code> - Query for single object by mRID</li> <li><code>get_triple_sparql(subject, predicate)</code> - Query for specific triple</li> <li><code>get_all_nodes_from_container(container)</code> - Query for all topology nodes in a container</li> <li><code>get_all_nodes_from_area(area)</code> - Query for distributed graph nodes</li> <li><code>get_all_nodes_from_list(mrid_list, namespace)</code> - Query for specific equipment list</li> <li><code>get_all_edges_sparql(graph, cim_class, eq_mrids)</code> - Query for object edges and attributes</li> <li><code>get_all_attributes_sparql(graph, cim_class, eq_mrids)</code> - Query for attributes only</li> <li><code>upload_triples_sparql(obj)</code> - Generate INSERT statement for object</li> </ul> <p>These query generators ensure consistent SPARQL syntax across all database backends.</p>"},{"location":"03_databases/3_1_databases_overview/#uml-sequence-diagrams","title":"UML Sequence Diagrams\u00b6","text":"<p>The following diagrams illustrate the interaction patterns for common operations across SPARQL endpoints.</p>"},{"location":"03_databases/3_1_databases_overview/#creating-a-new-graph-from-database","title":"Creating a New Graph from Database\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#expanding-graph-with-get_all_edges","title":"Expanding Graph with get_all_edges()\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#database-comparison","title":"Database Comparison\u00b6","text":"<p>The following table compares key characteristics of each database backend:</p> Feature XMLFile Blazegraph GraphDB RDFlib Neo4j Query Language XPath SPARQL SPARQL SPARQL Cypher Storage Type File Triple Store Triple Store Triple Store Property Graph Installation None Java Java/Docker Python Java/Docker Best For Small models Large models Enterprise Testing Graph algorithms Performance Slow (2 min for 8500 nodes) Fast Fast Medium Fast Memory Usage High Medium Medium High Medium Reasoning No No Yes Yes No ACID No Yes Yes Yes Yes Distributed No Yes Yes No Yes Web Interface No Yes Yes No Yes License Open Source Apache 2.0 Commercial/Free BSD Commercial/Community"},{"location":"03_databases/3_1_databases_overview/#recommended-use-cases","title":"Recommended Use Cases\u00b6","text":"<ul> <li>XMLFile: Quick testing with IEEE 13/123-bus models, no database setup</li> <li>Blazegraph: Production use with distribution models up to 10,000 nodes</li> <li>GraphDB: Enterprise deployments requiring reasoning and data governance</li> <li>RDFlib: Python-native applications, testing, temporary storage</li> <li>Neo4j: Advanced graph analytics, path finding, community detection</li> </ul>"},{"location":"03_databases/3_1_databases_overview/#environment-variables","title":"Environment Variables\u00b6","text":"<p>All database connections use environment variables for configuration. See Environment Variables for complete documentation.</p>"},{"location":"03_databases/3_1_databases_overview/#common-variables","title":"Common Variables\u00b6","text":"<pre>import os\n\n# CIM profile selection (required)\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\n\n# CIM namespace (optional, auto-detected from profile)\nos.environ['CIMG_NAMESPACE'] = 'http://cim.ucaiug.io/CIM101/draft#'\n\n# IEC 61970-301 version (optional, default: 7)\nos.environ['CIMG_IEC61970_301'] = '8'\n\n# Validation log level (optional, default: WARNING)\nos.environ['CIMG_VALIDATION_LOG_LEVEL'] = 'INFO'\n</pre>"},{"location":"03_databases/3_1_databases_overview/#database-specific-variables","title":"Database-Specific Variables\u00b6","text":"<p>SPARQL Endpoints (Blazegraph, GraphDB):</p> <pre>os.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql'\n</pre> <p>Neo4j:</p> <pre>os.environ['CIMG_HOST'] = 'localhost'\nos.environ['CIMG_PORT'] = '7687'\nos.environ['CIMG_DATABASE'] = 'neo4j'\nos.environ['CIMG_USERNAME'] = 'neo4j'\nos.environ['CIMG_PASSWORD'] = 'password'\n</pre> <p>MySQL:</p> <pre>os.environ['CIMG_HOST'] = 'localhost'\nos.environ['CIMG_PORT'] = '3306'\nos.environ['CIMG_DATABASE'] = 'cim_models'\nos.environ['CIMG_USERNAME'] = 'root'\nos.environ['CIMG_PASSWORD'] = 'password'\n</pre>"},{"location":"03_databases/3_1_databases_overview/#quick-start-examples","title":"Quick Start Examples\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#example-1-xml-file-no-database","title":"Example 1: XML File (No Database)\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#example-2-blazegraph-sparql-endpoint","title":"Example 2: Blazegraph (SPARQL Endpoint)\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#example-3-switching-databases","title":"Example 3: Switching Databases\u00b6","text":""},{"location":"03_databases/3_1_databases_overview/#additional-documentation","title":"Additional Documentation\u00b6","text":"<p>For detailed information on each database backend:</p> <ul> <li>Environment Variables Configuration</li> <li>Blazegraph Database</li> <li>Neo4j Database</li> <li>GraphDB Database</li> <li>MySQL Database</li> <li>GridAPPS-D Integration</li> <li>XML File Parser</li> <li>JSON-LD File Parser</li> <li>RDFlib Parser</li> </ul> <p>For usage examples:</p> <ul> <li>FeederModel Usage</li> <li>GraphModel API</li> </ul>"},{"location":"03_databases/3_2_env_variables/","title":"Environment Variables","text":"<p>IMPORTANT: As of v0.3+, the ConnectionParameters class has been deprecated. Use the environment variables below to authenticate with the database.</p> <p>The CIM-Graph library supports multiple databases. The environment variables specify how to read the CIM model:</p> <p>Required environment variables:</p> <ul> <li><code>CIMG_CIM_PROFILE</code>: CIM profile module name</li> </ul> <p>Optional environment variables:</p> <p>If these values are not specified, they will default to the sample values listed in example.env</p> <ul> <li><p><code>CIMG_NAMESPACE</code>: CIM namespace, default is <code>\"http://iec.ch/TC57/CIM100#\"</code></p> </li> <li><p><code>CIMG_IEC61970_301</code>: Serialization version. Versions 7(default) and below use <code>rdf:ID=</code>. Version 8 uses <code>rdf:about=urn:uuid:</code></p> </li> <li><p><code>CIMG_URL</code>: URL at which the database can be reached via TCP/IP or other connection</p> </li> <li><p><code>CIMG_HOST</code>: Database host address</p> </li> <li><p><code>CIMG_PORT</code>: Database host port</p> </li> <li><p><code>CIMG_DATABASE</code>: Database name</p> </li> <li><p><code>CIMG_USERNAME</code>: Database username</p> </li> <li><p><code>CIMG_PASSWORD</code>: Database password</p> </li> </ul> <p>Note that not all parameters are required. Each database connection uses a subset of these arguments depending on the requirements of the database connection driver.</p> In\u00a0[1]: Copied! <pre>import os\n# Set environment variable\nos.environ['CIMG_CIM_PROFILE'] = 'cim17v40'\n</pre> import os # Set environment variable os.environ['CIMG_CIM_PROFILE'] = 'cim17v40' In\u00a0[2]: Copied! <pre>from cimgraph.databases import get_cim_profile\n# Retrieve value of env var and library module path\ncim_profile, cim = get_cim_profile()\n</pre> from cimgraph.databases import get_cim_profile # Retrieve value of env var and library module path cim_profile, cim = get_cim_profile() In\u00a0[3]: Copied! <pre># Set environment variable\nos.environ['CIMG_CIM_PROFILE'] = 'cimgraph.data_profile.rc4_2021'\n# Retrieve value of env var and library module path\ncim_profile, cim = get_cim_profile()\n</pre> # Set environment variable os.environ['CIMG_CIM_PROFILE'] = 'cimgraph.data_profile.rc4_2021' # Retrieve value of env var and library module path cim_profile, cim = get_cim_profile() In\u00a0[4]: Copied! <pre>from cimgraph.databases import get_namespace\ndefault_namespace = get_namespace()\nprint(default_namespace)\n</pre> from cimgraph.databases import get_namespace default_namespace = get_namespace() print(default_namespace) <pre>http://iec.ch/TC57/CIM100#\n</pre> In\u00a0[9]: Copied! <pre># Set the new namespace\nos.environ['CIMG_NAMESPACE'] = \"http://iec.ch/TC57/2011/CIM-schema-cim15#\"\n# Clear cached namespace\nget_namespace.cache_clear()\n# Retrieve the new namespace\nnamespace = get_namespace()\nprint(namespace)\n</pre> # Set the new namespace os.environ['CIMG_NAMESPACE'] = \"http://iec.ch/TC57/2011/CIM-schema-cim15#\" # Clear cached namespace get_namespace.cache_clear() # Retrieve the new namespace namespace = get_namespace() print(namespace) <pre>http://iec.ch/TC57/2011/CIM-schema-cim15#\n</pre> <p>If your model file contains underscores, use</p> <pre>os.environ['CIMG_IEC61970_301'] = '7'\n</pre> <p>If your model does not contain underscores, use</p> <pre>os.environ['CIMG_IEC61970_301'] = '8'\n</pre> In\u00a0[10]: Copied! <pre>from cimgraph.databases import get_iec61970_301\nversion = get_iec61970_301()\nprint(version)\n</pre> from cimgraph.databases import get_iec61970_301 version = get_iec61970_301() print(version) <pre>8\n</pre> In\u00a0[11]: Copied! <pre># Set the new namespace\nos.environ['CIMG_IEC61970_301'] = '7'\n# Clear cached namespace\nget_iec61970_301.cache_clear()\n# Retrieve the new namespace\nnamespace = get_iec61970_301()\nprint(namespace)\n</pre> # Set the new namespace os.environ['CIMG_IEC61970_301'] = '7' # Clear cached namespace get_iec61970_301.cache_clear() # Retrieve the new namespace namespace = get_iec61970_301() print(namespace) <pre>7\n</pre> <p>Older versions of CIM-graph (0.1.x and 0.2.x) used the ConnectionParameters class to specify the variables needed to connect to the database</p> <p>The first step in using any of CIMantic Graphs functionalities is to define the connection parameters, which specify the CIM Profile, serialization format, and database to be used. The <code>ConnectionParameters</code> class is used to specify these inputs with the following required and optional arguments:</p>"},{"location":"03_databases/3_2_env_variables/#environment-variables","title":"Environment Variables\u00b6","text":""},{"location":"03_databases/3_2_env_variables/#cimg_cim_profile","title":"CIMG_CIM_PROFILE\u00b6","text":"<p>This specifies the specific version of CIM to be used, based on the available python data profiles loaded into the library.</p> <p>The value used should match the name CIM profile classes module imported using <code>import cimgraph.data_profile.profile_name as cim</code>.</p> <p>The environment variable should be specified as a string and can use shorthand for the profile name or the full library path. A full path to separate library can also be used.</p> <p>The value can be retrieved using the <code>get_cim_profile()</code> method from the CIM-Graph databases module.</p>"},{"location":"03_databases/3_2_env_variables/#example-1","title":"Example 1\u00b6","text":"<p>The example below shows how to set and retrieve the CIM profile using the short name of the profile</p>"},{"location":"03_databases/3_2_env_variables/#example-2","title":"Example 2\u00b6","text":"<p>The example below shows how to set and retrieve the CIM profile using the full path of the profile</p>"},{"location":"03_databases/3_2_env_variables/#cimg_namespace","title":"CIMG_NAMESPACE\u00b6","text":"<p>This environment variable sets the namespace tied to the <code>cim:</code> prefix.</p> <p>Each version of the CIM uses a specific namespace, which can typically be found in the first line of the XML file, such as</p> <p><code>xmlns:cim=\"http://iec.ch/TC57/2011/CIM-schema-cim15#\"</code></p> <p>The default used by CIMantic Graphs is the CIM100 namespace <code>\"http://iec.ch/TC57/CIM100#\"</code> used by CIM 17.</p> <p>The value can be retrieved from the <code>.get_namespace()</code> method in the databases module.</p>"},{"location":"03_databases/3_2_env_variables/#example-1","title":"Example 1\u00b6","text":"<p>The code snippet below shows how to retrieve the default namespace</p>"},{"location":"03_databases/3_2_env_variables/#example-2","title":"Example 2\u00b6","text":"<p>To set a custom namespace, set the environment variable to the full namespace URL:</p>"},{"location":"03_databases/3_2_env_variables/#cimg_iec61960_301","title":"CIMG_IEC61960_301\u00b6","text":"<p>This environment variable tracks the serialization format and use of underscores as part of the rdf identifier of each object. The default value in CIM-Graph 0.3+ is <code>8</code> (no underscores).</p> <p>Versions 7.0 and older of the IEC 61970-301 standard use the serialization format based on <code>rdf:ID</code> and a leading underscore:</p> <pre>&lt;cim:ClassName rdf:ID=\"_ABEB635F-729D-24BF-B8A4-E2EF268D8B9E\"&gt;\n  &lt;cim:ClsName.Association rdf:resource=\"#_73C512BD-7249-4F50-50DA-D93849B89C43\"/&gt;\n&lt;/cim:ClassName&gt;\n</pre> <p>Version 8.0 of the standard has changed the serialization format to specify that the serialization identifier must be a UUID, with no underscore:</p> <pre>&lt;cim:ClassName rdf:about=\"urn:uuid:abeb635f-729d-24bf-b8a4-e2ef268d8b9e\"&gt;\n  &lt;cim:ClassName.Association rdf:resource=\"urn:uuid:73c512bd-7249-4f50-50da-d93849b89c43\"/&gt;\n&lt;/cim:ClassName&gt;\n</pre>"},{"location":"03_databases/3_2_env_variables/#example-1","title":"Example 1\u00b6","text":"<p>The code snippet below shows how to retrieve the default serialization version.</p>"},{"location":"03_databases/3_2_env_variables/#example-2","title":"Example 2\u00b6","text":"<p>The code snippet below shows how to change to serialization environment variable to indicate that the mRIDs have underscores:</p>"},{"location":"03_databases/3_2_env_variables/#connection-parameters-deprecated","title":"Connection Parameters (Deprecated)\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/","title":"Blazegraph","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'rc4_2021'\nos.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql'\nos.environ['CIMG_IEC61970_301'] = '7'\n\nimport cimgraph.data_profile.rc4_2021 as cim\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'rc4_2021' os.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql' os.environ['CIMG_IEC61970_301'] = '7'  import cimgraph.data_profile.rc4_2021 as cim In\u00a0[\u00a0]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nos.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql'\nos.environ['CIMG_IEC61970_301'] = '8'\n\nimport cimgraph.data_profile.cimhub_2023 as cim\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' os.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql' os.environ['CIMG_IEC61970_301'] = '8'  import cimgraph.data_profile.cimhub_2023 as cim In\u00a0[\u00a0]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nos.environ['CIMG_URL'] = 'http://localhost:9999/blazegraph/sparql'\nos.environ['CIMG_IEC61970_301'] = '8'\n\nimport cimgraph.data_profile.cimhub_2023 as cim\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' os.environ['CIMG_URL'] = 'http://localhost:9999/blazegraph/sparql' os.environ['CIMG_IEC61970_301'] = '8'  import cimgraph.data_profile.cimhub_2023 as cim In\u00a0[\u00a0]: Copied! <pre>from cimgraph.databases import BlazegraphConnection\n\n# Create connection (automatically connects to database)\ndb = BlazegraphConnection()\n</pre> from cimgraph.databases import BlazegraphConnection  # Create connection (automatically connects to database) db = BlazegraphConnection() <p>The connection is established automatically when the object is instantiated. It retrieves the SPARQL endpoint URL from the <code>CIMG_URL</code> environment variable.</p> In\u00a0[\u00a0]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nos.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql'\nimport cimgraph.data_profile.cimhub_2023 as cim\n\nfrom cimgraph.databases import BlazegraphConnection\nfrom cimgraph.models import FeederModel\n\n# Connect to Blazegraph\ndb = BlazegraphConnection()\n\n# Load IEEE 13-bus feeder\nfeeder = cim.Feeder(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\")\nnetwork = FeederModel(container=feeder, connection=db)\n\nprint(f\"Loaded {len(network.graph[cim.ACLineSegment])} line segments\")\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' os.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql' import cimgraph.data_profile.cimhub_2023 as cim  from cimgraph.databases import BlazegraphConnection from cimgraph.models import FeederModel  # Connect to Blazegraph db = BlazegraphConnection()  # Load IEEE 13-bus feeder feeder = cim.Feeder(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\") network = FeederModel(container=feeder, connection=db)  print(f\"Loaded {len(network.graph[cim.ACLineSegment])} line segments\") In\u00a0[\u00a0]: Copied! <pre># Retrieve a feeder object directly from database\nfeeder = db.get_object(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\")\nfeeder.pprint()\n</pre> # Retrieve a feeder object directly from database feeder = db.get_object(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\") feeder.pprint() <p>Output:</p> <pre>{\n    \"@id\": \"49ad8e07-3bf9-a4e2-cb8f-c3722f837b62\",\n    \"@type\": \"Feeder\"\n}\n</pre> In\u00a0[\u00a0]: Copied! <pre># Get feeder name (string attribute)\nname = db.get_from_triple(subject=feeder, predicate='IdentifiedObject.name')\nprint(f\"Feeder name: {name}\")\n\n# Get associated substation (object reference)\nsubstation = db.get_from_triple(subject=feeder, predicate='Feeder.NormalEnergizingSubstation')\nprint(f\"Substation: {substation}\")\n</pre> # Get feeder name (string attribute) name = db.get_from_triple(subject=feeder, predicate='IdentifiedObject.name') print(f\"Feeder name: {name}\")  # Get associated substation (object reference) substation = db.get_from_triple(subject=feeder, predicate='Feeder.NormalEnergizingSubstation') print(f\"Substation: {substation}\") In\u00a0[\u00a0]: Copied! <pre># Custom SPARQL query to find all feeders\nquery_text = '''\nPREFIX r:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\nPREFIX cim:  &lt;http://iec.ch/TC57/CIM100#&gt;\nSELECT DISTINCT ?identifier ?name\nWHERE {\n    ?feeder r:type cim:Feeder .\n    BIND(strafter(str(?feeder),\"urn:uuid:\") as ?identifier)\n    OPTIONAL { ?feeder cim:IdentifiedObject.name ?name . }\n}\nORDER BY ?name\n'''\n\nresults = db.execute(query_text)\n\n# Parse results\nprint(\"Available Feeders:\")\nfor result in results['results']['bindings']:\n    mrid = result['identifier']['value']\n    name = result.get('name', {}).get('value', 'Unnamed')\n    print(f\"  - {name}: {mrid}\")\n</pre> # Custom SPARQL query to find all feeders query_text = ''' PREFIX r:   PREFIX cim:   SELECT DISTINCT ?identifier ?name WHERE {     ?feeder r:type cim:Feeder .     BIND(strafter(str(?feeder),\"urn:uuid:\") as ?identifier)     OPTIONAL { ?feeder cim:IdentifiedObject.name ?name . } } ORDER BY ?name '''  results = db.execute(query_text)  # Parse results print(\"Available Feeders:\") for result in results['results']['bindings']:     mrid = result['identifier']['value']     name = result.get('name', {}).get('value', 'Unnamed')     print(f\"  - {name}: {mrid}\") In\u00a0[\u00a0]: Copied! <pre># Load base topology\nfeeder = cim.Feeder(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\")\nnetwork = FeederModel(container=feeder, connection=db)\n\n# Expand breakers with all attributes\nnetwork.get_all_edges(cim.Breaker)\n\n# Expand line segments\nnetwork.get_all_edges(cim.ACLineSegment)\n\n# Now all breakers and lines have complete information\nbreaker = network.first(cim.Breaker)\nprint(f\"Breaker: {breaker.name}\")\nprint(f\"Rated Current: {breaker.ratedCurrent}\")\n</pre> # Load base topology feeder = cim.Feeder(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\") network = FeederModel(container=feeder, connection=db)  # Expand breakers with all attributes network.get_all_edges(cim.Breaker)  # Expand line segments network.get_all_edges(cim.ACLineSegment)  # Now all breakers and lines have complete information breaker = network.first(cim.Breaker) print(f\"Breaker: {breaker.name}\") print(f\"Rated Current: {breaker.ratedCurrent}\") In\u00a0[\u00a0]: Copied! <pre># Get the SPARQL query that would be executed\nquery_text = db.get_edges_query(network.graph, cim.Breaker)\nprint(\"SPARQL Query for Breaker expansion:\")\nprint(query_text)\n\n# Copy this query to Blazegraph web interface for debugging\n</pre> # Get the SPARQL query that would be executed query_text = db.get_edges_query(network.graph, cim.Breaker) print(\"SPARQL Query for Breaker expansion:\") print(query_text)  # Copy this query to Blazegraph web interface for debugging In\u00a0[\u00a0]: Copied! <pre>from mermaid import Mermaid\n\nwith open('./images/3_3_connect.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> from mermaid import Mermaid  with open('./images/3_3_connect.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>with open('./images/3_3_get_object.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/3_3_get_object.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>with open('./images/3_3_get_from_triple.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/3_3_get_from_triple.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>with open('./images/3_3_execute.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/3_3_execute.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>with open('./images/3_3_update.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/3_3_update.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>with open('./images/3_3_create_new_graph.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/3_3_create_new_graph.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>with open('./images/3_3_create_distributed_graph.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/3_3_create_distributed_graph.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>with open('./images/3_3_get_all_edges.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/3_3_get_all_edges.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>with open('./images/3_3_get_edges_query.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/3_3_get_edges_query.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>with open('./images/3_3_parse_node_query.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/3_3_parse_node_query.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>with open('./images/3_3_parse_edges_query.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/3_3_parse_edges_query.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[\u00a0]: Copied! <pre>from cimgraph.databases import XMLFile, BlazegraphConnection\nfrom cimgraph.models import FeederModel\n\n# Load from XML\nxml_file = XMLFile(filename='../../sample_models/ieee13.xml')\nnetwork = FeederModel(container=cim.Feeder(), connection=xml_file)\n\n# Upload to Blazegraph\ndb = BlazegraphConnection()\ndb.upload(network.graph)\n</pre> from cimgraph.databases import XMLFile, BlazegraphConnection from cimgraph.models import FeederModel  # Load from XML xml_file = XMLFile(filename='../../sample_models/ieee13.xml') network = FeederModel(container=cim.Feeder(), connection=xml_file)  # Upload to Blazegraph db = BlazegraphConnection() db.upload(network.graph)"},{"location":"03_databases/3_3_blazegraph/#blazegraph-database","title":"Blazegraph Database\u00b6","text":"<p>Blazegraph is a high-performance, open-source RDF graph database (triplestore) that supports Blueprints and RDF/SPARQL APIs. It provides excellent scalability (up to 50 billion edges on a single machine) and has been commercialized as AWS Neptune.</p> <p>CIMantic Graphs provides the <code>BlazegraphConnection</code> class for seamless integration with Blazegraph databases, making it one of the recommended backends for large-scale CIM power system models.</p>"},{"location":"03_databases/3_3_blazegraph/#overview","title":"Overview\u00b6","text":"<p>Key Features:</p> <ul> <li>High-performance SPARQL query execution</li> <li>Excellent scalability for large distribution models (IEEE 8500+ nodes)</li> <li>Fast bulk loading of RDF data</li> <li>Built-in web-based SPARQL query interface</li> <li>Support for multiple namespace enumeration parsing</li> <li>Docker images available with IEEE test feeders pre-loaded</li> </ul> <p>Best For:</p> <ul> <li>Large distribution feeder models (1000+ nodes)</li> <li>Production deployments requiring fast query performance</li> <li>Applications using GridAPPS-D platform</li> <li>Development and testing with IEEE standard test cases</li> </ul> <p>Performance:</p> <ul> <li>IEEE 8500-node model: ~10-15 seconds to load base topology</li> <li>Parallel query execution with batching</li> <li>Efficient graph traversal and expansion</li> </ul>"},{"location":"03_databases/3_3_blazegraph/#installation-and-setup","title":"Installation and Setup\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#docker-installation-recommended","title":"Docker Installation (Recommended)\u00b6","text":"<p>The easiest way to get started with Blazegraph is using Docker. GridAPPS-D provides pre-configured Docker images with IEEE test feeders already loaded.</p> <p>For CIM17 / RC4_2021 profile (GridAPPS-D v2021-v2024):</p> <pre>docker pull gridappsd/blazegraph:v2024.09.0\ndocker run -p 8889:8080 gridappsd/blazegraph:v2024.09.0\n</pre> <p>For CIM100 / CIMHub_2023 profile (GridAPPS-D v2025+):</p> <pre>docker pull gridappsd/blazegraph:v2025.01.0\ndocker run -p 8889:8080 gridappsd/blazegraph:v2025.01.0\n</pre> <p>Available tags: https://hub.docker.com/r/gridappsd/blazegraph/tags</p>"},{"location":"03_databases/3_3_blazegraph/#standalone-installation","title":"Standalone Installation\u00b6","text":"<p>For standalone installation:</p> <ol> <li>Download Blazegraph JAR from https://github.com/blazegraph/database/releases</li> <li>Start the server:<pre>java -server -Xmx4g -jar blazegraph.jar\n</pre> </li> <li>Access web interface at http://localhost:9999/blazegraph/</li> </ol>"},{"location":"03_databases/3_3_blazegraph/#python-dependencies","title":"Python Dependencies\u00b6","text":"<p>The <code>BlazegraphConnection</code> class requires the <code>SPARQLWrapper</code> library:</p> <pre>pip install SPARQLWrapper\n</pre> <p>This is installed automatically when you install CIMantic Graphs.</p>"},{"location":"03_databases/3_3_blazegraph/#environment-configuration","title":"Environment Configuration\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#for-gridapps-d-blazegraph-v2021-v2024-cim17","title":"For GridAPPS-D / Blazegraph v2021-v2024 (CIM17)\u00b6","text":"<p>If using GridAPPS-D Docker images with tags between <code>v2021.01.0</code> and <code>v2024.09.0</code>:</p>"},{"location":"03_databases/3_3_blazegraph/#for-gridapps-d-blazegraph-v2025-cim100","title":"For GridAPPS-D / Blazegraph v2025+ (CIM100)\u00b6","text":"<p>If using GridAPPS-D Docker images with tag <code>v2025.01.0</code> or later:</p>"},{"location":"03_databases/3_3_blazegraph/#for-standalone-blazegraph","title":"For Standalone Blazegraph\u00b6","text":"<p>If running standalone Blazegraph (default port 9999):</p>"},{"location":"03_databases/3_3_blazegraph/#creating-a-connection","title":"Creating a Connection\u00b6","text":"<p>Import and instantiate the <code>BlazegraphConnection</code> class:</p>"},{"location":"03_databases/3_3_blazegraph/#blazegraph-specific-features","title":"Blazegraph-Specific Features\u00b6","text":"<p>The <code>BlazegraphConnection</code> class extends <code>SPARQLEndpointConnection</code> with Blazegraph-specific implementations and features.</p>"},{"location":"03_databases/3_3_blazegraph/#constructor","title":"Constructor\u00b6","text":"<p><code>BlazegraphConnection.__init__()</code></p> <p>Creates a new Blazegraph database connection.</p> <p>Parameters: None (uses environment variables)</p> <p>Behavior:</p> <ul> <li>Calls parent <code>SPARQLEndpointConnection.__init__()</code> to initialize base attributes</li> <li>Retrieves SPARQL endpoint URL from <code>CIMG_URL</code> environment variable via <code>get_url()</code></li> <li>Configures multiple namespace support:<ul> <li>Primary namespace from CIM profile</li> <li>Additional namespace: <code>http://epri.com/gmdm/2025#</code> for EPRI GMDM enumerations</li> </ul> </li> <li>Automatically calls <code>connect()</code> to establish database connection</li> </ul> <p>Source: <code>cimgraph/databases/blazegraph/blazegraph.py:22</code></p>"},{"location":"03_databases/3_3_blazegraph/#database-specific-method-implementations","title":"Database-Specific Method Implementations\u00b6","text":"<p>Blazegraph implements the four required abstract methods from <code>SPARQLEndpointConnection</code>:</p>"},{"location":"03_databases/3_3_blazegraph/#_setup_connection","title":"_setup_connection()\u00b6","text":"<p>Initializes the SPARQLWrapper connection object for Blazegraph.</p> <p>Implementation:</p> <ul> <li>Creates <code>SPARQLWrapper</code> instance with Blazegraph SPARQL endpoint URL</li> <li>Sets return format to JSON for standardized response parsing</li> <li>Stores connection object in <code>self.connection_obj</code></li> </ul> <p>Source: <code>cimgraph/databases/blazegraph/blazegraph.py:33</code></p>"},{"location":"03_databases/3_3_blazegraph/#_execute_raw_queryquery_message","title":"_execute_raw_query(query_message)\u00b6","text":"<p>Executes a SPARQL query and returns raw JSON results.</p> <p>Parameters:</p> <ul> <li><code>query_message</code> (str): The SPARQL query to execute</li> </ul> <p>Returns:</p> <ul> <li><code>dict</code>: Query results in SPARQL JSON format</li> </ul> <p>Implementation:</p> <ul> <li>Sets query on SPARQLWrapper connection object</li> <li>Uses POST method for query submission</li> <li>Converts response to Python dictionary</li> <li>Returns standardized SPARQL JSON results</li> </ul> <p>Source: <code>cimgraph/databases/blazegraph/blazegraph.py:38</code></p>"},{"location":"03_databases/3_3_blazegraph/#_parse_result_fieldresult-field_name","title":"_parse_result_field(result, field_name)\u00b6","text":"<p>Extracts field values from SPARQLWrapper query results.</p> <p>Parameters:</p> <ul> <li><code>result</code> (dict): A single result binding from query results</li> <li><code>field_name</code> (str): The name of the field to extract</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: The field value, or <code>None</code> if field doesn't exist</li> </ul> <p>Implementation:</p> <ul> <li>SPARQLWrapper returns results as nested dictionaries: <code>result[field_name]['value']</code></li> <li>Checks if field exists in result binding</li> <li>Returns value or None</li> </ul> <p>Source: <code>cimgraph/databases/blazegraph/blazegraph.py:44</code></p>"},{"location":"03_databases/3_3_blazegraph/#_update_rawupdate_message","title":"_update_raw(update_message)\u00b6","text":"<p>Executes a SPARQL UPDATE statement.</p> <p>Parameters:</p> <ul> <li><code>update_message</code> (str): The SPARQL update to execute</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: Response from the database</li> </ul> <p>Implementation:</p> <ul> <li>Sets update query on SPARQLWrapper connection object</li> <li>Uses POST method for update submission</li> <li>Returns database response</li> </ul> <p>Source: <code>cimgraph/databases/blazegraph/blazegraph.py:50</code></p>"},{"location":"03_databases/3_3_blazegraph/#_get_namespaces","title":"_get_namespaces()\u00b6","text":"<p>Returns list of namespaces for enumeration parsing (optional override).</p> <p>Returns:</p> <ul> <li><code>list[str]</code>: List of namespace URIs</li> </ul> <p>Implementation:</p> <ul> <li>Returns <code>self.namespaces</code> list configured in <code>__init__()</code></li> <li>Includes both CIM profile namespace and EPRI GMDM namespace</li> <li>Enables parsing of enumerations from multiple namespace sources</li> </ul> <p>Source: <code>cimgraph/databases/blazegraph/blazegraph.py:56</code></p>"},{"location":"03_databases/3_3_blazegraph/#common-sparql-endpoint-methods","title":"Common SPARQL Endpoint Methods\u00b6","text":"<p>Important: <code>BlazegraphConnection</code> inherits all standard methods from <code>SPARQLEndpointConnection</code>. These methods are documented in the Databases Overview - Common SPARQL Endpoint Methods section.</p> <p>Inherited Methods:</p> <ul> <li>Connection Management: <code>connect()</code>, <code>disconnect()</code></li> <li>Query Execution: <code>execute()</code>, <code>update()</code></li> <li>Object Retrieval: <code>get_object()</code>, <code>get_from_triple()</code></li> <li>Graph Creation: <code>create_new_graph()</code>, <code>create_distributed_graph()</code>, <code>build_graph_from_list()</code></li> <li>Graph Expansion: <code>get_all_edges()</code>, <code>get_all_attributes()</code>, <code>get_edges_query()</code></li> <li>Query Parsing: <code>parse_node_query()</code>, <code>edge_query_parser()</code></li> <li>Data Upload: <code>upload()</code></li> </ul> <p>Refer to the Databases Overview for complete documentation, usage examples, and parameter details for these methods.</p>"},{"location":"03_databases/3_3_blazegraph/#usage-examples","title":"Usage Examples\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#example-1-loading-a-feeder-model","title":"Example 1: Loading a Feeder Model\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#example-2-retrieving-an-object-by-mrid","title":"Example 2: Retrieving an Object by mRID\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#example-3-querying-object-attributes","title":"Example 3: Querying Object Attributes\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#example-4-executing-custom-sparql-query","title":"Example 4: Executing Custom SPARQL Query\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#example-5-expanding-graph-with-specific-classes","title":"Example 5: Expanding Graph with Specific Classes\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#example-6-debugging-sparql-queries","title":"Example 6: Debugging SPARQL Queries\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#about-triplestore-databases","title":"About Triplestore Databases\u00b6","text":"<p>The triple-store database offers a semantic solution for data management. Unlike relational databases (which require a DDL database schema), the triple-store database structure is comprised of Resource Description Framework (RDF) statements.</p>"},{"location":"03_databases/3_3_blazegraph/#rdf-triple-structure","title":"RDF Triple Structure\u00b6","text":"<p>RDF statements take the form of subject (node) - predicate (relation) - object (node) that can be dynamically generated to form inter-related complex class structures.</p> <p>Example CIM Triple:</p> <pre><code>Subject:   ACLineSegment (urn:uuid:1234...)\nPredicate: ACLineSegment.length\nObject:    105 meters\n</code></pre>"},{"location":"03_databases/3_3_blazegraph/#advantages-for-cim","title":"Advantages for CIM\u00b6","text":"<p>The RDF statement structure intuitively corresponds to the structure of object-attribute specifications used in CIM. Key advantages include:</p> <ul> <li>Direct CIM Support: CIM models translate directly to RDF with automated data correlation</li> <li>Polymorphism: RDF Schema (RDFS) supports inheritance and class hierarchies</li> <li>Graph Constructs: Native support for complex graph structures and subgraphs</li> <li>Standards-Based: Uses mature, standardized languages (RDF, RDFS, OWL, SPARQL)</li> <li>Validation: Supports type-checking and SHACL (Shapes Constraint Language)</li> <li>Agility: Dynamic data structures support multiple developers and evolving schemas</li> </ul>"},{"location":"03_databases/3_3_blazegraph/#serialization-formats","title":"Serialization Formats\u00b6","text":"<p>RDF can be serialized in multiple formats:</p> <ul> <li>XML/RDF - IEC 61970-301 standard for CIM</li> <li>Turtle (TTL) - Human-readable format</li> <li>JSON-LD - JSON-based RDF for web applications</li> <li>N-Triples - Simple line-based format</li> </ul>"},{"location":"03_databases/3_3_blazegraph/#data-management-considerations","title":"Data Management Considerations\u00b6","text":"<p>Advantages:</p> <ul> <li>No schema migration required for model changes</li> <li>Easy integration of multiple data sources</li> <li>Standardized query language (SPARQL)</li> <li>Support for reasoning and inference (with OWL)</li> </ul> <p>Challenges:</p> <ul> <li>Risk of \"garbage-in-garbage-out\" without data governance</li> <li>Potential for dangling references without validation</li> <li>Requires rigor from data contributors</li> <li>Need for well-thought-out data management strategy</li> </ul>"},{"location":"03_databases/3_3_blazegraph/#uml-sequence-diagrams","title":"UML Sequence Diagrams\u00b6","text":"<p>This section contains UML sequence diagrams explaining how the <code>BlazegraphConnection</code> class executes database queries and API calls. The diagrams are rendered from flat text using mermaid.js.</p>"},{"location":"03_databases/3_3_blazegraph/#blazegraph-connection-initialization","title":"Blazegraph Connection Initialization\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#get_object-retrieving-object-by-mrid","title":"get_object() - Retrieving Object by mRID\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#get_from_triple-querying-object-attributes","title":"get_from_triple() - Querying Object Attributes\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#execute-executing-sparql-query","title":"execute() - Executing SPARQL Query\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#update-executing-sparql-update","title":"update() - Executing SPARQL Update\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#create_new_graph-building-feeder-topology","title":"create_new_graph() - Building Feeder Topology\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#create_distributed_graph-building-distributed-model","title":"create_distributed_graph() - Building Distributed Model\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#get_all_edges-parallel-graph-expansion","title":"get_all_edges() - Parallel Graph Expansion\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#get_edges_query-query-debugging","title":"get_edges_query() - Query Debugging\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#parse_node_query-parsing-network-topology","title":"parse_node_query() - Parsing Network Topology\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#edge_query_parser-parsing-edge-query-results","title":"edge_query_parser() - Parsing Edge Query Results\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#blazegraph-web-interface","title":"Blazegraph Web Interface\u00b6","text":"<p>Blazegraph provides a built-in web-based SPARQL query interface for interactive querying and debugging.</p> <p>Access:</p> <ul> <li>GridAPPS-D Docker: http://localhost:8889/bigdata/</li> <li>Standalone: http://localhost:9999/blazegraph/</li> </ul> <p>Features:</p> <ul> <li>SPARQL query editor with syntax highlighting</li> <li>Query execution with result display</li> <li>Namespace management</li> <li>Database statistics and monitoring</li> <li>Data loading interface (bulk load RDF files)</li> </ul> <p>Usage Tip: Copy SPARQL queries from <code>get_edges_query()</code> into the web interface to test and debug query performance.</p>"},{"location":"03_databases/3_3_blazegraph/#performance-optimization","title":"Performance Optimization\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#memory-configuration","title":"Memory Configuration\u00b6","text":"<p>For large models, increase JVM heap size:</p> <pre>java -server -Xmx8g -jar blazegraph.jar\n</pre>"},{"location":"03_databases/3_3_blazegraph/#query-batching","title":"Query Batching\u00b6","text":"<p>CIMantic Graphs automatically batches queries in groups of 100 objects. This is optimized for Blazegraph's query processing.</p>"},{"location":"03_databases/3_3_blazegraph/#parallel-execution","title":"Parallel Execution\u00b6","text":"<p>The <code>get_all_edges()</code> method uses parallel query execution with <code>ThreadPoolExecutor</code> for maximum performance on multi-core systems.</p>"},{"location":"03_databases/3_3_blazegraph/#indexing","title":"Indexing\u00b6","text":"<p>Blazegraph automatically indexes RDF triples for fast query execution. No manual index configuration required.</p>"},{"location":"03_databases/3_3_blazegraph/#troubleshooting","title":"Troubleshooting\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#connection-refused","title":"Connection Refused\u00b6","text":"<pre><code>ConnectionRefusedError: [Errno 111] Connection refused\n</code></pre> <ul> <li>Verify Blazegraph is running</li> <li>Check <code>CIMG_URL</code> environment variable</li> <li>Ensure correct port (8889 for Docker, 9999 for standalone)</li> </ul>"},{"location":"03_databases/3_3_blazegraph/#query-timeout","title":"Query Timeout\u00b6","text":"<pre><code>TimeoutError: Query execution exceeded timeout\n</code></pre> <ul> <li>Increase JVM heap size for Blazegraph</li> <li>Reduce batch size for large models</li> <li>Check Blazegraph web interface for slow queries</li> </ul>"},{"location":"03_databases/3_3_blazegraph/#empty-results","title":"Empty Results\u00b6","text":"<ul> <li>Verify data is loaded into Blazegraph</li> <li>Check namespace matches CIM profile</li> <li>Use Blazegraph web interface to verify data exists</li> </ul>"},{"location":"03_databases/3_3_blazegraph/#profile-mismatch","title":"Profile Mismatch\u00b6","text":"<pre><code>Class XYZ not in data profile\n</code></pre> <ul> <li>Verify <code>CIMG_CIM_PROFILE</code> matches database content</li> <li>Check Docker image version corresponds to correct profile</li> </ul>"},{"location":"03_databases/3_3_blazegraph/#loading-data-into-blazegraph","title":"Loading Data into Blazegraph\u00b6","text":""},{"location":"03_databases/3_3_blazegraph/#via-web-interface","title":"Via Web Interface\u00b6","text":"<ol> <li>Navigate to http://localhost:8889/bigdata/</li> <li>Click \"Update\" tab</li> <li>Select \"File Path or URL\"</li> <li>Choose RDF file format (RDF/XML for CIM)</li> <li>Click \"Update\" to load data</li> </ol>"},{"location":"03_databases/3_3_blazegraph/#via-cimantic-graphs","title":"Via CIMantic Graphs\u00b6","text":"<p>Load from XML file and upload to Blazegraph:</p>"},{"location":"03_databases/3_3_blazegraph/#via-rest-api","title":"Via REST API\u00b6","text":"<p>Use curl to bulk load RDF files:</p> <pre>curl -X POST \\\n  -H 'Content-Type: application/rdf+xml' \\\n  --data-binary @model.xml \\\n  http://localhost:8889/bigdata/namespace/kb/sparql\n</pre>"},{"location":"03_databases/3_3_blazegraph/#references","title":"References\u00b6","text":"<ul> <li>Blazegraph Official Website</li> <li>Blazegraph GitHub</li> <li>GridAPPS-D Blazegraph Docker Images</li> <li>AWS Neptune (Commercial Blazegraph)</li> <li>SPARQL 1.1 Specification</li> <li>RDF 1.1 Primer</li> <li>Common SPARQL Methods</li> <li>FeederModel Usage</li> </ul>"},{"location":"03_databases/3_4_neo4j/","title":"Neo4j","text":"In\u00a0[\u00a0]: Copied! <pre># Import class from cimgraph databases module\nfrom cimgraph.databases.neo4j import Neo4jConnection\n# Create connection parameters\n\nparams = ConnectionParameters(url = \"neo4j://localhost:7687/neo4j\", database=\"neo4j\",\n                               cim_profile='rc4_2021', iec61970_301=8)\n# Create database connection object\nneo4j = Neo4jConnection(params)\n</pre> # Import class from cimgraph databases module from cimgraph.databases.neo4j import Neo4jConnection # Create connection parameters  params = ConnectionParameters(url = \"neo4j://localhost:7687/neo4j\", database=\"neo4j\",                                cim_profile='rc4_2021', iec61970_301=8) # Create database connection object neo4j = Neo4jConnection(params)"},{"location":"03_databases/3_4_neo4j/#neo4j-database","title":"Neo4j Database\u00b6","text":""},{"location":"03_databases/3_5_graphdb/","title":"GraphDB","text":"In\u00a0[\u00a0]: Copied! <pre># Import class from cimgraph databases module\nfrom cimgraph.databases.graphdb import GraphDBConnection\n# Create connection parameters\nparams = ConnectionParameters(url = \"http://localhost:7200/repositories/cim_test\", \n                              cim_profile='rc4_2021', iec61970_301=8)\n# Create database connection object\ngraphdb = GraphDBConnection(params)\n</pre> # Import class from cimgraph databases module from cimgraph.databases.graphdb import GraphDBConnection # Create connection parameters params = ConnectionParameters(url = \"http://localhost:7200/repositories/cim_test\",                                cim_profile='rc4_2021', iec61970_301=8) # Create database connection object graphdb = GraphDBConnection(params)"},{"location":"03_databases/3_5_graphdb/#graph-db-database","title":"Graph-DB Database\u00b6","text":"<p>GraphDB is a full-featured commercial RDF graph database developed by Ontotext</p>"},{"location":"03_databases/3_6_mysql/","title":"MySQL","text":"In\u00a0[\u00a0]: Copied! <pre># Import class from cimgraph databases module\nfrom cimgraph.databases.mysql.mysql import MySQLJSONConnection\n# Create connection parameters\nparams = ConnectionParameters(host= \"localhost\", database=\"rc4_2021\", username=\"root\", password=\"password\", \n                              cim_profile='rc4_2021', namespace=\"http://iec.ch/TC57/CIM100#\")\n\n# Create database connection object\nmysql = MySQLJSONConnection(params)\n</pre> # Import class from cimgraph databases module from cimgraph.databases.mysql.mysql import MySQLJSONConnection # Create connection parameters params = ConnectionParameters(host= \"localhost\", database=\"rc4_2021\", username=\"root\", password=\"password\",                                cim_profile='rc4_2021', namespace=\"http://iec.ch/TC57/CIM100#\")  # Create database connection object mysql = MySQLJSONConnection(params)"},{"location":"03_databases/3_6_mysql/#mysql-json-ld-database","title":"MySQL JSON-LD Database\u00b6","text":"<p>MySQL database with JSON-LD typing generated by the PNNL CIM-Loader library</p>"},{"location":"03_databases/3_7_gridappsd/","title":"GridAPPS-D","text":"<p>GridAPPS-D\u2122 is an open-source platform that accelerates development and deployment of portable applications for advanced distribution management and operations. It is built in a linux environment using Docker, which allows large software packages to be distributed as containers. Its purpose is to reduce the time and cost to integrate advanced functionality into distribution operations, to create a more reliable and resilient grid.</p> <p>The GridAPPS-D source code is publically available from the GridAPPS-D GitHub. The GridAPPS-D\u2122 project is sponsored by the U.S. Department of Energy Office of Electricity and receives ongoing updates from a team of core developers at PNNL. Documentation for the platform and API is available on the GridAPPS-D Training ReadTheDocs.</p> <p>The CIM-Graph <code>ConnectionParameters</code> class is used to specify the configuration used to connect to the platform and access the data contained in the platform, with the following default values:</p> <ul> <li><p><code>cim_profile</code>: Use <code>cimhub_2023</code> for GridAPPS-D releases v2025.01.0 and later. Use <code>rc4_2021</code> for releases v2024.09.0 and earlier.</p> </li> <li><p><code>iec61970_301</code>: CIM serialization format.  Use <code>8</code> for GridAPPS-D releases v2025.01.0 and later. Use <code>7</code> for releases v2024.09.0 and earlier.</p> </li> <li><p><code>host</code>: IP address for the platform, default is <code>localhost</code>. Remote servers should use the IP address of the server.</p> </li> <li><p><code>port</code>: IP port for the platform message bus, default is <code>61613</code>.</p> </li> <li><p><code>username</code>: Username from GOSS security config, default is <code>app_user</code>.</p> </li> <li><p><code>password</code>: Password from GOSS security config, default is <code>1234App</code>.</p> </li> <li><p><code>database</code>: GridAPPS-D API to be used. Currently only <code>powergridmodel</code> API is supported.</p> </li> <li><p><code>url</code>: URL of the internal database. If running inside a docker container, this needs to be updated</p> </li> </ul> <p>To connect with the default parameters, only the <code>cim_profile</code> and <code>iec61970_301</code> versions need to be specified:</p> In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <pre>from cimgraph.databases import ConnectionParameters\nparams = ConnectionParameters(host= \"localhost\", port=\"61613\",\n                             username=\"app_user\", password=\"1234App\", \n                             cim_profile='rc4_2021', namespace=\"http://iec.ch/TC57/CIM100#\")\n</pre> from cimgraph.databases import ConnectionParameters params = ConnectionParameters(host= \"localhost\", port=\"61613\",                              username=\"app_user\", password=\"1234App\",                               cim_profile='rc4_2021', namespace=\"http://iec.ch/TC57/CIM100#\") <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 params = ConnectionParameters(host= \"localhost\", port=\"61613\",\n      2                              username=\"app_user\", password=\"1234App\", \n      3                              cim_profile='rc4_2021', namespace=\"http://iec.ch/TC57/CIM100#\")\n\nNameError: name 'ConnectionParameters' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre># Import class from cimgraph databases module\nfrom cimgraph.databases import GridappsdConnection\n# Create connection parameters\n\n# Create platform connection object\ngapps = GridAPPSDConnection(params)\n</pre> # Import class from cimgraph databases module from cimgraph.databases import GridappsdConnection # Create connection parameters  # Create platform connection object gapps = GridAPPSDConnection(params) <pre>\n---------------------------------------------------------------------------\nImportError                               Traceback (most recent call last)\nCell In[2], line 2\n      1 # Import class from cimgraph databases module\n----&gt; 2 from cimgraph.databases import GridAPPSDConnection\n      3 # Create connection parameters\n      4 params = ConnectionParameters(host= \"localhost\", port=\"61613\",\n      5                              username=\"app_user\", password=\"1234App\", \n      6                              cim_profile='rc4_2021', namespace=\"http://iec.ch/TC57/CIM100#\")\n\nImportError: cannot import name 'GridAPPSDConnection' from 'cimgraph.databases' (/home/ande188/CIM-Graph/cimgraph/databases/__init__.py)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"03_databases/3_7_gridappsd/#gridapps-d-platform-connection","title":"GridAPPS-D Platform Connection\u00b6","text":""},{"location":"03_databases/3_7_gridappsd/#connection-parameters","title":"Connection Parameters\u00b6","text":"<p>GridAPPS-D uses Java Token Authentication for user authentication based on a combination of IP address, port, username, and password. The set of default username and passwords are available in the GOSS Security Config File.</p>"},{"location":"03_databases/3_8_xml_file_parser/","title":"XML File Parser","text":"In\u00a0[1]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nimport cimgraph.data_profile.cimhub_2023 as cim\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' import cimgraph.data_profile.cimhub_2023 as cim In\u00a0[2]: Copied! <pre>from cimgraph.databases import XMLFile\nfile = XMLFile(filename='../../sample_models/ieee13.xml')\n</pre> from cimgraph.databases import XMLFile file = XMLFile(filename='../../sample_models/ieee13.xml') <pre>File ../../sample_models/ieee13.xml not found. Defaulting to empty network graph\n</pre> In\u00a0[3]: Copied! <pre>from cimgraph.models import FeederModel\nnetwork = FeederModel(container=cim.Feeder(), connection=file)\n</pre> from cimgraph.models import FeederModel network = FeederModel(container=cim.Feeder(), connection=file) <pre>No root element found in XML file\n</pre> <p>The complete network model, including both forward and reverse associations, is now loaded into the graph.</p> <p>To demonstrate the structure, let's examine a breaker object:</p> In\u00a0[4]: Copied! <pre>from cimgraph import utils\nfrom mermaid import Mermaid\n\n# Get first breaker in graph\nbreaker = network.first(cim.Breaker)\n# Display the breaker\nMermaid(utils.get_mermaid(breaker))\n</pre> from cimgraph import utils from mermaid import Mermaid  # Get first breaker in graph breaker = network.first(cim.Breaker) # Display the breaker Mermaid(utils.get_mermaid(breaker)) Out[4]: In\u00a0[5]: Copied! <pre>from mermaid import Mermaid\n\ndiagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%%\nsequenceDiagram\n    actor User\n    participant XMLFile\n    participant ElementTree\n    participant FileSystem\n    \n    note right of User: Initialize XML connection\n    User -&gt;&gt;+ XMLFile: XMLFile(filename, namespaces)\n    XMLFile -&gt;&gt; XMLFile: clear env variable cache\n    XMLFile -&gt;&gt; XMLFile: retrieve CIM profile &amp; namespace\n    XMLFile -&gt;&gt;+ XMLFile: connect()\n    XMLFile -&gt;&gt;+ ElementTree: parse(filename)\n    ElementTree -&gt;&gt;+ FileSystem: read XML file\n    FileSystem --&gt;&gt;- ElementTree: file contents\n    ElementTree --&gt;&gt;- XMLFile: tree &amp; root element\n    XMLFile -&gt;&gt;+ FileSystem: open &amp; read header (8KB)\n    FileSystem --&gt;&gt;- XMLFile: XML header text\n    XMLFile -&gt;&gt; XMLFile: extract_namespaces_from_header()\n    XMLFile -&gt;&gt; XMLFile: update namespace mappings\n    XMLFile -&gt;&gt; XMLFile: initialize empty graph\n    XMLFile -&gt;&gt; XMLFile: initialize class_index\n    XMLFile --&gt;&gt;- XMLFile: connection ready\n    XMLFile --&gt;&gt;- User: XMLFile instance\n\"\"\"\n\nMermaid(diagram_text)\n</pre> from mermaid import Mermaid  diagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%% sequenceDiagram     actor User     participant XMLFile     participant ElementTree     participant FileSystem          note right of User: Initialize XML connection     User -&gt;&gt;+ XMLFile: XMLFile(filename, namespaces)     XMLFile -&gt;&gt; XMLFile: clear env variable cache     XMLFile -&gt;&gt; XMLFile: retrieve CIM profile &amp; namespace     XMLFile -&gt;&gt;+ XMLFile: connect()     XMLFile -&gt;&gt;+ ElementTree: parse(filename)     ElementTree -&gt;&gt;+ FileSystem: read XML file     FileSystem --&gt;&gt;- ElementTree: file contents     ElementTree --&gt;&gt;- XMLFile: tree &amp; root element     XMLFile -&gt;&gt;+ FileSystem: open &amp; read header (8KB)     FileSystem --&gt;&gt;- XMLFile: XML header text     XMLFile -&gt;&gt; XMLFile: extract_namespaces_from_header()     XMLFile -&gt;&gt; XMLFile: update namespace mappings     XMLFile -&gt;&gt; XMLFile: initialize empty graph     XMLFile -&gt;&gt; XMLFile: initialize class_index     XMLFile --&gt;&gt;- XMLFile: connection ready     XMLFile --&gt;&gt;- User: XMLFile instance \"\"\"  Mermaid(diagram_text) Out[5]: In\u00a0[6]: Copied! <pre>diagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%%\nsequenceDiagram\n    actor GraphModel\n    participant XMLFile\n    participant root element\n    \n    note right of GraphModel: Build network graph from XML\n    GraphModel -&gt;&gt;+ XMLFile: create_new_graph(container, graph)\n    \n    note over XMLFile,root element: First Pass - Create Nodes\n    loop for each element in root\n        XMLFile -&gt;&gt;+ XMLFile: parse_nodes(element)\n        XMLFile -&gt;&gt; XMLFile: extract class name from tag\n        XMLFile -&gt;&gt; XMLFile: extract rdf:about or rdf:ID\n        XMLFile -&gt;&gt; XMLFile: create_object(graph, cim_class, uri)\n        XMLFile -&gt;&gt; XMLFile: update class_index\n        XMLFile --&gt;&gt;- XMLFile: object created\n    end\n    \n    note over XMLFile,root element: Second Pass - Create Edges\n    loop for each element in root\n        XMLFile -&gt;&gt;+ XMLFile: parse_edges(element)\n        XMLFile -&gt;&gt; XMLFile: extract object from graph\n        loop for each sub_element\n            XMLFile -&gt;&gt; XMLFile: parse_value(sub_element)\n            alt rdf:resource present\n                XMLFile -&gt;&gt; XMLFile: create_edge() to linked object\n                XMLFile -&gt;&gt; XMLFile: create reverse edge\n            else text value present\n                XMLFile -&gt;&gt; XMLFile: create_value() attribute\n            else enumeration\n                XMLFile -&gt;&gt; XMLFile: set enum value\n            end\n        end\n        XMLFile --&gt;&gt;- XMLFile: edges created\n    end\n    \n    XMLFile --&gt;&gt;- GraphModel: Graph\n\"\"\"\n\nMermaid(diagram_text)\n</pre> diagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%% sequenceDiagram     actor GraphModel     participant XMLFile     participant root element          note right of GraphModel: Build network graph from XML     GraphModel -&gt;&gt;+ XMLFile: create_new_graph(container, graph)          note over XMLFile,root element: First Pass - Create Nodes     loop for each element in root         XMLFile -&gt;&gt;+ XMLFile: parse_nodes(element)         XMLFile -&gt;&gt; XMLFile: extract class name from tag         XMLFile -&gt;&gt; XMLFile: extract rdf:about or rdf:ID         XMLFile -&gt;&gt; XMLFile: create_object(graph, cim_class, uri)         XMLFile -&gt;&gt; XMLFile: update class_index         XMLFile --&gt;&gt;- XMLFile: object created     end          note over XMLFile,root element: Second Pass - Create Edges     loop for each element in root         XMLFile -&gt;&gt;+ XMLFile: parse_edges(element)         XMLFile -&gt;&gt; XMLFile: extract object from graph         loop for each sub_element             XMLFile -&gt;&gt; XMLFile: parse_value(sub_element)             alt rdf:resource present                 XMLFile -&gt;&gt; XMLFile: create_edge() to linked object                 XMLFile -&gt;&gt; XMLFile: create reverse edge             else text value present                 XMLFile -&gt;&gt; XMLFile: create_value() attribute             else enumeration                 XMLFile -&gt;&gt; XMLFile: set enum value             end         end         XMLFile --&gt;&gt;- XMLFile: edges created     end          XMLFile --&gt;&gt;- GraphModel: Graph \"\"\"  Mermaid(diagram_text) Out[6]: In\u00a0[7]: Copied! <pre>diagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%%\nsequenceDiagram\n    actor User\n    participant GraphModel\n    participant XMLFile\n    participant FileSystem\n    \n    note right of User: Write modified graph to XML\n    User -&gt;&gt;+ GraphModel: upload()\n    GraphModel -&gt;&gt;+ XMLFile: upload(graph)\n    XMLFile -&gt;&gt;+ FileSystem: open(filename, 'w')\n    FileSystem --&gt;&gt;- XMLFile: file handle\n    \n    XMLFile -&gt;&gt; XMLFile: determine IEC 61970-301 format\n    XMLFile -&gt;&gt;+ FileSystem: write XML header &amp; RDF tag\n    FileSystem --&gt;&gt;- XMLFile: ok\n    \n    loop for each class in graph\n        loop for each object in class\n            XMLFile -&gt;&gt;+ FileSystem: write opening tag with mRID\n            FileSystem --&gt;&gt;- XMLFile: ok\n            \n            loop for each parent class\n                loop for each attribute\n                    XMLFile -&gt;&gt; XMLFile: get attribute value\n                    alt CIM object reference\n                        XMLFile -&gt;&gt;+ FileSystem: write rdf:resource edge\n                        FileSystem --&gt;&gt;- XMLFile: ok\n                    else enumeration\n                        XMLFile -&gt;&gt;+ FileSystem: write rdf:resource enum\n                        FileSystem --&gt;&gt;- XMLFile: ok\n                    else primitive with CIMUnit\n                        XMLFile -&gt;&gt;+ FileSystem: write with rdf:datatype\n                        FileSystem --&gt;&gt;- XMLFile: ok\n                    else primitive value\n                        XMLFile -&gt;&gt;+ FileSystem: write text value\n                        FileSystem --&gt;&gt;- XMLFile: ok\n                    end\n                end\n            end\n            \n            XMLFile -&gt;&gt;+ FileSystem: write closing tag\n            FileSystem --&gt;&gt;- XMLFile: ok\n        end\n    end\n    \n    XMLFile -&gt;&gt;+ FileSystem: write closing RDF tag\n    FileSystem --&gt;&gt;- XMLFile: ok\n    XMLFile -&gt;&gt;+ FileSystem: close file\n    FileSystem --&gt;&gt;- XMLFile: ok\n    \n    XMLFile --&gt;&gt;- GraphModel: None\n    GraphModel --&gt;&gt;- User: upload complete\n\"\"\"\n\nMermaid(diagram_text)\n</pre> diagram_text = \"\"\"%%{init: {\"theme\":\"base\"}}%% sequenceDiagram     actor User     participant GraphModel     participant XMLFile     participant FileSystem          note right of User: Write modified graph to XML     User -&gt;&gt;+ GraphModel: upload()     GraphModel -&gt;&gt;+ XMLFile: upload(graph)     XMLFile -&gt;&gt;+ FileSystem: open(filename, 'w')     FileSystem --&gt;&gt;- XMLFile: file handle          XMLFile -&gt;&gt; XMLFile: determine IEC 61970-301 format     XMLFile -&gt;&gt;+ FileSystem: write XML header &amp; RDF tag     FileSystem --&gt;&gt;- XMLFile: ok          loop for each class in graph         loop for each object in class             XMLFile -&gt;&gt;+ FileSystem: write opening tag with mRID             FileSystem --&gt;&gt;- XMLFile: ok                          loop for each parent class                 loop for each attribute                     XMLFile -&gt;&gt; XMLFile: get attribute value                     alt CIM object reference                         XMLFile -&gt;&gt;+ FileSystem: write rdf:resource edge                         FileSystem --&gt;&gt;- XMLFile: ok                     else enumeration                         XMLFile -&gt;&gt;+ FileSystem: write rdf:resource enum                         FileSystem --&gt;&gt;- XMLFile: ok                     else primitive with CIMUnit                         XMLFile -&gt;&gt;+ FileSystem: write with rdf:datatype                         FileSystem --&gt;&gt;- XMLFile: ok                     else primitive value                         XMLFile -&gt;&gt;+ FileSystem: write text value                         FileSystem --&gt;&gt;- XMLFile: ok                     end                 end             end                          XMLFile -&gt;&gt;+ FileSystem: write closing tag             FileSystem --&gt;&gt;- XMLFile: ok         end     end          XMLFile -&gt;&gt;+ FileSystem: write closing RDF tag     FileSystem --&gt;&gt;- XMLFile: ok     XMLFile -&gt;&gt;+ FileSystem: close file     FileSystem --&gt;&gt;- XMLFile: ok          XMLFile --&gt;&gt;- GraphModel: None     GraphModel --&gt;&gt;- User: upload complete \"\"\"  Mermaid(diagram_text) Out[7]: In\u00a0[8]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nimport cimgraph.data_profile.cimhub_2023 as cim\nfrom cimgraph.databases import XMLFile\nfrom cimgraph.models import FeederModel\n\n# 1. Load model from XML\nfile = XMLFile(filename='../../sample_models/ieee13.xml')\nnetwork = FeederModel(container=cim.Feeder(), connection=file)\n\n# 2. Modify the model\nfor line in network.graph.get(cim.ACLineSegment, {}).values():\n    if line.length is not None:\n        # Increase all line lengths by 10%\n        line.length = line.length * 1.1\n\n# 3. Save modified model\noutput_file = XMLFile(filename='../../sample_models/ieee13_modified.xml')\noutput_file.upload(network.graph)\n\nprint(\"Model modified and saved successfully\")\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' import cimgraph.data_profile.cimhub_2023 as cim from cimgraph.databases import XMLFile from cimgraph.models import FeederModel  # 1. Load model from XML file = XMLFile(filename='../../sample_models/ieee13.xml') network = FeederModel(container=cim.Feeder(), connection=file)  # 2. Modify the model for line in network.graph.get(cim.ACLineSegment, {}).values():     if line.length is not None:         # Increase all line lengths by 10%         line.length = line.length * 1.1  # 3. Save modified model output_file = XMLFile(filename='../../sample_models/ieee13_modified.xml') output_file.upload(network.graph)  print(\"Model modified and saved successfully\") <pre>File ../../sample_models/ieee13.xml not found. Defaulting to empty network graph\nNo root element found in XML file\nFile ../../sample_models/ieee13_modified.xml not found. Defaulting to empty network graph\n</pre> <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[8], line 19\n     17 # 3. Save modified model\n     18 output_file = XMLFile(filename='../../sample_models/ieee13_modified.xml')\n---&gt; 19 output_file.upload(network.graph)\n     21 print(\"Model modified and saved successfully\")\n\nFile ~/CIM-Graph/cimgraph/databases/fileparsers/xml_parser.py:345, in XMLFile.upload(self, graph)\n    343     rdf_header = 'rdf:ID=\"'\n    344     rdf_resource = '#'\n--&gt; 345 f = open(self.filename, 'w', encoding='utf-8')\n    346 header = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n    347 header += '&lt;!-- un-comment this line to enable validation\\n'\n\nFileNotFoundError: [Errno 2] No such file or directory: '../../sample_models/ieee13_modified.xml'</pre>"},{"location":"03_databases/3_8_xml_file_parser/#xml-file-parser","title":"XML File Parser\u00b6","text":"<p>The <code>XMLFile</code> class provides a local file-based interface for reading and writing CIM power system models in XML/RDF format. This is particularly useful for working with small to medium-sized test cases without requiring a database infrastructure.</p>"},{"location":"03_databases/3_8_xml_file_parser/#overview","title":"Overview\u00b6","text":"<p>The XML file parser implements the <code>ConnectionInterface</code> and provides the following capabilities:</p> <ul> <li>Read CIM XML/RDF files conforming to IEC 61970-301 (CIM RDF Schema)</li> <li>Parse and validate namespace declarations from XML headers</li> <li>Build typed property graphs from XML element trees</li> <li>Write CIM objects back to XML/RDF format</li> <li>Support for both rdf:ID and rdf:about serialization formats</li> <li>Automatic namespace extraction and validation</li> </ul>"},{"location":"03_databases/3_8_xml_file_parser/#user-guide","title":"User Guide\u00b6","text":""},{"location":"03_databases/3_8_xml_file_parser/#installation-and-setup","title":"Installation and Setup\u00b6","text":"<p>The XML parser requires no additional database software. It uses the Python <code>defusedxml</code> library for secure XML parsing.</p> <p>First, set the CIM profile environment variable and import the profile:</p>"},{"location":"03_databases/3_8_xml_file_parser/#creating-an-xmlfile-connection","title":"Creating an XMLFile Connection\u00b6","text":"<p>Import and instantiate the <code>XMLFile</code> class:</p>"},{"location":"03_databases/3_8_xml_file_parser/#constructor-parameters","title":"Constructor Parameters\u00b6","text":"<p>The <code>XMLFile.__init__()</code> method accepts the following parameters:</p> <p>Required Parameters:</p> <ul> <li><code>filename</code> (str | list[str]): Path to the XML file(s) to read. Can be a single file path or a list of paths for multi-file models.</li> </ul> <p>Optional Parameters:</p> <ul> <li><code>namespaces</code> (dict): Additional namespace mappings to override or supplement extracted namespaces. Format: <code>{'prefix': 'uri'}</code>. Default: <code>None</code></li> </ul> <p>Behavior:</p> <ul> <li>Automatically clears cached environment variables to ensure fresh configuration</li> <li>Retrieves CIM profile, namespace, IEC 61970-301 version, and validation log level from environment</li> <li>Calls <code>connect()</code> method automatically to parse the XML file and extract namespaces</li> </ul>"},{"location":"03_databases/3_8_xml_file_parser/#loading-a-feedermodel-from-xml","title":"Loading a FeederModel from XML\u00b6","text":"<p>Once the <code>XMLFile</code> connection is established, create a <code>FeederModel</code> to build the network graph:</p>"},{"location":"03_databases/3_8_xml_file_parser/#user-api-methods","title":"User API Methods\u00b6","text":"<p>The <code>XMLFile</code> class implements the <code>ConnectionInterface</code> abstract base class and provides the following user-facing methods:</p>"},{"location":"03_databases/3_8_xml_file_parser/#connect","title":"connect()\u00b6","text":"<p>Establishes connection to the XML file and parses the document structure.</p> <p>Parameters: None</p> <p>Returns: None</p> <p>Behavior:</p> <ul> <li>Parses XML file using <code>defusedxml.ElementTree.parse()</code> for security</li> <li>Extracts namespace declarations from the XML root element</li> <li>Updates internal namespace mappings</li> <li>Initializes empty graph structure (<code>defaultdict(lambda: defaultdict(dict))</code>)</li> <li>Creates empty <code>class_index</code> for tracking object types by URI</li> <li>If file is not found, logs warning and creates empty graph</li> </ul> <p>Usage:</p> <pre>file = XMLFile(filename='model.xml')  # connect() called automatically\n</pre>"},{"location":"03_databases/3_8_xml_file_parser/#disconnect","title":"disconnect()\u00b6","text":"<p>Releases resources held by the XML file connection.</p> <p>Parameters: None</p> <p>Returns: None</p> <p>Behavior:</p> <ul> <li>Deletes the ElementTree (<code>self.tree</code>)</li> <li>Deletes the root element (<code>self.root</code>)</li> <li>Deletes the graph dictionary (<code>self.graph</code>)</li> </ul> <p>Usage:</p> <pre>file.disconnect()\n</pre>"},{"location":"03_databases/3_8_xml_file_parser/#get_objectmrid-graphnone","title":"get_object(mRID, graph=None)\u00b6","text":"<p>Retrieves a single CIM object from the XML file by its mRID.</p> <p>Parameters:</p> <ul> <li><code>mRID</code> (str): The master resource identifier (UUID) of the object to retrieve</li> <li><code>graph</code> (dict): Optional existing graph (not used in current implementation)</li> </ul> <p>Returns:</p> <ul> <li><code>object</code>: The parsed CIM object, or <code>None</code> if not found</li> </ul> <p>Behavior:</p> <ul> <li>Iterates through all XML elements in the document</li> <li>Matches elements by <code>rdf:about</code> or <code>rdf:ID</code> attributes</li> <li>Returns the first object whose URI contains the specified mRID</li> <li>Calls <code>parse_nodes()</code> to construct the object</li> </ul> <p>Usage:</p> <pre>breaker = file.get_object(mRID='4c04f838-62aa-475e-aefa-a63b7c889c13')\n</pre>"},{"location":"03_databases/3_8_xml_file_parser/#get_from_triplesubject-predicate-graphnone","title":"get_from_triple(subject, predicate, graph=None)\u00b6","text":"<p>Retrieves attribute values for a specific object and predicate.</p> <p>Parameters:</p> <ul> <li><code>subject</code> (Identity): The CIM object to query</li> <li><code>predicate</code> (str): The attribute/association name to retrieve</li> <li><code>graph</code> (Graph): Optional existing graph (uses empty graph if not provided)</li> </ul> <p>Returns:</p> <ul> <li><code>list[object]</code>: List of values for the specified attribute</li> </ul> <p>Behavior:</p> <ul> <li>Finds all XML elements matching the subject's class type</li> <li>Filters to elements matching the subject's URI</li> <li>Extracts child elements matching the predicate</li> <li>Parses and returns the values</li> </ul> <p>Usage:</p> <pre>breaker = network.first(cim.Breaker)\nterminals = file.get_from_triple(breaker, 'Terminals')\n</pre>"},{"location":"03_databases/3_8_xml_file_parser/#create_new_graphcontainer-graphnone","title":"create_new_graph(container, graph=None)\u00b6","text":"<p>Builds the complete typed property graph from the XML file.</p> <p>Parameters:</p> <ul> <li><code>container</code> (object): The top-level CIM container object (typically a <code>Feeder</code>)</li> <li><code>graph</code> (dict): Optional existing graph to populate (creates new if <code>None</code>)</li> </ul> <p>Returns:</p> <ul> <li><code>Graph</code>: The populated typed property graph</li> </ul> <p>Behavior:</p> <ul> <li>Two-pass parsing approach:<ol> <li>First pass: Create all nodes (objects) using <code>parse_nodes()</code></li> <li>Second pass: Create all edges (associations) using <code>parse_edges()</code></li> </ol> </li> <li>Validates all elements against the loaded CIM profile</li> <li>Builds bidirectional associations between objects</li> <li>Returns empty graph if XML root is <code>None</code></li> </ul> <p>Usage:</p> <pre>graph = file.create_new_graph(container=cim.Feeder())\n</pre> <p>Note: This method is typically called internally by <code>FeederModel</code> or other <code>GraphModel</code> subclasses.</p>"},{"location":"03_databases/3_8_xml_file_parser/#uploadgraph","title":"upload(graph)\u00b6","text":"<p>Writes a typed property graph back to XML/RDF format.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (Graph): The typed property graph to serialize</li> </ul> <p>Returns: None</p> <p>Behavior:</p> <ul> <li>Creates properly formatted CIM XML/RDF file</li> <li>Handles both IEC 61970-301 v7 and v8+ formats:<ul> <li>v7: Uses <code>rdf:ID</code> and <code>#</code> for resources</li> <li>v8+: Uses <code>rdf:about</code> with <code>urn:uuid:</code> URIs</li> </ul> </li> <li>Serializes all object attributes and associations</li> <li>Handles enumerations, primitives, and object references</li> <li>Supports many-to-one and known many-to-many associations</li> <li>Preserves CIM units with <code>rdf:datatype</code> attributes</li> <li>Writes to the file specified in <code>self.filename</code></li> </ul> <p>Usage:</p> <pre># Modify objects in the graph\n# ...\n\n# Write back to XML\nfile.upload(network.graph)\n</pre>"},{"location":"03_databases/3_8_xml_file_parser/#executequery_message","title":"execute(query_message)\u00b6","text":"<p>Not implemented for XML file parser.</p> <p>Parameters:</p> <ul> <li><code>query_message</code> (str): Query string (not used)</li> </ul> <p>Returns:</p> <ul> <li><code>QueryResponse</code>: Empty response</li> </ul> <p>Note: The XML parser uses direct element tree traversal instead of query-based access.</p>"},{"location":"03_databases/3_8_xml_file_parser/#create_distributed_grapharea-graphnone","title":"create_distributed_graph(area, graph=None)\u00b6","text":"<p>Not supported for XML file parser.</p> <p>Parameters:</p> <ul> <li><code>area</code> (object): Geographic area object (not used)</li> <li><code>graph</code> (dict): Optional existing graph</li> </ul> <p>Returns:</p> <ul> <li><code>Graph</code>: Empty graph</li> </ul> <p>Behavior:</p> <ul> <li>Logs error message: \"distributed models not supported for XML file read\"</li> <li>Returns empty graph structure</li> </ul> <p>Note: Distributed model functionality is only available with database backends.</p>"},{"location":"03_databases/3_8_xml_file_parser/#uml-sequence-diagrams","title":"UML Sequence Diagrams\u00b6","text":"<p>This section provides sequence diagrams showing the internal workflow of key XMLFile methods.</p>"},{"location":"03_databases/3_8_xml_file_parser/#xmlfile-initialization-and-connection","title":"XMLFile Initialization and Connection\u00b6","text":""},{"location":"03_databases/3_8_xml_file_parser/#create_new_graph-building-the-typed-property-graph","title":"create_new_graph() - Building the Typed Property Graph\u00b6","text":""},{"location":"03_databases/3_8_xml_file_parser/#upload-writing-graph-to-xmlrdf","title":"upload() - Writing Graph to XML/RDF\u00b6","text":""},{"location":"03_databases/3_8_xml_file_parser/#developer-documentation","title":"Developer Documentation\u00b6","text":"<p>This section documents the internal methods used by the XML parser implementation. These methods are not typically called directly by users but are essential for understanding the parser's operation.</p>"},{"location":"03_databases/3_8_xml_file_parser/#extract_namespaces_from_header","title":"extract_namespaces_from_header()\u00b6","text":"<p>Extracts namespace declarations from the XML root element.</p> <p>Parameters: None</p> <p>Returns:</p> <ul> <li><code>dict</code>: Dictionary mapping namespace prefixes to URIs (without curly braces)</li> </ul> <p>Implementation Details:</p> <ul> <li>Reads the first 8KB of the XML file to find the root element</li> <li>Uses regex pattern <code>xmlns(?::([a-zA-Z0-9_-]+))?=[\"']([^\"']+)[\"']</code> to match namespace declarations</li> <li>Captures both prefixed namespaces (<code>xmlns:cim=\"...\"</code>) and default namespace (<code>xmlns=\"...\"</code>)</li> <li>Stores namespaces WITHOUT curly braces for ElementTree compatibility</li> <li>Default namespace stored with key <code>'default'</code></li> <li>Logs debug information for each namespace found</li> </ul> <p>Source: <code>cimgraph/databases/fileparsers/xml_parser.py:77</code></p>"},{"location":"03_databases/3_8_xml_file_parser/#parse_nodeselement","title":"parse_nodes(element)\u00b6","text":"<p>Creates CIM objects from XML elements without populating associations.</p> <p>Parameters:</p> <ul> <li><code>element</code> (xml.etree.ElementTree.Element): The XML element to parse</li> </ul> <p>Returns:</p> <ul> <li><code>Identity</code>: The created CIM object, or <code>None</code> if parsing fails</li> </ul> <p>Implementation Details:</p> <ul> <li>Extracts class name from element tag by removing namespace URI</li> <li>Tries primary namespace first, then falls back to other registered namespaces</li> <li>Validates class name against CIM profile (<code>self.cim.__all__</code>)</li> <li>Extracts object identifier from <code>rdf:about</code> or <code>rdf:ID</code> attribute</li> <li>Strips URI prefixes (e.g., <code>urn:uuid:</code>) to extract UUID</li> <li>Calls <code>create_object()</code> to instantiate the object and add to graph</li> <li>Updates <code>class_index</code> dictionary for later edge creation</li> <li>Logs validation warnings for classes not in the data profile</li> </ul> <p>Source: <code>cimgraph/databases/fileparsers/xml_parser.py:192</code></p>"},{"location":"03_databases/3_8_xml_file_parser/#parse_edgeselement","title":"parse_edges(element)\u00b6","text":"<p>Populates associations (edges) between CIM objects after all nodes are created.</p> <p>Parameters:</p> <ul> <li><code>element</code> (xml.etree.ElementTree.Element): The XML element to parse</li> </ul> <p>Returns: None</p> <p>Implementation Details:</p> <ul> <li>Extracts class name and object identifier from element</li> <li>Retrieves the object from the graph using class type and UUID</li> <li>Iterates through all child elements (sub-elements)</li> <li>Skips <code>Identity.identifier</code> elements</li> <li>Calls <code>parse_value()</code> for each child element to create edges/attributes</li> <li>Handles conversion of string URIs to UUID objects</li> <li>Logs validation warnings for classes not in the data profile</li> </ul> <p>Note: This method must be called after <code>parse_nodes()</code> has created all objects.</p> <p>Source: <code>cimgraph/databases/fileparsers/xml_parser.py:238</code></p>"},{"location":"03_databases/3_8_xml_file_parser/#parse_valuesub_element-cim_class-identifier","title":"parse_value(sub_element, cim_class, identifier)\u00b6","text":"<p>Parses and sets attribute values or creates edges to other objects.</p> <p>Parameters:</p> <ul> <li><code>sub_element</code> (xml.etree.ElementTree.Element): The XML sub-element containing the value</li> <li><code>cim_class</code> (type): The CIM class type of the parent object</li> <li><code>identifier</code> (UUID): The UUID of the parent object</li> </ul> <p>Returns:</p> <ul> <li><code>object</code>: The parsed value, edge object, or <code>None</code></li> </ul> <p>Implementation Details:</p> <ul> <li><p>Extracts attribute name from element tag (e.g., <code>ACLineSegment.length</code>)</p> </li> <li><p>Checks for <code>rdf:datatype</code> attribute for CIM units</p> </li> <li><p>Checks for <code>rdf:resource</code> attribute indicating an edge or enumeration</p> </li> <li><p>Three parsing branches:</p> <p>1. Edge to another object (<code>rdf:resource</code> to UUID):</p> <ul> <li>Extracts UUID from resource URI</li> <li>Validates object exists in <code>class_index</code></li> <li>Calls <code>create_edge()</code> to link objects</li> <li>Creates reverse/inverse edge automatically</li> <li>Logs warning if referenced object not found</li> </ul> <p>2. Enumeration value (<code>rdf:resource</code> to enum):</p> <ul> <li>Detects namespace in URI</li> <li>Parses enum class and value (e.g., <code>PhaseCode.ABC</code>)</li> <li>Instantiates enum and sets on parent object</li> </ul> <p>3. Primitive value (text content):</p> <ul> <li>Extracts text from element</li> <li>Passes <code>rdf:datatype</code> if present for CIM units</li> <li>Calls <code>create_value()</code> to handle type conversion</li> </ul> </li> </ul> <p>Source: <code>cimgraph/databases/fileparsers/xml_parser.py:264</code></p>"},{"location":"03_databases/3_8_xml_file_parser/#parse_node_querygraph-query_output","title":"parse_node_query(graph, query_output)\u00b6","text":"<p>Not implemented for XML file parser.</p> <p>Note: This method is used by database backends to parse SPARQL query results.</p>"},{"location":"03_databases/3_8_xml_file_parser/#get_edges_querygraph-cim_class","title":"get_edges_query(graph, cim_class)\u00b6","text":"<p>Not implemented for XML file parser.</p> <p>Note: This method is used by database backends to construct SPARQL queries.</p>"},{"location":"03_databases/3_8_xml_file_parser/#get_all_edgesgraph-cim_class","title":"get_all_edges(graph, cim_class)\u00b6","text":"<p>Not implemented for XML file parser.</p> <p>Note: This method is defined in the <code>ConnectionInterface</code> but not used by the XML parser, which builds the complete graph in <code>create_new_graph()</code> instead of querying incrementally.</p>"},{"location":"03_databases/3_8_xml_file_parser/#get_all_attributesgraph-cim_class","title":"get_all_attributes(graph, cim_class)\u00b6","text":"<p>Not implemented for XML file parser.</p> <p>Note: The XML parser loads all attributes during the initial <code>create_new_graph()</code> operation.</p>"},{"location":"03_databases/3_8_xml_file_parser/#edge_query_parserquery_output-graph-cim_class-expand_graphtrue","title":"edge_query_parser(query_output, graph, cim_class, expand_graph=True)\u00b6","text":"<p>Not implemented for XML file parser.</p> <p>Note: This method is used by database backends to parse query results for edge expansion.</p>"},{"location":"03_databases/3_8_xml_file_parser/#common-inherited-methods","title":"Common Inherited Methods\u00b6","text":"<p>The <code>XMLFile</code> class inherits several utility methods from the <code>ConnectionInterface</code> base class. These methods are used internally but are documented here for completeness.</p>"},{"location":"03_databases/3_8_xml_file_parser/#check_attributecim_class-attribute","title":"check_attribute(cim_class, attribute)\u00b6","text":"<p>Validates and resolves attribute names including inverse associations.</p> <p>Parameters:</p> <ul> <li><code>cim_class</code> (type): The CIM class type</li> <li><code>attribute</code> (str): The attribute name in format <code>ClassName.attributeName</code></li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: The resolved attribute name, or <code>None</code> if not found</li> </ul> <p>Implementation Details:</p> <ul> <li>Splits attribute into class name and link name</li> <li>First checks if attribute exists directly on <code>cim_class</code></li> <li>If not, checks the source class for the attribute</li> <li>Resolves inverse associations using metadata</li> <li>Logs validation warnings for missing attributes</li> </ul> <p>Source: <code>cimgraph/databases/__init__.py:80</code></p>"},{"location":"03_databases/3_8_xml_file_parser/#create_objectgraph-class_type-uri","title":"create_object(graph, class_type, uri)\u00b6","text":"<p>Creates a new CIM object and adds it to the graph.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (Graph): The typed property graph</li> <li><code>class_type</code> (type): The CIM class type (e.g., <code>cim.ACLineSegment</code>)</li> <li><code>uri</code> (str): The RDF ID or mRID of the object</li> </ul> <p>Returns:</p> <ul> <li><code>object</code>: The created or existing dataclass instance</li> </ul> <p>Implementation Details:</p> <ul> <li>Converts URI string to UUID</li> <li>Checks if object already exists in graph</li> <li>If exists, returns existing object</li> <li>If not, creates new instance and adds to graph</li> <li>Handles non-UUID identifiers gracefully</li> </ul> <p>Source: <code>cimgraph/databases/__init__.py:245</code></p>"},{"location":"03_databases/3_8_xml_file_parser/#create_edgegraph-cim_class-identifier-attribute-edge_class-edge_mrid","title":"create_edge(graph, cim_class, identifier, attribute, edge_class, edge_mRID)\u00b6","text":"<p>Creates an association (edge) between two CIM objects.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (Graph): The typed property graph</li> <li><code>cim_class</code> (type): The source object's class type</li> <li><code>identifier</code> (UUID): The source object's UUID</li> <li><code>attribute</code> (str): The attribute name for the association</li> <li><code>edge_class</code> (type): The target object's class type</li> <li><code>edge_mRID</code> (str): The target object's mRID</li> </ul> <p>Returns:</p> <ul> <li><code>object</code>: The edge object, or <code>None</code> if creation failed</li> </ul> <p>Implementation Details:</p> <ul> <li>Validates attribute exists using <code>check_attribute()</code></li> <li>Determines if attribute is single-valued or list-valued</li> <li>For lists: appends to existing list without duplicates</li> <li>For single values: sets the attribute directly</li> <li>Creates target object if it doesn't exist</li> <li>Updates the source object's attribute</li> </ul> <p>Source: <code>cimgraph/databases/__init__.py:216</code></p>"},{"location":"03_databases/3_8_xml_file_parser/#create_valuegraph-cim_class-identifier-attribute-value-datatype_urinone","title":"create_value(graph, cim_class, identifier, attribute, value, datatype_uri=None)\u00b6","text":"<p>Sets a primitive attribute value with proper type conversion.</p> <p>Parameters:</p> <ul> <li><code>graph</code> (Graph): The typed property graph</li> <li><code>cim_class</code> (type): The object's class type</li> <li><code>identifier</code> (UUID): The object's UUID</li> <li><code>attribute</code> (str): The attribute name</li> <li><code>value</code> (str): The string value to convert and set</li> <li><code>datatype_uri</code> (str): Optional RDF datatype URI for CIM units</li> </ul> <p>Returns:</p> <ul> <li><code>bool|int|float|str|object</code>: The converted value</li> </ul> <p>Implementation Details:</p> <ul> <li>Validates attribute using <code>check_attribute()</code></li> <li>Handles CIM units when <code>datatype_uri</code> is provided:<ul> <li>Extracts unit class name from URI</li> <li>Parses unit and multiplier (e.g., \"MVA\" -&gt; \"VA\" + \"M\")</li> <li>Creates <code>CIMUnit</code> instance with proper conversions</li> </ul> </li> <li>Type conversions for primitives:<ul> <li><code>bool</code>: Converts \"true\"/\"1\" to <code>True</code>, \"false\"/\"0\" to <code>False</code></li> <li><code>int</code>: Converts to integer via float (handles \"123.0\")</li> <li><code>float</code>: Direct float conversion</li> <li><code>list</code>: Appends without duplicates</li> <li>Other types: Sets as string</li> </ul> </li> <li>Logs warnings for type conversion failures</li> </ul> <p>Source: <code>cimgraph/databases/__init__.py:110</code></p>"},{"location":"03_databases/3_8_xml_file_parser/#add_to_graphobj-graph","title":"add_to_graph(obj, graph)\u00b6","text":"<p>Adds an existing CIM object to the graph.</p> <p>Parameters:</p> <ul> <li><code>obj</code> (object): A dataclass instance inheriting from <code>Identity</code></li> <li><code>graph</code> (Graph): The typed property graph</li> </ul> <p>Returns: None</p> <p>Implementation Details:</p> <ul> <li>Creates class type entry in graph if not present</li> <li>Adds instance to graph using its identifier as key</li> <li>Does not overwrite existing instances</li> </ul> <p>Source: <code>cimgraph/databases/__init__.py:275</code></p>"},{"location":"03_databases/3_8_xml_file_parser/#performance-considerations","title":"Performance Considerations\u00b6","text":""},{"location":"03_databases/3_8_xml_file_parser/#load-times","title":"Load Times\u00b6","text":"<p>Typical load times for standard IEEE test cases:</p> Model Nodes Branches Load Time IEEE 13-bus ~100 objects ~10 lines &lt; 1 second IEEE 123-bus ~800 objects ~100 lines ~2-3 seconds IEEE 8500-node ~20,000 objects ~8,000 lines ~12 seconds"},{"location":"03_databases/3_8_xml_file_parser/#optimization-strategies","title":"Optimization Strategies\u00b6","text":"<p>For large models (&gt; 5,000 nodes), consider:</p> <ol> <li>Use a Database Backend: Blazegraph, GraphDB, or Neo4j provide much faster access</li> <li>Incremental Loading: Load only the equipment classes you need using selective queries</li> <li>Caching: Save the graph as a Python pickle for repeated use</li> </ol>"},{"location":"03_databases/3_8_xml_file_parser/#memory-usage","title":"Memory Usage\u00b6","text":"<p>The XML parser loads the entire model into memory. Approximate memory requirements:</p> <ul> <li>Small models (&lt; 1000 objects): ~10-20 MB</li> <li>Medium models (1000-5000 objects): ~50-100 MB</li> <li>Large models (&gt; 10,000 objects): ~500 MB+</li> </ul>"},{"location":"03_databases/3_8_xml_file_parser/#threading-note","title":"Threading Note\u00b6","text":"<p>The code includes commented-out <code>ThreadPoolExecutor</code> implementation for parallel edge parsing (lines 183-186 in source). This may be enabled in future versions for improved performance.</p>"},{"location":"03_databases/3_8_xml_file_parser/#example-complete-workflow","title":"Example: Complete Workflow\u00b6","text":"<p>This example demonstrates a complete workflow: loading, modifying, and saving a CIM model.</p>"},{"location":"03_databases/3_8_xml_file_parser/#troubleshooting","title":"Troubleshooting\u00b6","text":""},{"location":"03_databases/3_8_xml_file_parser/#common-issues","title":"Common Issues\u00b6","text":"<p>1. File Not Found</p> <pre><code>File model.xml not found. Defaulting to empty network graph\n</code></pre> <ul> <li>Verify the file path is correct</li> <li>Use absolute paths or paths relative to working directory</li> </ul> <p>2. Namespace Errors</p> <pre><code>Unable to parse &lt;Element...&gt;. This may be caused by an invalid namespace\n</code></pre> <ul> <li>Check that XML file has proper namespace declarations</li> <li>Verify CIM profile matches the XML file's CIM version</li> <li>Use the <code>namespaces</code> parameter to override if needed</li> </ul> <p>3. Class Not in Profile</p> <pre><code>ClassName not in data profile\n</code></pre> <ul> <li>Ensure the correct CIM profile is loaded</li> <li>Check if the XML uses a newer/older CIM version than the profile</li> <li>Adjust <code>CIMG_VALIDATION_LOG_LEVEL</code> to filter warnings</li> </ul> <p>4. UUID Parsing Warnings</p> <pre><code>Unable to parse URI. Check the IEC61970-301 serialization\n</code></pre> <ul> <li>Verify XML follows IEC 61970-301 standard</li> <li>Check <code>rdf:about</code> and <code>rdf:ID</code> format</li> <li>May occur with non-standard mRID formats (handled gracefully)</li> </ul>"},{"location":"03_databases/3_8_xml_file_parser/#references","title":"References\u00b6","text":"<ul> <li>IEC 61970-301: CIM RDF Schema</li> <li>RDF 1.1 Primer</li> <li>defusedxml Documentation</li> <li>CIM Profiles Overview</li> <li>FeederModel Usage</li> </ul>"},{"location":"03_databases/3_9_jsonld_file_parser/","title":"JSON-LD File Parser","text":"<p>[in progress]</p>"},{"location":"03_databases/3_9_jsonld_file_parser/#json-ld-file-parser","title":"JSON-LD File Parser\u00b6","text":""},{"location":"04_graph_models/4_1_graph_models/","title":"Graph Models Overview","text":"In\u00a0[1]: Copied! <pre>from mermaid import Mermaid\n</pre> from mermaid import Mermaid In\u00a0[3]: Copied! <pre>with open('./images/4_1_graph_model_inheritance.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/4_1_graph_model_inheritance.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) Out[3]: In\u00a0[\u00a0]: Copied! <pre>with open('./images/4_1_get_all_edges.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/4_1_get_all_edges.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) In\u00a0[4]: Copied! <pre>with open('./images/4_1_get_all_attributes.txt', 'r') as diagram:\n    diagram_text = diagram.read()\nMermaid(diagram_text)\n</pre> with open('./images/4_1_get_all_attributes.txt', 'r') as diagram:     diagram_text = diagram.read() Mermaid(diagram_text) Out[4]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"04_graph_models/4_1_graph_models/#graphmodel-overview","title":"GraphModel Overview\u00b6","text":""},{"location":"04_graph_models/4_1_graph_models/#intro-to-knowledge-graphs","title":"Intro to Knowledge Graphs\u00b6","text":"<p>Knowledge graphs are a way of storing and organizing complex information in a graph structure. In a knowledge graph, data is represented as nodes (entities) and edges (relationships) that connect these nodes. This structure makes it easier to visualize and analyze connections between different pieces of information.</p> <p>For example, in a knowledge graph representing a power grid:</p> <ul> <li><p>Graph nodes can represent components like transformers, substations, and generators.</p> </li> <li><p>Graph edges can represent relationships such as the connection between different components.</p> </li> </ul> <p>It is very important to understand that in this context graph nodes are not the same as electrical buses / nodes. Every bus, branch, and piece of equipment is a node in the knowledge graph.</p> <p>Below is a simple graphical representation an distribution line as a knowledge graph:</p> <p></p>"},{"location":"04_graph_models/4_1_graph_models/#intro-to-typed-property-graphs","title":"Intro to Typed Property Graphs\u00b6","text":"<p>The core functionality of the CIMantic Graphs interface is driven by a typed property graph interface in which the graph nodes and edges are strictly typed according to the particular object and its attributes and associations as given by UML structure of the Common Information Model. Typed property graphs are a specific kind of graph used in programming and database systems to model and manage complex data. Within the typed property graph, the following general rules apply:</p> <ol> <li><p>Nodes and Edges:</p> <ul> <li><p>Nodes represent entities (like transformers, substations, or generators).</p> </li> <li><p>Edges represent the relationships between these entities.</p> </li> </ul> </li> <li><p>Properties:</p> <ul> <li><p>Both nodes and edges can have properties. Properties are additional pieces of information such as names, capacity, or any other relevant attributes.</p> </li> <li><p>For example, a node representing an <code>ACLineSegment</code> will have properties like name and length.</p> </li> </ul> </li> <li><p>Types:</p> <ul> <li><p>Each node and edge has a type that defines what kind of entity or relationship it represents.</p> </li> <li><p>Types help in organizing and validating the data. For example, a node of type <code>ACLineSegment</code> might only have properties like name and length, while a node of type <code>PhotoVoltaicUnit</code> will have properties like name and rated capacity.</p> </li> </ul> </li> </ol> <p>In the figure above, each of the graph nodes are an object with a strict datatype, such as <code>ACLineSegment</code>, <code>Feeder</code>, and <code>Terminal</code>. Only object types defined within the CIM profile selected by the user are supported within the typed property graph. The graph nodes are linked together with edges of strict typing with specific names for each association. So, the edge <code>ACLineSegment</code> --[<code>ConductingEquipment.Terminals</code>]--&gt; <code>list(Terminal)</code> can only have a list of <code>Terminal</code> objects. A different object type, such as <code>Location</code> cannot be used in that edge.</p>"},{"location":"04_graph_models/4_1_graph_models/#graphmodel-base-class","title":"GraphModel Base Class\u00b6","text":"<p>Most of the core interfaces for interacting with bus-branch, node-breaker, and distribution feeders models are provided by the <code>GraphModel</code> base class, which is the parent software dataclass for the classes used for specific modeling needs. The structure of the GraphModel class and its attributes are explained in more detail below.</p>"},{"location":"04_graph_models/4_1_graph_models/#input-arguments","title":"Input Arguments\u00b6","text":"<p>The following parameters need to be specified when creating a GraphModel representation of the power system:</p> <ul> <li><p><code>connection</code>: An instance of <code>ConnectionInterface</code>, such as <code>XMLFile</code> or <code>GridappsdConnection</code></p> </li> <li><p><code>container</code>: An instance of the top-level <code>EquipmentContainer</code> such as <code>Feeder</code> from which the model will be built</p> </li> <li><p><code>distributed</code>: Boolean on whether a centralized or distributed graph should be built</p> </li> </ul> <p>The <code>GraphModel</code> class itself is an abstract class and does not contain an <code>__init__</code> method. The input arguments need to be passed to a child class of <code>GraphModel</code>, such as <code>FeederModel</code></p>"},{"location":"04_graph_models/4_1_graph_models/#graph","title":"Graph\u00b6","text":"<p>The <code>.graph</code> attribute of the GraphModel dataclass provides the interface to the typed property graph with all data contained in the network model.</p> <p>It is a dictionary typed first by class type (e.g. <code>cim.ACLineSegment</code>) and then by UUID of each element within the network model.</p> <p>All objects within the graph (if added using the API) are forced to have a unique UUID identifier.</p>"},{"location":"04_graph_models/4_1_graph_models/#object-types-in-the-graph","title":"Object Types in the <code>graph</code>\u00b6","text":"<p>The set of all equipment available in the graph can be obtained as the dictionary keys:</p> <pre>eq_types = list(network.graph.keys())\n</pre> <p>This will provide a list of dataclass types, such as</p> <p><code>[cim.ACLineSegment, cim.ConnectivityNode, cim.PowerTransformer, cim.Terminal]</code></p>"},{"location":"04_graph_models/4_1_graph_models/#object-ids-in-the-graph","title":"Object IDs in the <code>graph</code>\u00b6","text":"<p>The set of mRIDs of all equipment contained in the graph can be obtained as the dictionary keys of the graph of a particular class type:</p> <pre>eq_uuids = list(network.graph[cim.ACLineSegment].keys())\n</pre>"},{"location":"04_graph_models/4_1_graph_models/#objects-in-the-graph","title":"Objects in the <code>graph</code>\u00b6","text":"<p>Access to graph nodes (objects) is done via a loop or by reference to the UUID, as shown below.</p>"},{"location":"04_graph_models/4_1_graph_models/#example-1-access-to-objects-via-loop","title":"Example 1: Access to objects via loop\u00b6","text":"<p>The most direct method to access objects is via a loop, which covers most use cases</p> <pre># Find line named 634_645\nfor line in network.graph[cim.ACLineSegment].values():\n    if line.name == '634_635':\n        break\n</pre> <p>The .get() method can be used for more robust handling of empty fields:</p> <pre># Find lines with length &gt; 100:\nlong_lines = []\nfor line in network.graph.get(cim.ACLineSegment, {}).values():\n    if line.length &gt; 100:\n        long_lines.append(line)\n</pre>"},{"location":"04_graph_models/4_1_graph_models/#example-2-access-to-objects-via-uuid","title":"Example 2: Access to objects via UUID\u00b6","text":"<p>The other method is by directly invoking the mRID of the object as a UUID</p> <pre>line = network.graph[cim.ACLineSegment][UUID('4c04f838-62aa-475e-aefa-a63b7c889c13')]\n</pre>"},{"location":"04_graph_models/4_1_graph_models/#api-reference","title":"API Reference\u00b6","text":"<p>All classes based on GraphModel inherit the following methods:</p> <ul> <li><p><code>add_to_graph(object)</code> -</p> </li> <li><p><code>add_jsonld_to_graph(str)</code></p> </li> <li><p><code>get_all_edges(cim.ClassName)</code></p> </li> <li><p><code>get_object(mRID)</code></p> </li> <li><p><code>get_from_triple(object,attribute)</code></p> </li> <li><p><code>pprint(cim.ClassName)</code></p> </li> <li><p><code>upload()</code></p> </li> </ul>"},{"location":"04_graph_models/4_1_graph_models/#get_all_edges","title":"get_all_edges()\u00b6","text":"<p>The <code>.get_all_edges()</code> method is the core library method that enables the flexibility of CIM-Graph to query for CIM objects of any class and build the knowledge graph without custom queries.</p> <p>The arguments of the method are</p> <ul> <li>cim_class (type): The CIM class for which to retrieve edges (e.g. <code>cim.ACLineSegment</code>)</li> </ul> <p>The method does not return any values.</p>"},{"location":"04_graph_models/4_1_graph_models/#get_all_attributes","title":"get_all_attributes()\u00b6","text":"<p>The <code>.get_all_attributes()</code> method is similar to get_all_edges(), but does not create any new graph nodes. Instead, edges to new classes are represented as strings.</p> <p>The arguments of the method are</p> <ul> <li>cim_class (type): The CIM class for which to retrieve edges (e.g. <code>cim.ACLineSegment</code>)</li> </ul> <p>The method does not return any values.</p>"},{"location":"04_graph_models/4_1_graph_models/#get_object","title":"get_object()\u00b6","text":"<p>The <code>get_object()</code> method is used to retrieve an object from the database using its mRID.</p> <p>The arguments are</p> <ul> <li><p><code>mRID</code> (str): The mRID of the object to be retrieved.</p> </li> <li><p><code>graph</code> (dict[type, uuid]): Optional -- An existing graph to which the object should be added</p> </li> </ul>"},{"location":"04_graph_models/4_1_graph_models/#add_to_graph","title":"add_to_graph()\u00b6","text":"<p>The <code>.add_to_graph()</code> method adds a CIM object to the graph model (at both the type and UUID levels within the graph dictionary).</p> <p>The arguments are</p> <ul> <li>`</li> </ul>"},{"location":"04_graph_models/4_1_graph_models/#uml-diagrams","title":"UML Diagrams\u00b6","text":"<p>This section contains UML class and sequence diagrams summarizing the structure and methods offered by the GraphModel class.</p> <p>All diagrams are loaded from flat text using mermaid.js which can be imported using</p>"},{"location":"04_graph_models/4_1_graph_models/#graphmodel-class-inheritance","title":"GraphModel Class Inheritance\u00b6","text":"<p>The diagram below shows the dataclass fields and methods offered by the GraphModel base class and its children classes.</p>"},{"location":"04_graph_models/4_1_graph_models/#get_all_edges","title":"get_all_edges()\u00b6","text":"<p>The <code>.get_all_edges()</code> method invokes a similarly named method within the the ConnectionInterface, which performs the database-specific query. For improved processing, CIM-Graph generally uses parallel processing with sets of 100 objects queried for in each batch. The execution workflow is shown below</p>"},{"location":"04_graph_models/4_1_graph_models/#get_all_attributes","title":"get_all_attributes()\u00b6","text":"<p>The get_all_attributes method invokes a similarly named method within the the ConnectionInterface, which performs the database-specific query.The execution workflow is shown below</p>"},{"location":"04_graph_models/4_2_feeder_model/","title":"Feeder Model","text":"<p>This section contains description of distribution feeder modeling concepts and usage of the CIMantic Graphs <code>FeederModel</code> class for accessing CIM feeder models in a centralized and distributed manner.</p> <p>All diagrams within this page have been auto-generated using mermaid.js and the <code>cimgraph.utils</code> module of CIMantic Graphs, which can be imported using</p> In\u00a0[1]: Copied! <pre>from cimgraph import utils\nfrom mermaid import Mermaid\n</pre> from cimgraph import utils from mermaid import Mermaid <ul> <li><p><code>ConnectivityNode</code> used for 3-phase buses. Separate modeling of single-phase nodes not used</p> </li> <li><p><code>Terminal</code> used to connect conducting equipment to a bus</p> </li> <li><p><code>ACLineSegment</code> used for overhead lines, underground cables, and secondary triplex lines. Phasing represented using <code>ACLineSegmentPhase</code></p> </li> <li><p>Representation of downstream switching devices using <code>Recloser</code>, <code>Sectionaliser</code>, etc. Poletop <code>LinearShuntCompensator</code> and <code>RatioTapChanger</code> devices</p> </li> <li><p><code>EnergySource</code> slack bus at substation</p> </li> <li><p>Loads can be represented at medium voltage level or broken down into individual <code>EnergyConsumer</code> customers with split-phase <code>TransformerTank</code></p> </li> </ul> In\u00a0[2]: Copied! <pre>from cimgraph.models import FeederModel\n</pre> from cimgraph.models import FeederModel <p>The structure of the distribution network graphs and API methods are explained in the sections below</p> <p>The first step is to import the correct CIM profile to use and set the associated environment variable used by CIM-Graph. For an explanation of CIM profiles, see Profiles Overview</p> In\u00a0[3]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nimport cimgraph.data_profile.cimhub_2023 as cim\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' import cimgraph.data_profile.cimhub_2023 as cim <p>Next, use the <code>XMLFile</code> interface to open the XML file:</p> In\u00a0[4]: Copied! <pre>from cimgraph.databases import XMLFile\nfile = XMLFile(filename='../../tests/test_models/ieee13.xml')\n</pre> from cimgraph.databases import XMLFile file = XMLFile(filename='../../tests/test_models/ieee13.xml') <p>Finally, create a new <code>FeederModel</code> network class to load the feeder into the graph:</p> In\u00a0[5]: Copied! <pre>network = FeederModel(container=cim.Feeder(), connection=file)\n</pre> network = FeederModel(container=cim.Feeder(), connection=file) <p>The complete network model, including both forward and reverse associations between all objects in the model has now been loaded into the FeederModel graph.</p> <p>To demonstrate the structure of resulting FeederModel network, we can display a sample  breaker object:</p> In\u00a0[6]: Copied! <pre># Get first breaker in graph\nbreaker = network.first(cim.Breaker)\n# Display the line\nMermaid(utils.get_mermaid(breaker))\n</pre> # Get first breaker in graph breaker = network.first(cim.Breaker) # Display the line Mermaid(utils.get_mermaid(breaker)) Out[6]: <p>The first step is to import the correct CIM profile to use and set the associated environment variable used by CIM-Graph. For an explanation of CIM profiles, see Profiles Overview.</p> In\u00a0[7]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023'\nimport cimgraph.data_profile.cimhub_2023 as cim\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cimhub_2023' import cimgraph.data_profile.cimhub_2023 as cim <p>Next, use the interface class to your preferred database to authenticate and connect to the database.</p> In\u00a0[8]: Copied! <pre>from cimgraph.databases import BlazegraphConnection\nos.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql'\ndatabase = BlazegraphConnection()\n</pre> from cimgraph.databases import BlazegraphConnection os.environ['CIMG_URL'] = 'http://localhost:8889/bigdata/namespace/kb/sparql' database = BlazegraphConnection() <p>Next, create a CIM <code>Feeder</code> object with the correct model mRID. This can be done by a) directly creating the object or b) retrieving it from the database using the <code>.get_object()</code> method.</p> In\u00a0[9]: Copied! <pre>feeder = cim.Feeder(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\")\nprint(feeder)\n</pre> feeder = cim.Feeder(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\") print(feeder) <pre>{\"@id\": \"49ad8e07-3bf9-a4e2-cb8f-c3722f837b62\", \"@type\": \"Feeder\"}\n</pre> In\u00a0[10]: Copied! <pre>feeder = database.get_object(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\")\nprint(feeder)\n</pre> feeder = database.get_object(mRID=\"49AD8E07-3BF9-A4E2-CB8F-C3722F837B62\") print(feeder) <pre>{\"@id\": \"49ad8e07-3bf9-a4e2-cb8f-c3722f837b62\", \"@type\": \"Feeder\"}\n</pre> <p>Finally, create a new <code>FeederModel</code> class and pass in the feeder and database objects as the input arguments. This will authenticate with the database and load the base feeder topology into the graph</p> In\u00a0[11]: Copied! <pre>network = FeederModel(container=feeder, connection=database)\n</pre> network = FeederModel(container=feeder, connection=database) <p>To ensure performance on large models, only the minimum set of <code>Equipment</code>, <code>ConnectivityNode</code>, and <code>Terminal</code> objects are loaded into graph with only their UUID identifiers. All attributes are left as <code>None</code> or <code>[]</code> until the object classes are populated using the <code>.get_all_edges</code> method.</p> In\u00a0[12]: Copied! <pre># Get first breaker in graph\nbreaker = network.first(cim.Breaker)\n# Display the breaker\nMermaid(utils.get_mermaid(breaker))\n</pre> # Get first breaker in graph breaker = network.first(cim.Breaker) # Display the breaker Mermaid(utils.get_mermaid(breaker)) Out[12]: In\u00a0[13]: Copied! <pre>diagram_text = utils.get_mermaid_path(cim.Feeder, \"Equipments\", show_attributes=False)\ndiagram_text = utils.add_mermaid_path(cim.Feeder, \"ConnectivityNodes\", diagram_text, show_attributes=False)\ndiagram_text = utils.add_mermaid_path(cim.Feeder, \"NormalEnergizingSubstation\", diagram_text, show_attributes=False)\ndiagram_text = utils.add_mermaid_path(cim.Equipment, \"Measurements\", diagram_text, show_attributes=False)\ndiagram_text = utils.add_mermaid_path(cim.ConnectivityNode, \"Terminals\", diagram_text, show_attributes=False)\n\nMermaid(diagram_text)\n</pre> diagram_text = utils.get_mermaid_path(cim.Feeder, \"Equipments\", show_attributes=False) diagram_text = utils.add_mermaid_path(cim.Feeder, \"ConnectivityNodes\", diagram_text, show_attributes=False) diagram_text = utils.add_mermaid_path(cim.Feeder, \"NormalEnergizingSubstation\", diagram_text, show_attributes=False) diagram_text = utils.add_mermaid_path(cim.Equipment, \"Measurements\", diagram_text, show_attributes=False) diagram_text = utils.add_mermaid_path(cim.ConnectivityNode, \"Terminals\", diagram_text, show_attributes=False)  Mermaid(diagram_text) Out[13]: In\u00a0[14]: Copied! <pre>network.get_all_edges(cim.Breaker)\n</pre> network.get_all_edges(cim.Breaker) In\u00a0[15]: Copied! <pre># Display the same breaker\nMermaid(utils.get_mermaid(breaker))\n</pre> # Display the same breaker Mermaid(utils.get_mermaid(breaker)) Out[15]:"},{"location":"04_graph_models/4_2_feeder_model/#distribution-feeder-modeling","title":"Distribution Feeder Modeling\u00b6","text":""},{"location":"04_graph_models/4_2_feeder_model/#distribution-feeders-in-cim","title":"Distribution Feeders in CIM\u00b6","text":"<p>Full modeling of North American distribution circuits was introduced in CIM 17 to include include unbalanced medium-voltage networks, low-voltage customer-side equipment, DERs, and advanced metering infrastructure (AMI) usage points. An example of a very simple distribution feeder is shown and explained in detail below:</p> <p></p>"},{"location":"04_graph_models/4_2_feeder_model/#feedermodel-class","title":"FeederModel Class\u00b6","text":"<p>The <code>FeederModel</code> class in CIMantic Graphs provides the interface for users to access a single feeder at a time (in a manner similar to study tools such as EPRI OpenDSS or Eaton CYME). The class provides access to the typed property graph and API methods to read and write to a data source.</p> <p>It can be imported using</p>"},{"location":"04_graph_models/4_2_feeder_model/#loading-a-feedermodel-from-an-xml-file","title":"Loading a FeederModel from an XML File\u00b6","text":"<p>When working with small test cases (e.g. IEEE 13 and 123 bus models), it is possible to use CIMantic Graphs without any database and instead directly build the graph from an XML file. Note: large models (e.g. IEEE 8500) will see poor performance when reading directly from the XML (approx 2 minutes to load all triples and build the full network graph).</p>"},{"location":"04_graph_models/4_2_feeder_model/#loading-a-feedermodel-from-a-database","title":"Loading a FeederModel from a Database\u00b6","text":"<p>When working with large models (e.g. IEEE 8500/9500 node or utility networks), it is generally advisable to load the the models into a database and then use CIM-Graph to access the feeder via its internal API.</p>"},{"location":"04_graph_models/4_2_feeder_model/#feedermodelgraph","title":"FeederModel.graph\u00b6","text":"<p>The <code>.graph</code> attribute of the GraphModel dataclass provides the interface to the typed property graph with all data contained in the network model.</p> <p>It is a dictionary typed first by class type (e.g. <code>cim.ACLineSegment</code>) and then by UUID of each element within the network model.</p> <p>All objects within the graph (if added using the API) are forced to have a unique UUID identifier.</p>"},{"location":"04_graph_models/4_2_feeder_model/#graph-initialization","title":"Graph Initialization\u00b6","text":"<p>The CIM <code>Feeder</code> class is used to describe containment and naming of equipment and nodes within distribution feeders. For most applications, each feeder is described as having a single normal energizing substation that serves as the source for all downstream customers.</p>"},{"location":"04_graph_models/4_2_feeder_model/#graph-expansion","title":"Graph Expansion\u00b6","text":"<p>One of the key features of CIMantic graphs is the elimination of all custom database queries to access information regarding equipment, impedances, measurements etc. Instead, a single API method is used to extract all information about the</p> <p>The <code>.get_all_edges()</code> method is the core library method that enables the flexibility of CIM-Graph to query for CIM objects of any class and build the knowledge graph without custom queries.</p> <p>The arguments of the method are</p> <ul> <li>cim_class (type): The CIM class for which to retrieve edges (e.g. <code>cim.Breaker</code>)</li> </ul>"},{"location":"04_graph_models/4_3_node_breaker/","title":"Node Breaker","text":"<p>This section contains description of transmission node-breaker modeling concepts and usage of the CIMantic Graphs <code>NodeBreakerModel</code> class for accessing CIM feeder models in a centralized and distributed manner.</p> <p>All diagrams within this page have been auto-generated using mermaid.js and the <code>cimgraph.utils</code> module of CIMantic Graphs, which can be imported using</p> In\u00a0[1]: Copied! <pre>from cimgraph import utils\nfrom mermaid import Mermaid\n</pre> from cimgraph import utils from mermaid import Mermaid In\u00a0[2]: Copied! <pre># TODO: Provide sample Node Breaker Model diagram\n</pre> # TODO: Provide sample Node Breaker Model diagram <p>The first step is to import the correct CIM profile to use and set the associated environment variable used by CIM-Graph. For an explanation of CIM profiles, see Profiles Overview</p> In\u00a0[3]: Copied! <pre>import os\nos.environ['CIMG_CIM_PROFILE'] = 'cim17v40' # import and env var must match\n\nimport cimgraph.data_profile.cim17v40 as cim # import and env var must match\n</pre> import os os.environ['CIMG_CIM_PROFILE'] = 'cim17v40' # import and env var must match  import cimgraph.data_profile.cim17v40 as cim # import and env var must match <p>Next, use the <code>XMLFile</code> interface to open the XML file:</p> In\u00a0[4]: Copied! <pre>from cimgraph.databases import XMLFile\n\nfile = XMLFile(filename='../../sample_models/maple10nodebreaker.xml')\n</pre> from cimgraph.databases import XMLFile  file = XMLFile(filename='../../sample_models/maple10nodebreaker.xml') <p>If custom extensions are used, provide a namespaces dictionary mapping the prefix to the custom namespaces:</p> In\u00a0[5]: Copied! <pre>namespaces={'cim': 'http://iec.ch/TC57/CIM100#',\n            'gmdm': 'http://epri.com/gmdm/2025#',\n            'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n            'gad': 'http://gridappsd.org/CIM/extension#'}\n\nfile = XMLFile(filename='../../sample_models/maple10nodebreaker.xml',\n               namespaces=namespaces)\n</pre> namespaces={'cim': 'http://iec.ch/TC57/CIM100#',             'gmdm': 'http://epri.com/gmdm/2025#',             'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',             'gad': 'http://gridappsd.org/CIM/extension#'}  file = XMLFile(filename='../../sample_models/maple10nodebreaker.xml',                namespaces=namespaces) <p>Finally, create a new <code>NodeBreakerModel</code> network class to load the transmission model into the graph:</p> In\u00a0[6]: Copied! <pre>from cimgraph.models import NodeBreakerModel\n\nnetwork = NodeBreakerModel(container=None, connection=file)\n</pre> from cimgraph.models import NodeBreakerModel  network = NodeBreakerModel(container=None, connection=file) In\u00a0[7]: Copied! <pre># Get first breaker in graph\nbreaker = network.first(cim.Breaker)\n# Display the line\nMermaid(utils.get_mermaid(breaker))\n</pre> # Get first breaker in graph breaker = network.first(cim.Breaker) # Display the line Mermaid(utils.get_mermaid(breaker)) Out[7]: In\u00a0[8]: Copied! <pre>new_breaker = cim.Breaker(name='new_breaker', open=False)\nnetwork.add_to_graph(new_breaker)\n</pre> new_breaker = cim.Breaker(name='new_breaker', open=False) network.add_to_graph(new_breaker) In\u00a0[9]: Copied! <pre>network.delete(new_breaker)\n</pre> network.delete(new_breaker) In\u00a0[10]: Copied! <pre>network.modify(breaker, 'open', True, incremental_file='breaker_incremental.xml')\n</pre> network.modify(breaker, 'open', True, incremental_file='breaker_incremental.xml') In\u00a0[11]: Copied! <pre>from cimgraph import utils\n\nutils.write_xml(network, '../../sample_models/maple10nodebreaker_modified.xml')\nutils.write_json_ld(network, '../../sample_models/maple10nodebreaker_modified.jsonld')\n</pre> from cimgraph import utils  utils.write_xml(network, '../../sample_models/maple10nodebreaker_modified.xml') utils.write_json_ld(network, '../../sample_models/maple10nodebreaker_modified.jsonld') In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[12]: Copied! <pre>network = NodeBreakerModel(container=None, connection=file, distributed = True)\n</pre> network = NodeBreakerModel(container=None, connection=file, distributed = True) <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[12], line 1\n----&gt; 1 network = NodeBreakerModel(container=None, connection=file, distributed = True)\n\nFile &lt;string&gt;:10, in __init__(self, container, connection, distributed, graph, incrementals, __class_iter__, aggregate_lower_areas)\n\nFile ~/CIM-Graph/cimgraph/models/node_breaker_model.py:51, in NodeBreakerModel.__post_init__(self)\n     47 if self.connection is not None:    # Check if connection has been specified\n     48     # self.cim = self.connection.cim    # Set CIM data profile\n     49     if self.distributed:    # Check if distributed flag is true\n     50         # Build distributed network model\n---&gt; 51         self.initialize_distributed_model(self.container)\n     52     else:\n     53         # Otherwise build centralized network model\n     54         self.initialize_centralized_model(self.container)\n\nFile ~/CIM-Graph/cimgraph/models/node_breaker_model.py:65, in NodeBreakerModel.initialize_distributed_model(self, container)\n     63 def initialize_distributed_model(self, container: object) -&gt; None:\n     64     self.graph = {}\n---&gt; 65     self.add_to_graph(self.container)\n     66     self.distributed_areas = {}\n\nFile ~/CIM-Graph/cimgraph/models/graph_model.py:56, in GraphModel.add_to_graph(self, obj, graph)\n     54 if type(obj) not in graph:\n     55     graph[type(obj)] = {}\n---&gt; 56 if obj.identifier not in graph[type(obj)]:\n     57     graph[type(obj)][obj.identifier] = obj\n\nAttributeError: 'NoneType' object has no attribute 'identifier'</pre> In\u00a0[\u00a0]: Copied! <pre>for sr_area in network.distributed_areas[cim.SubGeographicalRegion].values():\n    print(\"subregion\", sr_area.container.name)\n    for sub_area in sr_area.distributed_areas[cim.Substation].values():\n        print(\"substation\", sub_area.container.name)\n\n        for vl_area in sub_area.distributed_areas[cim.VoltageLevel].values():\n            print(\"voltage level\", vl_area.container.name)\n            \n        for feeder_area in sub_area.distributed_areas[cim.Feeder].values():\n            print(\"feeder\", feeder_area.container.name, \"contains PV aggregates\")\n            feeder_area.get_all_edges(cim.PowerElectronicsConnection)\n            feeder_area.get_all_edges(cim.PhotoVoltaicUnit)\n            if cim.PowerElectronicsConnection in feeder_area.graph:\n                for pv in feeder_area.graph[cim.PowerElectronicsConnection].values():\n                    print(pv.name, float(pv.p)/1000000, \"MW\")\n            else:\n                print(\"none\")\n</pre> for sr_area in network.distributed_areas[cim.SubGeographicalRegion].values():     print(\"subregion\", sr_area.container.name)     for sub_area in sr_area.distributed_areas[cim.Substation].values():         print(\"substation\", sub_area.container.name)          for vl_area in sub_area.distributed_areas[cim.VoltageLevel].values():             print(\"voltage level\", vl_area.container.name)                      for feeder_area in sub_area.distributed_areas[cim.Feeder].values():             print(\"feeder\", feeder_area.container.name, \"contains PV aggregates\")             feeder_area.get_all_edges(cim.PowerElectronicsConnection)             feeder_area.get_all_edges(cim.PhotoVoltaicUnit)             if cim.PowerElectronicsConnection in feeder_area.graph:                 for pv in feeder_area.graph[cim.PowerElectronicsConnection].values():                     print(pv.name, float(pv.p)/1000000, \"MW\")             else:                 print(\"none\")  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"04_graph_models/4_3_node_breaker/#node-breaker-models","title":"Node Breaker Models\u00b6","text":""},{"location":"04_graph_models/4_3_node_breaker/#transmission-network-models-in-cim","title":"Transmission Network Models in CIM\u00b6","text":"<p>CIM was originally designed to support full node-breaker modeling of transmission network models and substations</p>"},{"location":"04_graph_models/4_3_node_breaker/#loading-a-feedermodel-from-an-xml-file","title":"Loading a FeederModel from an XML File\u00b6","text":"<p>It is possible to use CIMantic Graphs without any database and instead directly build the graph from an XML file.</p>"},{"location":"04_graph_models/4_3_node_breaker/#modifying-files","title":"Modifying Files\u00b6","text":"<p>Objects can be created, modified, or deleted using the <code>.add_to_graph(object)</code>, <code>.delete(object)</code>,  and <code>.create('incremental_file.xml')</code> methods</p>"},{"location":"04_graph_models/4_3_node_breaker/#saving-to-a-file","title":"Saving to a File\u00b6","text":"<p>Use the <code>utils.write_xml()</code> and <code>utils.write_json_ld</code> methods to save modified network to file</p>"},{"location":"04_graph_models/4_3_node_breaker/#advanced-concepts-distributed-modeling","title":"Advanced Concepts - Distributed Modeling\u00b6","text":"<p>These features are still in development and intended to provide a preview of planned capabilities. Under certain use cases, users may wish to instantiate a new typed property graph for each substation and voltage level as its own standalone network.</p>"},{"location":"04_graph_models/4_4_bus_branch/","title":"Bus Branch","text":"<p>Import all required libraries for data profile, connection parameters, database, and <code>BusBranchModel</code>:</p> In\u00a0[\u00a0]: Copied! <pre>import cimgraph.data_profile.cim17v40 as cim\nfrom cimgraph.models import BusBranchModel\n</pre> import cimgraph.data_profile.cim17v40 as cim from cimgraph.models import BusBranchModel In\u00a0[\u00a0]: Copied! <pre># Blazegraph Connection\nparams = ConnectionParameters(url = \"http://localhost:8889/bigdata/namespace/kb/sparql\",\n                              cim_profile='cim17v40', iec61970_301=8)\nblazegraph = BlazegraphConnection(params)\n</pre> # Blazegraph Connection params = ConnectionParameters(url = \"http://localhost:8889/bigdata/namespace/kb/sparql\",                               cim_profile='cim17v40', iec61970_301=8) blazegraph = BlazegraphConnection(params) <p>Create CIM EquipmentContainer object:</p> In\u00a0[\u00a0]: Copied! <pre>model_mrid = \"1783D2A8-1204-4781-A0B4-7A73A2FA6038\" #IEEE 118 Bus\ncontainer = cim.ConnectivityNodeContainer(mRID=model_mrid)\n</pre> model_mrid = \"1783D2A8-1204-4781-A0B4-7A73A2FA6038\" #IEEE 118 Bus container = cim.ConnectivityNodeContainer(mRID=model_mrid) In\u00a0[\u00a0]: Copied! <pre>network = BusBranchModel(connection=blazegraph, container=container, distributed=False)\n</pre> network = BusBranchModel(connection=blazegraph, container=container, distributed=False) In\u00a0[\u00a0]: Copied! <pre>network.get_all_edges(cim.ACLineSegment)\nnetwork.pprint(cim.ACLineSegment)\n</pre> network.get_all_edges(cim.ACLineSegment) network.pprint(cim.ACLineSegment) In\u00a0[1]: Copied! <pre>cim_profile = 'cimhub_2023'\ncim = importlib.import_module('cimgraph.data_profile.' + cim_profile)\n\n# RDFLib File Reader Connection\nparams = ConnectionParameters(filename=\"../cimgraph/tests/test_models/IEEE118_CIM.xml\", cim_profile='cimhub_2023', iec61970_301=8)\nrdf = RDFlibConnection(params)\n\nmodel_mrid = \"1783D2A8-1204-4781-A0B4-7A73A2FA6038\" #IEEE 118 Bus\"\ncontainer = cim.ConnectivityNodeContainer(mRID = model_mrid)\nnetwork = BusBranchModel(connection=rdf, container=container, distributed=False)\n</pre> cim_profile = 'cimhub_2023' cim = importlib.import_module('cimgraph.data_profile.' + cim_profile)  # RDFLib File Reader Connection params = ConnectionParameters(filename=\"../cimgraph/tests/test_models/IEEE118_CIM.xml\", cim_profile='cimhub_2023', iec61970_301=8) rdf = RDFlibConnection(params)  model_mrid = \"1783D2A8-1204-4781-A0B4-7A73A2FA6038\" #IEEE 118 Bus\" container = cim.ConnectivityNodeContainer(mRID = model_mrid) network = BusBranchModel(connection=rdf, container=container, distributed=False) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[1], line 2\n      1 cim_profile = 'cimhub_2023'\n----&gt; 2 cim = importlib.import_module('cimgraph.data_profile.' + cim_profile)\n      4 # RDFLib File Reader Connection\n      5 params = ConnectionParameters(filename=\"../cimgraph/tests/test_models/IEEE118_CIM.xml\", cim_profile='cimhub_2023', iec61970_301=8)\n\nNameError: name 'importlib' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>load_nodes = []\ngen_nodes = []\ncap_nodes = []\ninv_nodes = []\n\nfor node in network.graph[cim.ConnectivityNode].values():\n    print(\"\\n listing equipment for node\", node.name)\n    for terminal in node.Terminals:\n        equipment = terminal.ConductingEquipment\n        # print(equipment.__class__.__name__, equipment.mRID)\n        type = equipment.__class__.__name__\n        load_types = ['EnergyConsumer', 'ConformLoad', 'NonConformLoad']\n        gen_types = ['RotatingMachine', 'SynchronousMachine', 'AsynchronousMachine']\n        cap_types = ['ShuntCompensator', 'LinearShuntCompensator']\n        inv_types = ['PowerElectronicsConnection']\n\n\n\n        if type in load_types:\n            load_nodes.append(node.mRID)\n        if type in gen_types:\n            print('gen node')\n        if type in \n        \n</pre> load_nodes = [] gen_nodes = [] cap_nodes = [] inv_nodes = []  for node in network.graph[cim.ConnectivityNode].values():     print(\"\\n listing equipment for node\", node.name)     for terminal in node.Terminals:         equipment = terminal.ConductingEquipment         # print(equipment.__class__.__name__, equipment.mRID)         type = equipment.__class__.__name__         load_types = ['EnergyConsumer', 'ConformLoad', 'NonConformLoad']         gen_types = ['RotatingMachine', 'SynchronousMachine', 'AsynchronousMachine']         cap_types = ['ShuntCompensator', 'LinearShuntCompensator']         inv_types = ['PowerElectronicsConnection']            if type in load_types:             load_nodes.append(node.mRID)         if type in gen_types:             print('gen node')         if type in           In\u00a0[\u00a0]: Copied! <pre>network.get_all_edges(cim.EnergyConsumer)\nnetwork.get_all_edges(cim.ConformLoad)\nnetwork.get_all_edges(cim.NonConformLoad)\n\nfor load in network.graph[cim.EnergyConsumer].values():\n    print(f\"name:{load.name}, bus:{load.Terminals[0].ConnectivityNode.name}, p:{float(load.p)/1e6} MW, q:{float(load.q)/1e6} MVAr\")\n</pre> network.get_all_edges(cim.EnergyConsumer) network.get_all_edges(cim.ConformLoad) network.get_all_edges(cim.NonConformLoad)  for load in network.graph[cim.EnergyConsumer].values():     print(f\"name:{load.name}, bus:{load.Terminals[0].ConnectivityNode.name}, p:{float(load.p)/1e6} MW, q:{float(load.q)/1e6} MVAr\")  In\u00a0[\u00a0]: Copied! <pre>network.get_all_edges(cim.BaseVoltage)\nload_by_voltage = {}\nfor id in network.graph[cim.BaseVoltage].values():\n    nomv = id.nominalVoltage\n    load_by_voltage[id.mRID] = []\n    for equipment in id.ConductingEquipment:\n        type = equipment.__class__.__name__\n        load_types = ['EnergyConsumer', 'ConformLoad', 'NonConformLoad']\n        if type in load_types:\n            load_by_voltage[id.mRID].append(equipment)\n</pre> network.get_all_edges(cim.BaseVoltage) load_by_voltage = {} for id in network.graph[cim.BaseVoltage].values():     nomv = id.nominalVoltage     load_by_voltage[id.mRID] = []     for equipment in id.ConductingEquipment:         type = equipment.__class__.__name__         load_types = ['EnergyConsumer', 'ConformLoad', 'NonConformLoad']         if type in load_types:             load_by_voltage[id.mRID].append(equipment)  In\u00a0[\u00a0]: Copied! <pre>for id in list(load_by_voltage.keys()):\n    nomv = network.graph[cim.BaseVoltage][id].nominalVoltage\n    print(nomv)\n\n    for load in load_by_voltage[id]:\n        print(load.name, load.p, load.q, load.Terminals[0].ConnectivityNode.name)\n</pre> for id in list(load_by_voltage.keys()):     nomv = network.graph[cim.BaseVoltage][id].nominalVoltage     print(nomv)      for load in load_by_voltage[id]:         print(load.name, load.p, load.q, load.Terminals[0].ConnectivityNode.name)"},{"location":"04_graph_models/4_4_bus_branch/#bus-branch-transmission-modeling","title":"Bus-Branch Transmission Modeling\u00b6","text":""},{"location":"04_graph_models/4_4_bus_branch/#creating-a-busbranchmodel","title":"Creating a BusBranchModel\u00b6","text":""},{"location":"04_graph_models/4_5_distributed_area/","title":"Distributed Area","text":""},{"location":"04_graph_models/4_5_distributed_area/#distributed-topological-areas","title":"Distributed Topological Areas\u00b6","text":""},{"location":"05_utils/5_1_file_writers/","title":"File Writers","text":""},{"location":"05_utils/5_1_file_writers/#file-writers","title":"File Writers\u00b6","text":""},{"location":"05_utils/5_2_get_all_data/","title":"Get All Data","text":"In\u00a0[1]: Copied! <pre>from mermaid import Mermaid\n</pre> from mermaid import Mermaid In\u00a0[2]: Copied! <pre>text = '''zenuml\n    title get_all_line_data(network)\n    @Actor User\n    @AzureFunction utils\n    @PubSub GraphModel\n    @AzureBackup Database\n   \n    \n    User -&gt; utils.get_all_line_data(network) {\n        GraphModel.get_all_edges(cim.ACLineSegment) {\n            Database.query {\n                return objects\n            }  \n        }\n        GraphModel.get_all_edges(cim.ACLineSegmentPhase) {\n            Database.query {\n                return objects\n            }\n        }\n        GraphModel.get_all_edges(cim.PhaseImpedanceData) {\n            Database.query {\n                return objects\n            }\n        }\n    }\n'''\n</pre> text = '''zenuml     title get_all_line_data(network)     @Actor User     @AzureFunction utils     @PubSub GraphModel     @AzureBackup Database              User -&gt; utils.get_all_line_data(network) {         GraphModel.get_all_edges(cim.ACLineSegment) {             Database.query {                 return objects             }           }         GraphModel.get_all_edges(cim.ACLineSegmentPhase) {             Database.query {                 return objects             }         }         GraphModel.get_all_edges(cim.PhaseImpedanceData) {             Database.query {                 return objects             }         }     } ''' <pre><code>zenuml\n    title get_all_line_data(network)\n    @Actor User\n    @AzureFunction utils\n    @PubSub GraphModel\n    @AzureBackup Database\n   \n    \n    User -&gt; utils.get_all_line_data(network) {\n        GraphModel.get_all_edges(cim.ACLineSegment) {\n            Database.query {\n                return objects\n            }  \n        }\n        GraphModel.get_all_edges(cim.ACLineSegmentPhase) {\n            Database.query {\n                return objects\n            }\n        }\n        GraphModel.get_all_edges(cim.PhaseImpedanceData) {\n            Database.query {\n                return objects\n            }\n        }\n    }\n</code></pre> In\u00a0[3]: Copied! <pre>Mermaid(text)\n</pre> Mermaid(text) Out[3]:"},{"location":"05_utils/5_2_get_all_data/#get-all-data-shortcuts","title":"Get All Data Shortcuts\u00b6","text":""},{"location":"05_utils/5_3_mermaid/","title":"Mermaid Diagrams","text":""},{"location":"05_utils/5_3_mermaid/#mermaid-diagramming","title":"Mermaid Diagramming\u00b6","text":""}]}