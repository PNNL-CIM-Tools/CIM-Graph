from __future__ import annotations
from dataclasses import dataclass, field
from typing import Optional
from enum import Enum
from uuid import UUID, uuid4
from random import Random
import json
import logging
_log = logging.getLogger(__name__)
'''
    Annotated CIMantic Graphs data profile for cim17v40
    Generated by CIMTool http://cimtool.org
'''
@dataclass
class Identity():
    '''
    This is the new root class from CIM 18 to provide common identificationcim17v40
    for all classes needing identification and naming attributes.
    IdentifiedObject is now a child class of Identity.
    mRID is superseded by Identity.identifier, which is typed to be a UUID.
    '''
    identifier: Optional[ str | UUID ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '1',
            'maxOccurs': '1'
        })
    # Override python __repr__ method with JSON-LD representation
    # This is needed to avoid infinite loops in object previews
    def __repr__(self) -> str:
        return json.dumps({'@id': f'{str(self.identifier)}', '@type': f'{self.__class__.__name__}'})
    
    # Override python string for printing with JSON representation
    def __str__(self) -> str:
        # Create JSON-LD dump with repr and all attributes
        dump = dict(json.loads(self.__repr__()) | self.__dict__)
        attribute_list = list(self.__dataclass_fields__.keys())
        for attribute in attribute_list:
            if dump[attribute] is None or dump[attribute] == []:
                # Delete attributes from print that are empty
                del dump[attribute]
            elif type[dump[attribute]] != str:
                # Reformat all attributes as string for JSON
                dump[attribute] = str(dump[attribute])
        # Fix python ' vs JSON "
        dump = str(dump).replace('\'','\"' )
        # Add 4 spaces indentation
        dump = json.dumps(json.loads(dump), indent=4)
        return dump
    
    # Create UUID from inconsistent mRIDs
    def uuid(self, mRID:str = None, name:str = None) -> UUID:
        invalid_mrid = False
        # If mRID is specified, try creating from UUID from mRID
        if mRID is not None:
            try:
                self.identifier = UUID(mRID.strip('_').lower(), version=4)
            except:
                invalid_mrid = True
                name = mRID
                _log.warning(f'mRID {mRID} not a valid UUID, generating new UUID')
        # Otherwise, build UUID using unique name as a seed
        elif invalid_mrid or name is not None:
            seedStr = f"{self.__class__.__name__}:{name}"
            randomGenerator = Random(seedStr)
            self.identifier = UUID(int=randomGenerator.getrandbits(128), version=4)
        else:
            self.identifier = uuid4()
        if 'mRID' in self.__dataclass_fields__:
            if mRID is not None:
                self.mRID = mRID
            else:
                self.mRID = str(self.identifier)
        
@dataclass(repr=False)
class IdentifiedObject(Identity):
    '''
    This is a root class to provide common identification for all classes needing
    identification and naming attributes.
    '''
    mRID: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Master resource identifier issued by a model authority. The mRID is unique
    within an exchange context. Global uniqueness is easily achieved by using
    a UUID, as specified in RFC 4122, for the mRID. The use of UUID is strongly
    recommended.
    For CIMXML data files in RDF syntax conforming to IEC 61970-552, the mRID
    is mapped to rdf:ID or rdf:about attributes that identify CIM object elements.
    '''
    aliasName: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The aliasName is free text human readable name of the object alternative
    to IdentifiedObject.name. It may be non unique and may not correlate to
    a naming hierarchy.
    The attribute aliasName is retained because of backwards compatibility
    between CIM relases. It is however recommended to replace aliasName with
    the Name class as aliasName is planned for retirement at a future time.
    '''
    description: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The description is a free human readable text describing or naming the
    object. It may be non unique and may not correlate to a naming hierarchy.
    '''
    name: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The name is any free human readable and possibly non unique text naming
    the object.
    '''
@dataclass(repr=False)
class ACDCTerminal(IdentifiedObject):
    '''
    An electrical connection point (AC or DC) to a piece of conducting equipment.
    Terminals are connected at physical connection points called connectivity
    nodes.
    '''
    connected: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The connected status is related to a bus-branch model and the topological
    node to terminal relation. True implies the terminal is connected to the
    related topological node and false implies it is not.
    In a bus-branch model, the connected status is used to tell if equipment
    is disconnected without having to change the connectivity described by
    the topological node to terminal relation. A valid case is that conducting
    equipment can be connected in one end and open in the other. In particular
    for an AC line segment, where the reactive line charging can be significant,
    this is a relevant case.
    '''
    sequenceNumber: Optional[ int ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The orientation of the terminal connections for a multiple terminal conducting
    equipment. The sequence numbering starts with 1 and additional terminals
    should follow in increasing order. The first terminal is the "starting
    point" for a two terminal branch.
    '''
    BusNameMarker: Optional[ str | BusNameMarker ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'BusNameMarker.Terminal'
        })
    '''
    The bus name marker used to name the bus (topological node).
    '''
    Measurements: list[ str | Measurement ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Measurement.Terminal'
        })
    '''
    Measurements associated with this terminal defining where the measurement
    is placed in the network topology. It may be used, for instance, to capture
    the sensor position, such as a voltage transformer (PT) at a busbar or
    a current transformer (CT) at the bar between a breaker and an isolator.
    '''
@dataclass(repr=False)
class Terminal(ACDCTerminal):
    '''
    An AC electrical connection point to a piece of conducting equipment. Terminals
    are connected at physical connection points called connectivity nodes.
    '''
    phases: Optional[ str | PhaseCode ] = field(
        default = None,
        metadata = {
            'type': 'enumeration',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Represents the normal network phasing condition. If the attribute is missing,
    three phases (ABC) shall be assumed, except for terminals of grounding
    classes (specializations of EarthFaultCompensator, GroundDisconnector,
    and Ground) which will be assumed to be N. Therefore, phase code ABCN is
    explicitly declared when needed, e.g. for star point grounding equipment.
    The phase code on terminals connecting same ConnectivityNode or same TopologicalNode
    as well as for equipment between two terminals shall be consistent.
    '''
    ConductingEquipment: Optional[ str | ConductingEquipment ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'ConductingEquipment.Terminals'
        })
    '''
    The conducting equipment of the terminal. Conducting equipment have terminals
    that may be connected to other conducting equipment terminals via connectivity
    nodes or topological nodes.
    '''
@dataclass(repr=False)
class BusNameMarker(IdentifiedObject):
    '''
    Used to apply user standard names to TopologicalNodes. Associated with
    one or more terminals that are normally connected with the bus name. The
    associated terminals are normally connected by non-retained switches. For
    a ring bus station configuration, all BusbarSection terminals in the ring
    are typically associated. For a breaker and a half scheme, both BusbarSections
    would normally be associated. For a ring bus, all BusbarSections would
    normally be associated. For a "straight" busbar configuration, normally
    only the main terminal at the BusbarSection would be associated.
    '''
@dataclass(repr=False)
class Measurement(IdentifiedObject):
    '''
    A Measurement represents any measured, calculated or non-measured non-calculated
    quantity. Any piece of equipment may contain Measurements, e.g. a substation
    may have temperature measurements and door open indications, a transformer
    may have oil temperature and tank pressure measurements, a bay may contain
    a number of power flow measurements and a Breaker may contain a switch
    status measurement.
    The PSR - Measurement association is intended to capture this use of Measurement
    and is included in the naming hierarchy based on EquipmentContainer. The
    naming hierarchy typically has Measurements as leaves, e.g. Substation-VoltageLevel-Bay-Switch-Measurement.
    Some Measurements represent quantities related to a particular sensor location
    in the network, e.g. a voltage transformer (VT) or potential transformer
    (PT) at a busbar or a current transformer (CT) at the bar between a breaker
    and an isolator. The sensing position is not captured in the PSR - Measurement
    association. Instead it is captured by the Measurement - Terminal association
    that is used to define the sensing location in the network topology. The
    location is defined by the connection of the Terminal to ConductingEquipment.
    If both a Terminal and PSR are associated, and the PSR is of type ConductingEquipment,
    the associated Terminal should belong to that ConductingEquipment instance.
    When the sensor location is needed both Measurement-PSR and Measurement-Terminal
    are used. The Measurement-Terminal association is never used alone.
    '''
    measurementType: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Specifies the type of measurement. For example, this specifies if the measurement
    represents an indoor temperature, outdoor temperature, bus voltage, line
    flow, etc.
    When the measurementType is set to "Specialization", the type of Measurement
    is defined in more detail by the specialized class which inherits from
    Measurement.
    '''
    Terminal: Optional[ str | ACDCTerminal ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'ACDCTerminal.Measurements'
        })
    '''
    One or more measurements may be associated with a terminal in the network.
    '''
@dataclass(repr=False)
class PowerSystemResource(IdentifiedObject):
    '''
    A power system resource (PSR) can be an item of equipment such as a switch,
    an equipment container containing many individual items of equipment such
    as a substation, or an organisational entity such as sub-control area.
    Power system resources can have measurements associated.
    '''
@dataclass(repr=False)
class ACLineSegmentPhase(PowerSystemResource):
    '''
    Represents a single wire of an alternating current line segment.
    '''
    sequenceNumber: Optional[ int ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Number designation for this line segment phase. Each line segment phase
    within a line segment should have a unique sequence number. This is useful
    for unbalanced modelling to bind the mathematical model (PhaseImpedanceData
    of PerLengthPhaseImpedance) with the connectivity model (this class) and
    the physical model (WirePosition) without tight coupling.
    '''
    phase: Optional[ str | SinglePhaseKind ] = field(
        default = None,
        metadata = {
            'type': 'enumeration',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': ''
        })
    '''
    The phase connection of the wire at both ends.
    '''
    ACLineSegment: Optional[ str | ACLineSegment ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'ACLineSegment.ACLineSegmentPhases'
        })
    '''
    The line segment to which the phase belongs.
    '''
@dataclass(repr=False)
class Equipment(PowerSystemResource):
    '''
    The parts of a power system that are physical devices, electronic or mechanical.
    '''
    aggregate: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The aggregate flag provides an alternative way of representing an aggregated
    (equivalent) element. It is applicable in cases when the dedicated classes
    for equivalent equipment do not have all of the attributes necessary to
    represent the required level of detail. In case the flag is set to “true”
    the single instance of equipment represents multiple pieces of equipment
    that have been modelled together as an aggregate equivalent obtained by
    a network reduction procedure. Examples would be power transformers or
    synchronous machines operating in parallel modelled as a single aggregate
    power transformer or aggregate synchronous machine.
    The attribute is not used for EquivalentBranch, EquivalentShunt and EquivalentInjection.
    '''
    inService: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Specifies the availability of the equipment. True means the equipment is
    available for topology processing, which determines if the equipment is
    energized or not. False means that the equipment is treated by network
    applications as if it is not in the model.
    '''
    networkAnalysisEnabled: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The equipment is enabled to participate in network analysis. If unspecified,
    the value is assumed to be true.
    '''
    normallyInService: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Specifies the availability of the equipment under normal operating conditions.
    True means the equipment is available for topology processing, which determines
    if the equipment is energized or not. False means that the equipment is
    treated by network applications as if it is not in the model.
    '''
@dataclass(repr=False)
class ConductingEquipment(Equipment):
    '''
    The parts of the AC power system that are designed to carry current or
    that are conductively connected through terminals.
    '''
@dataclass(repr=False)
class Conductor(ConductingEquipment):
    '''
    Combination of conducting material with consistent electrical characteristics,
    building a single electrical system, used to carry current between points
    in the power system.
    '''
    length: Optional[ float | Length ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Segment length for calculating line section capabilities.
    '''
@dataclass(repr=False)
class ACLineSegment(Conductor):
    '''
    A wire or combination of wires, with consistent electrical characteristics,
    building a single electrical system, used to carry alternating current
    between points in the power system.
    For symmetrical, transposed three phase lines, it is sufficient to use
    attributes of the line segment, which describe impedances and admittances
    for the entire length of the segment. Additionally impedances can be computed
    by using length and associated per length impedances.
    The BaseVoltage at the two ends of ACLineSegments in a Line shall have
    the same BaseVoltage.nominalVoltage. However, boundary lines may have slightly
    different BaseVoltage.nominalVoltages and variation is allowed. Larger
    voltage difference in general requires use of an equivalent branch.
    '''
    b0ch: Optional[ float | Susceptance ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Zero sequence shunt (charging) susceptance, uniformly distributed, of the
    entire line section.
    '''
    bch: Optional[ float | Susceptance ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Positive sequence shunt (charging) susceptance, uniformly distributed,
    of the entire line section. This value represents the full charging over
    the full length of the line.
    '''
    g0ch: Optional[ float | Conductance ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Zero sequence shunt (charging) conductance, uniformly distributed, of the
    entire line section.
    '''
    gch: Optional[ float | Conductance ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Positive sequence shunt (charging) conductance, uniformly distributed,
    of the entire line section.
    '''
    r: Optional[ float | Resistance ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Positive sequence series resistance of the entire line section.
    '''
    r0: Optional[ float | Resistance ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Zero sequence series resistance of the entire line section.
    '''
    shortCircuitEndTemperature: Optional[ float | Temperature ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Maximum permitted temperature at the end of SC for the calculation of minimum
    short-circuit currents. Used for short circuit data exchange according
    to IEC 60909.
    '''
    x: Optional[ float | Reactance ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Positive sequence series reactance of the entire line section.
    '''
    x0: Optional[ float | Reactance ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Zero sequence series reactance of the entire line section.
    '''
    ACLineSegmentPhases: list[ str | ACLineSegmentPhase ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'ACLineSegmentPhase.ACLineSegment'
        })
    '''
    The line segment phases which belong to the line segment.
    '''
class PhaseCode( Enum ):
    '''
    An unordered enumeration of phase identifiers. Allows designation of phases
    for both transmission and distribution equipment, circuits and loads. The
    enumeration, by itself, does not describe how the phases are connected
    together or connected to ground. Ground is not explicitly denoted as a
    phase.
    Residential and small commercial loads are often served from single-phase,
    or split-phase, secondary circuits. For the example of s12N, phases 1 and
    2 refer to hot wires that are 180 degrees out of phase, while N refers
    to the neutral wire. Through single-phase transformer connections, these
    secondary circuits may be served from one or two of the primary phases
    A, B, and C. For three-phase loads, use the A, B, C phase codes instead
    of s12N.
    The integer values are from IEC 61968-9 to support revenue metering applications.
    '''
    A = 'A'
    '''
    Phase A.
    '''
    AB = 'AB'
    '''
    Phases A and B.
    '''
    ABC = 'ABC'
    '''
    Phases A, B, and C.
    '''
    ABCN = 'ABCN'
    '''
    Phases A, B, C, and N.
    '''
    ABN = 'ABN'
    '''
    Phases A, B, and neutral.
    '''
    AC = 'AC'
    '''
    Phases A and C.
    '''
    ACN = 'ACN'
    '''
    Phases A, C and neutral.
    '''
    AN = 'AN'
    '''
    Phases A and neutral.
    '''
    B = 'B'
    '''
    Phase B.
    '''
    BC = 'BC'
    '''
    Phases B and C.
    '''
    BCN = 'BCN'
    '''
    Phases B, C, and neutral.
    '''
    BN = 'BN'
    '''
    Phases B and neutral.
    '''
    C = 'C'
    '''
    Phase C.
    '''
    CN = 'CN'
    '''
    Phases C and neutral.
    '''
    N = 'N'
    '''
    Neutral phase.
    '''
    X = 'X'
    '''
    Unknown non-neutral phase.
    '''
    XN = 'XN'
    '''
    Unknown non-neutral phase plus neutral.
    '''
    XY = 'XY'
    '''
    Two unknown non-neutral phases.
    '''
    XYN = 'XYN'
    '''
    Two unknown non-neutral phases plus neutral.
    '''
    none = 'none'
    '''
    No phases specified.
    '''
    s1 = 's1'
    '''
    Secondary phase 1.
    '''
    s12 = 's12'
    '''
    Secondary phase 1 and 2.
    '''
    s12N = 's12N'
    '''
    Secondary phases 1, 2, and neutral.
    '''
    s1N = 's1N'
    '''
    Secondary phase 1 and neutral.
    '''
    s2 = 's2'
    '''
    Secondary phase 2.
    '''
    s2N = 's2N'
    '''
    Secondary phase 2 and neutral.
    '''
class SinglePhaseKind( Enum ):
    '''
    Enumeration of single phase identifiers. Allows designation of single phases
    for both transmission and distribution equipment, circuits and loads.
    '''
    A = 'A'
    '''
    Phase A.
    '''
    B = 'B'
    '''
    Phase B.
    '''
    C = 'C'
    '''
    Phase C.
    '''
    N = 'N'
    '''
    Neutral.
    '''
    s1 = 's1'
    '''
    Secondary phase 1.
    '''
    s2 = 's2'
    '''
    Secondary phase 2.
    '''
@dataclass
class Susceptance():
    value: float = field(default=None)
    '''
    Imaginary part of admittance.
    '''
@dataclass
class Length():
    value: float = field(default=None)
    '''
    Unit of length. It shall be a positive value or zero.
    '''
@dataclass
class Reactance():
    value: float = field(default=None)
    '''
    Reactance (imaginary part of impedance), at rated frequency.
    '''
@dataclass
class Temperature():
    value: float = field(default=None)
    '''
    Value of temperature in degrees Celsius.
    '''
@dataclass
class Conductance():
    value: float = field(default=None)
    '''
    Factor by which voltage must be multiplied to give corresponding power
    lost from a circuit. Real part of admittance.
    '''
@dataclass
class Resistance():
    value: float = field(default=None)
    '''
    Resistance (real part of impedance).
    '''
