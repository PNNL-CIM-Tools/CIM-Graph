from __future__ import annotations
from dataclasses import dataclass, field
from typing import Optional
from enum import Enum
from uuid import UUID, uuid4
from random import Random
import json
import logging
_log = logging.getLogger(__name__)

'''
    Annotated CIMantic Graphs data profile for ufls
    Generated by CIMTool http://cimtool.org
'''

@dataclass
class Identity():
    '''
    This is the new root class from CIM 18 to provide common identificationufls
    for all classes needing identification and naming attributes.
    IdentifiedObject is now a child class of Identity.
    mRID is superseded by Identity.identifier, which is typed to be a UUID.
    '''
    identifier: Optional[ str | UUID ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '1',
            'maxOccurs': '1'
        })
    
    # Override python __repr__ method with JSON-LD representation
    # This is needed to avoid infinite loops in object previews
    def __repr__(self) -> str:
        return json.dumps({'@id': f'{str(self.identifier)}', '@type': f'{self.__class__.__name__}'})
    
    # Override python string for printing with JSON representation
    def __str__(self) -> str:
        # Create JSON-LD dump with repr and all attributes
        dump = dict(json.loads(self.__repr__()) | self.__dict__)
        attribute_list = list(self.__dataclass_fields__.keys())
        for attribute in attribute_list:
            if dump[attribute] is None or dump[attribute] == []:
                # Delete attributes from print that are empty
                del dump[attribute]
            elif type[dump[attribute]] != str:
                # Reformat all attributes as string for JSON
                dump[attribute] = str(dump[attribute])
        # Fix python ' vs JSON "
        dump = str(dump).replace('\'','\"' )
        # Add 4 spaces indentation
        dump = json.dumps(json.loads(dump), indent=4)
        return dump
    
    # Create UUID from inconsistent mRIDs
    def uuid(self, mRID:str = None, name:str = None) -> UUID:
        invalid_mrid = False
        # If mRID is specified, try creating from UUID from mRID
        if mRID is not None:
            try:
                self.identifier = UUID(mRID.strip('_').lower(), version=4)
            except:
                invalid_mrid = True
                name = mRID
                _log.warning(f'mRID {mRID} not a valid UUID, generating new UUID')
        # Otherwise, build UUID using unique name as a seed
        elif invalid_mrid or name is not None:
            seedStr = f"{self.__class__.__name__}:{name}"
            randomGenerator = Random(seedStr)
            self.identifier = UUID(int=randomGenerator.getrandbits(128), version=4)
        else:
            self.identifier = uuid4()
        if 'mRID' in self.__dataclass_fields__:
            if mRID is not None:
                self.mRID = mRID
            else:
                self.mRID = str(self.identifier)
        
@dataclass(repr=False)
class IdentifiedObject(Identity):
    '''
    This is a root class to provide common identification for all classes needing
    identification and naming attributes.
    '''
    mRID: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Master resource identifier issued by a model authority. The mRID is unique
    within an exchange context. Global uniqueness is easily achieved by using
    a UUID, as specified in RFC 4122, for the mRID. The use of UUID is strongly
    recommended.
    For CIMXML data files in RDF syntax conforming to IEC 61970-552 Edition
    1, the mRID is mapped to rdf:ID or rdf:about attributes that identify CIM
    object elements.
    '''
    aliasName: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The aliasName is free text human readable name of the object alternative
    to IdentifiedObject.name. It may be non unique and may not correlate to
    a naming hierarchy.
    The attribute aliasName is retained because of backwards compatibility
    between CIM relases. It is however recommended to replace aliasName with
    the Name class as aliasName is planned for retirement at a future time.
    '''
    description: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The description is a free human readable text describing or naming the
    object. It may be non unique and may not correlate to a naming hierarchy.
    '''
    name: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The name is any free human readable and possibly non unique text naming
    the object.
    '''
@dataclass(repr=False)
class ACDCTerminal(IdentifiedObject):
    '''
    An electrical connection point (AC or DC) to a piece of conducting equipment.
    Terminals are connected at physical connection points called connectivity
    nodes.
    '''
    connected: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The connected status is related to a bus-branch model and the topological
    node to terminal relation. True implies the terminal is connected to the
    related topological node and false implies it is not.
    In a bus-branch model, the connected status is used to tell if equipment
    is disconnected without having to change the connectivity described by
    the topological node to terminal relation. A valid case is that conducting
    equipment can be connected in one end and open in the other. In particular
    for an AC line segment, where the reactive line charging can be significant,
    this is a relevant case.
    '''
    sequenceNumber: Optional[ int ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The orientation of the terminal connections for a multiple terminal conducting
    equipment. The sequence numbering starts with 1 and additional terminals
    should follow in increasing order. The first terminal is the "starting
    point" for a two terminal branch.
    '''
    Measurements: list[ str | Measurement ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Measurement.Terminal'
        })
    '''
    Measurements associated with this terminal defining where the measurement
    is placed in the network topology. It may be used, for instance, to capture
    the sensor position, such as a voltage transformer (PT) at a busbar or
    a current transformer (CT) at the bar between a breaker and an isolator.
    '''
@dataclass(repr=False)
class Terminal(ACDCTerminal):
    '''
    An AC electrical connection point to a piece of conducting equipment. Terminals
    are connected at physical connection points called connectivity nodes.
    '''
    ConductingEquipment: Optional[ str | ConductingEquipment ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'ConductingEquipment.Terminals'
        })
    '''
    The conducting equipment of the terminal. Conducting equipment have terminals
    that may be connected to other conducting equipment terminals via connectivity
    nodes or topological nodes.
    '''
    ConnectivityNode: Optional[ str | ConnectivityNode ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'ConnectivityNode.Terminals'
        })
    '''
    The connectivity node to which this terminal connects with zero impedance.
    '''
    NormalHeadFeeder: Optional[ str | Feeder ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'Feeder.NormalHeadTerminal'
        })
    '''
    The feeder that this terminal normally feeds. Only specifed for the terminals
    at head of feeders.
    '''
    TopologicalNode: Optional[ str | TopologicalNode ] = field(
        default = None,
        metadata = {
            'type': 'Of Aggregate',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'TopologicalNode.Terminal'
        })
    '''
    The topological node associated with the terminal. This can be used as
    an alternative to the connectivity node path to topological node, thus
    making it unneccesary to model connectivity nodes in some cases. Note that
    the if connectivity nodes are in the model, this association would probably
    not be used as an input specification.
    '''
@dataclass(repr=False)
class BaseVoltage(IdentifiedObject):
    '''
    Defines a system base voltage which is referenced.
    '''
@dataclass(repr=False)
class ConnectivityNode(IdentifiedObject):
    '''
    Connectivity nodes are points where terminals of AC conducting equipment
    are connected together with zero impedance.
    '''
    ConnectivityNodeContainer: Optional[ str | ConnectivityNodeContainer ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'ConnectivityNodeContainer.ConnectivityNodes'
        })
    '''
    Container of this connectivity node.
    '''
    Terminals: list[ str | Terminal ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Terminal.ConnectivityNode'
        })
    '''
    Terminals interconnected with zero impedance at a this connectivity node.
    '''
    TopologicalNode: Optional[ str | TopologicalNode ] = field(
        default = None,
        metadata = {
            'type': 'Of Aggregate',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'TopologicalNode.ConnectivityNodes'
        })
    '''
    The topological node to which this connectivity node is assigned. May depend
    on the current state of switches in the network.
    '''
@dataclass(repr=False)
class FunctionBlock(IdentifiedObject):
    '''
    Function block is a function described as a set of elementary blocks. The
    blocks describe the function between input variables and output variables.
    '''
    enabled: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    True, if the function block is enabled (active). Otherwise false.
    '''
    priority: Optional[ int ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Value 0 means ignore priority. 1 means the highest priority, 2 is the second
    highest priority.
    '''
    FunctionOutputVariable: list[ str | FunctionOutputVariable ] = field(
        default_factory = list,
        metadata = {
            'type': 'Aggregate Of',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'FunctionOutputVariable.FunctionBlock'
        })
    '''
    Function output variable describe the output or codomain to the function
    block.
    '''
    Input: list[ str | FunctionInputVariable ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'FunctionInputVariable.Function'
        })
    '''
    Function input variable describe the input or domain to the function block.
    '''
@dataclass(repr=False)
class ProtectionFunctionBlock(FunctionBlock):
    '''
    '''
    isEnabled: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    usage: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    operateDelayTime: Optional[ float | Seconds ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    operateTime: Optional[ float | Seconds ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    resetDelayTime: Optional[ float | Seconds ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    resetTime: Optional[ float | Seconds ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    startTime: Optional[ float | Seconds ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    ProtectedSwitch: Optional[ str | ProtectedSwitch ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'ProtectedSwitch.ProtectionRelayFunction'
        })
    '''
    '''
    SettingsGroup: list[ str | ProtectionSettingsGroup ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'ProtectionSettingsGroup.ProtectionFunctionBlock'
        })
    '''
    '''
@dataclass(repr=False)
class WideAreaProtectionFunctionBlock(ProtectionFunctionBlock):
    '''
    '''
@dataclass(repr=False)
class FrequencyProtectionFunctionBlock(WideAreaProtectionFunctionBlock):
    '''
    '''
    voltageBlockValue: Optional[ float | Voltage ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
@dataclass(repr=False)
class UnderFrequencyProtectionFunctionBlock(FrequencyProtectionFunctionBlock):
    '''
    '''
    operateValue: Optional[ float | Frequency ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
@dataclass(repr=False)
class FunctionInputVariable(IdentifiedObject):
    '''
    Functional input variable defines the domain of the function.
    '''
    Function: Optional[ str | FunctionBlock ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'FunctionBlock.Input'
        })
    '''
    Function block describe the function that function input variable provides
    the domain for.
    '''
@dataclass(repr=False)
class FunctionOutputVariable(IdentifiedObject):
    '''
    Functional output variable defines the codomain of the function.
    '''
    FunctionBlock: Optional[ str | FunctionBlock ] = field(
        default = None,
        metadata = {
            'type': 'Of Aggregate',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'FunctionBlock.FunctionOutputVariable'
        })
    '''
    Function block describe the function that function output variable provides
    the codomain for.
    '''
@dataclass(repr=False)
class GeographicalRegion(IdentifiedObject):
    '''
    A geographical region of a power system network model.
    '''
    Regions: list[ str | SubGeographicalRegion ] = field(
        default_factory = list,
        metadata = {
            'type': 'Aggregate Of',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'SubGeographicalRegion.Region'
        })
    '''
    All sub-geograhpical regions within this geographical region.
    '''
@dataclass(repr=False)
class Measurement(IdentifiedObject):
    '''
    A Measurement represents any measured, calculated or non-measured non-calculated
    quantity. Any piece of equipment may contain Measurements, e.g. a substation
    may have temperature measurements and door open indications, a transformer
    may have oil temperature and tank pressure measurements, a bay may contain
    a number of power flow measurements and a Breaker may contain a switch
    status measurement.
    The PSR - Measurement association is intended to capture this use of Measurement
    and is included in the naming hierarchy based on EquipmentContainer. The
    naming hierarchy typically has Measurements as leafs, e.g. Substation-VoltageLevel-Bay-Switch-Measurement.
    Some Measurements represent quantities related to a particular sensor location
    in the network, e.g. a voltage transformer (PT) at a busbar or a current
    transformer (CT) at the bar between a breaker and an isolator. The sensing
    position is not captured in the PSR - Measurement association. Instead
    it is captured by the Measurement - Terminal association that is used to
    define the sensing location in the network topology. The location is defined
    by the connection of the Terminal to ConductingEquipment.
    If both a Terminal and PSR are associated, and the PSR is of type ConductingEquipment,
    the associated Terminal should belong to that ConductingEquipment instance.
    When the sensor location is needed both Measurement-PSR and Measurement-Terminal
    are used. The Measurement-Terminal association is never used alone.
    '''
    measurementType: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Specifies the type of measurement. For example, this specifies if the measurement
    represents an indoor temperature, outdoor temperature, bus voltage, line
    flow, etc.
    When the measurementType is set to "Specialization", the type of Measurement
    is defined in more detail by the specialized class which inherits from
    Measurement.
    '''
    PowerSystemResource: Optional[ str | PowerSystemResource ] = field(
        default = None,
        metadata = {
            'type': 'Of Aggregate',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'PowerSystemResource.Measurements'
        })
    '''
    The power system resource that contains the measurement.
    '''
    Terminal: Optional[ str | ACDCTerminal ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'ACDCTerminal.Measurements'
        })
    '''
    One or more measurements may be associated with a terminal in the network.
    '''
@dataclass(repr=False)
class Analog(Measurement):
    '''
    Analog represents an analog Measurement.
    '''
    maxValue: Optional[ float ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Normal value range maximum for any of the MeasurementValue.values. Used
    for scaling, e.g. in bar graphs or of telemetered raw values.
    '''
    minValue: Optional[ float ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Normal value range minimum for any of the MeasurementValue.values. Used
    for scaling, e.g. in bar graphs or of telemetered raw values.
    '''
    normalValue: Optional[ float ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Normal measurement value, e.g., used for percentage calculations.
    '''
    positiveFlowIn: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    If true then this measurement is an active power, reactive power or current
    with the convention that a positive value measured at the Terminal means
    power is flowing into the related PowerSystemResource.
    '''
@dataclass(repr=False)
class Discrete(Measurement):
    '''
    Discrete represents a discrete Measurement, i.e. a Measurement representing
    discrete values, e.g. a Breaker position.
    '''
    maxValue: Optional[ int ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Normal value range maximum for any of the MeasurementValue.values. Used
    for scaling, e.g. in bar graphs or of telemetered raw values.
    '''
    minValue: Optional[ int ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Normal value range minimum for any of the MeasurementValue.values. Used
    for scaling, e.g. in bar graphs or of telemetered raw values.
    '''
    normalValue: Optional[ int ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Normal measurement value, e.g., used for percentage calculations.
    '''
@dataclass(repr=False)
class PowerSystemResource(IdentifiedObject):
    '''
    A power system resource can be an item of equipment such as a switch, an
    equipment container containing many individual items of equipment such
    as a substation, or an organisational entity such as sub-control area.
    Power system resources can have measurements associated.
    '''
    Measurements: list[ str | Measurement ] = field(
        default_factory = list,
        metadata = {
            'type': 'Aggregate Of',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Measurement.PowerSystemResource'
        })
    '''
    The measurements associated with this power system resource.
    '''
@dataclass(repr=False)
class ConnectivityNodeContainer(PowerSystemResource):
    '''
    A base class for all objects that may contain connectivity nodes or topological
    nodes.
    '''
    ConnectivityNodes: list[ str | ConnectivityNode ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'ConnectivityNode.ConnectivityNodeContainer'
        })
    '''
    Connectivity nodes which belong to this connectivity node container.
    '''
    TopologicalNode: list[ str | TopologicalNode ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'TopologicalNode.ConnectivityNodeContainer'
        })
    '''
    The topological nodes which belong to this connectivity node container.
    '''
@dataclass(repr=False)
class EquipmentContainer(ConnectivityNodeContainer):
    '''
    A modeling construct to provide a root class for containing equipment.
    '''
    AdditionalGroupedEquipment: list[ str | Equipment ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Equipment.AdditionalEquipmentContainer'
        })
    '''
    The additonal contained equipment. The equipment belong to the equipment
    container. The equipment is contained in another equipment container, but
    also grouped with this equipment container. Examples include when a switch
    contained in a substation is also desired to be grouped with a line contianer
    or when a switch is included in a secondary substation and also grouped
    in a feeder.
    '''
    Equipments: list[ str | Equipment ] = field(
        default_factory = list,
        metadata = {
            'type': 'Aggregate Of',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Equipment.EquipmentContainer'
        })
    '''
    Contained equipment.
    '''
@dataclass(repr=False)
class Feeder(EquipmentContainer):
    '''
    A collection of equipment for organizational purposes, used for grouping
    distribution resources.
    The organization a feeder does not necessarily reflect connectivity or
    current operation state.
    '''
    NamingSecondarySubstation: list[ str | Substation ] = field(
        default_factory = list,
        metadata = {
            'type': 'Aggregate Of',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Substation.NamingFeeder'
        })
    '''
    The secondary substations that are normally energized from the feeder.
    Used for naming purposes. Should be consistent with the other associations
    for energizing terminal specification and the feeder energization specification.
    '''
    NormalEnergizedSubstation: list[ str | Substation ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Substation.NormalEnergizingFeeder'
        })
    '''
    The substations that are normally energized by the feeder.
    '''
    NormalEnergizingSubstation: Optional[ str | Substation ] = field(
        default = None,
        metadata = {
            'type': 'Of Aggregate',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'Substation.NormalEnergizedFeeder'
        })
    '''
    The substation that nominally energizes the feeder. Also used for naming
    purposes.
    '''
    NormalHeadTerminal: list[ str | Terminal ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Terminal.NormalHeadFeeder'
        })
    '''
    The normal head terminal or terminals of the feeder.
    '''
@dataclass(repr=False)
class Substation(EquipmentContainer):
    '''
    A collection of equipment for purposes other than generation or utilization,
    through which electric energy in bulk is passed for the purposes of switching
    or modifying its characteristics.
    '''
    NamingFeeder: Optional[ str | Feeder ] = field(
        default = None,
        metadata = {
            'type': 'Of Aggregate',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'Feeder.NamingSecondarySubstation'
        })
    '''
    The primary feeder that normally energizes the secondary substation. Used
    for naming purposes. Either this association or the substation to subgeographical
    region should be used for hiearchical containment specification.
    '''
    NormalEnergizedFeeder: list[ str | Feeder ] = field(
        default_factory = list,
        metadata = {
            'type': 'Aggregate Of',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Feeder.NormalEnergizingSubstation'
        })
    '''
    The normal energized feeders of the substation. Also used for naming purposes.
    '''
    NormalEnergizingFeeder: list[ str | Feeder ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Feeder.NormalEnergizedSubstation'
        })
    '''
    The feeders that potentially energize the downstream substation. Should
    be consistent with the associations that describe the naming hiearchy.
    '''
    Region: Optional[ str | SubGeographicalRegion ] = field(
        default = None,
        metadata = {
            'type': 'Of Aggregate',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'SubGeographicalRegion.Substations'
        })
    '''
    The SubGeographicalRegion containing the substation.
    '''
@dataclass(repr=False)
class Equipment(PowerSystemResource):
    '''
    The parts of a power system that are physical devices, electronic or mechanical.
    '''
    aggregate: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The single instance of equipment represents multiple pieces of equipment
    that have been modeled together as an aggregate. Examples would be power
    transformers or synchronous machines operating in parallel modeled as a
    single aggregate power transformer or aggregate synchronous machine. This
    is not to be used to indicate equipment that is part of a group of interdependent
    equipment produced by a network production program.
    '''
    inService: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    If true, the equipment is in service.
    '''
    networkAnalysisEnabled: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The equipment is enabled to participate in network analysis. If unspecified,
    the value is assumed to be true.
    '''
    normallyInService: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    If true, the equipment is normally in service.
    '''
    AdditionalEquipmentContainer: list[ str | EquipmentContainer ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'EquipmentContainer.AdditionalGroupedEquipment'
        })
    '''
    Additional equipment container beyond the primary equipment container.
    The equipment is contained in another equipment container, but also grouped
    with this equipment container.
    '''
    EquipmentContainer: Optional[ str | EquipmentContainer ] = field(
        default = None,
        metadata = {
            'type': 'Of Aggregate',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'EquipmentContainer.Equipments'
        })
    '''
    Container of this equipment.
    '''
@dataclass(repr=False)
class ConductingEquipment(Equipment):
    '''
    The parts of the AC power system that are designed to carry current or
    that are conductively connected through terminals.
    '''
    BaseVoltage: Optional[ str | BaseVoltage ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'BaseVoltage.ConductingEquipment'
        })
    '''
    Base voltage of this conducting equipment. Use only when there is no voltage
    level container used and only one base voltage applies. For example, not
    used for transformers.
    '''
    Terminals: list[ str | Terminal ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Terminal.ConductingEquipment'
        })
    '''
    Conducting equipment have terminals that may be connected to other conducting
    equipment terminals via connectivity nodes or topological nodes.
    '''
@dataclass(repr=False)
class EnergyConnection(ConductingEquipment):
    '''
    '''
@dataclass(repr=False)
class EnergyConsumer(EnergyConnection):
    '''
    Generic user of energy - a point of consumption on the power system model.
    '''
    customerCount: Optional[ int ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Number of individual customers represented by this demand.
    '''
    grounded: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Used for Yn and Zn connections. True if the neutral is solidly grounded.
    '''
    p: Optional[ float | ActivePower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Active power of the load. Load sign convention is used, i.e. positive sign
    means flow out from a node.
    For voltage dependent loads the value is at rated voltage.
    Starting value for a steady state solution.
    '''
    q: Optional[ float | ReactivePower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Reactive power of the load. Load sign convention is used, i.e. positive
    sign means flow out from a node.
    For voltage dependent loads the value is at rated voltage.
    Starting value for a steady state solution.
    '''
    PowerCutZone: Optional[ str | PowerCutZone ] = field(
        default = None,
        metadata = {
            'type': 'Of Aggregate',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'PowerCutZone.EnergyConsumers'
        })
    '''
    The energy consumer is assigned to this power cut zone.
    '''
@dataclass(repr=False)
class RegulatingCondEq(EnergyConnection):
    '''
    A type of conducting equipment that can regulate a quantity (i.e. voltage
    or flow) at a specific point in the network.
    '''
    controlEnabled: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Specifies the regulation status of the equipment. True is regulating, false
    is not regulating.
    '''
@dataclass(repr=False)
class PowerElectronicsConnection(RegulatingCondEq):
    '''
    A connection to the AC network for energy production or consumption that
    uses power electronics rather than rotating machines.
    '''
    controlMode: Optional[ str | ConverterControlModeKind ] = field(
        default = None,
        metadata = {
            'type': 'Enumeration',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    maxIFault: Optional[ float | PU ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Maximum fault current this device will contribute, in per-unit of rated
    current, before the converter protection will trip or bypass.
    '''
    maxQ: Optional[ float | ReactivePower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Maximum reactive power limit. This is the maximum (nameplate) limit for
    the unit.
    '''
    minQ: Optional[ float | ReactivePower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Minimum reactive power limit for the unit. This is the minimum (nameplate)
    limit for the unit.
    '''
    p: Optional[ float | ActivePower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Active power injection. Load sign convention is used, i.e. positive sign
    means flow out from a node.
    Starting value for a steady state solution.
    '''
    q: Optional[ float | ReactivePower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Reactive power injection. Load sign convention is used, i.e. positive sign
    means flow out from a node.
    Starting value for a steady state solution.
    '''
    ratedS: Optional[ float | ApparentPower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Nameplate apparent power rating for the unit.
    The attribute shall have a positive value.
    '''
    ratedU: Optional[ float | Voltage ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Rated voltage (nameplate data, Ur in IEC 60909-0). It is primarily used
    for short circuit data exchange according to IEC 60909.
    '''
    PowerElectronicsUnit: list[ str | PowerElectronicsUnit ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'PowerElectronicsUnit.PowerElectronicsConnection'
        })
    '''
    '''
@dataclass(repr=False)
class Switch(ConductingEquipment):
    '''
    A generic device designed to close, or open, or both, one or more electric
    circuits. All switches are two terminal devices including grounding switches.
    '''
    normalOpen: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The attribute is used in cases when no Measurement for the status value
    is present. If the Switch has a status measurement the Discrete.normalValue
    is expected to match with the Switch.normalOpen.
    '''
    open: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The attribute tells if the switch is considered open when used as input
    to topology processing.
    '''
    retained: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Branch is retained in a bus branch model. The flow through retained switches
    will normally be calculated in power flow.
    '''
    ratedCurrent: Optional[ float | CurrentFlow ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The maximum continuous current carrying capacity in amps governed by the
    device material and construction.
    '''
@dataclass(repr=False)
class ProtectedSwitch(Switch):
    '''
    A ProtectedSwitch is a switching device that can be operated by ProtectionEquipment.
    '''
    breakingCapacity: Optional[ float | CurrentFlow ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The maximum fault current a breaking device can break safely under prescribed
    conditions of use.
    '''
    ProtectionRelayFunction: list[ str | ProtectionFunctionBlock ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'ProtectionFunctionBlock.ProtectedSwitch'
        })
    '''
    '''
@dataclass(repr=False)
class Breaker(ProtectedSwitch):
    '''
    A mechanical switching device capable of making, carrying, and breaking
    currents under normal circuit conditions and also making, carrying for
    a specified time, and breaking currents under specified abnormal circuit
    conditions e.g. those of short circuit.
    '''
    inTransitTime: Optional[ float | Seconds ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The transition time from open to close.
    '''
@dataclass(repr=False)
class PowerElectronicsUnit(Equipment):
    '''
    A generating unit or battery or aggregation that connects to the AC network
    using power electronics rather than rotating machines.
    '''
    maxP: Optional[ float | ActivePower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Maximum active power limit. This is the maximum (nameplate) limit for the
    unit.
    '''
    minP: Optional[ float | ActivePower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Minimum active power limit. This is the minimum (nameplate) limit for the
    unit.
    '''
    PowerElectronicsConnection: Optional[ str | PowerElectronicsConnection ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'PowerElectronicsConnection.PowerElectronicsUnit'
        })
    '''
    '''
@dataclass(repr=False)
class BatteryUnit(PowerElectronicsUnit):
    '''
    An electrochemical energy storage device
    '''
    batteryState: Optional[ str | BatteryStateKind ] = field(
        default = None,
        metadata = {
            'type': 'Enumeration',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    indicates whether the battery is charging, discharging or idle
    '''
    ratedE: Optional[ float | RealEnergy ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    full energy storage capacity of the battery
    '''
    storedE: Optional[ float | RealEnergy ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    amount of energy currently stored; no more than ratedE
    '''
@dataclass(repr=False)
class PhotovoltaicUnit(PowerElectronicsUnit):
    '''
    A photovoltaic device or an aggregation of such devices
    '''
@dataclass(repr=False)
class PowerCutZone(PowerSystemResource):
    '''
    An area or zone of the power system which is used for load shedding purposes.
    '''
    cutLevel1: Optional[ float | PerCent ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    First level (amount) of load to cut as a percentage of total zone load.
    '''
    cutLevel2: Optional[ float | PerCent ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    Second level (amount) of load to cut as a percentage of total zone load.
    '''
    EnergyConsumers: list[ str | EnergyConsumer ] = field(
        default_factory = list,
        metadata = {
            'type': 'Aggregate Of',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'EnergyConsumer.PowerCutZone'
        })
    '''
    Energy consumer is assigned to the power cut zone.
    '''
@dataclass(repr=False)
class ProtectionSettingsGroup(IdentifiedObject):
    '''
    '''
    caseName: Optional[ str ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    groupNumber: Optional[ int ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    inService: Optional[ bool ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    '''
    ProtectionFunctionBlock: list[ str | ProtectionFunctionBlock ] = field(
        default_factory = list,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'ProtectionFunctionBlock.SettingsGroup'
        })
    '''
    '''
@dataclass(repr=False)
class SubGeographicalRegion(IdentifiedObject):
    '''
    A subset of a geographical region of a power system network model.
    '''
    Region: Optional[ str | GeographicalRegion ] = field(
        default = None,
        metadata = {
            'type': 'Of Aggregate',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'GeographicalRegion.Regions'
        })
    '''
    The geographical region to which this sub-geographical region is within.
    '''
    Substations: list[ str | Substation ] = field(
        default_factory = list,
        metadata = {
            'type': 'Aggregate Of',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Substation.Region'
        })
    '''
    The substations in this sub-geographical region.
    '''
@dataclass(repr=False)
class TopologicalNode(IdentifiedObject):
    '''
    For a detailed substation model a topological node is a set of connectivity
    nodes that, in the current network state, are connected together through
    any type of closed switches, including jumpers. Topological nodes change
    as the current network state changes (i.e., switches, breakers, etc. change
    state).
    For a planning model, switch statuses are not used to form topological
    nodes. Instead they are manually created or deleted in a model builder
    tool. Topological nodes maintained this way are also called "busses".
    '''
    pInjection: Optional[ float | ActivePower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The active power injected into the bus at this location in addition to
    injections from equipment. Positive sign means injection into the TopologicalNode
    (bus).
    Starting value for a steady state solution.
    '''
    qInjection: Optional[ float | ReactivePower ] = field(
        default = None,
        metadata = {
            'type': 'Attribute',
            'minOccurs': '0',
            'maxOccurs': '1'
        })
    '''
    The reactive power injected into the bus at this location in addition to
    injections from equipment. Positive sign means injection into the TopologicalNode
    (bus).
    Starting value for a steady state solution.
    '''
    BaseVoltage: Optional[ str | BaseVoltage ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'BaseVoltage.TopologicalNode'
        })
    '''
    The base voltage of the topologocial node.
    '''
    ConnectivityNodeContainer: Optional[ str | ConnectivityNodeContainer ] = field(
        default = None,
        metadata = {
            'type': 'Association',
            'minOccurs': '0',
            'maxOccurs': '1',
            'inverse': 'ConnectivityNodeContainer.TopologicalNode'
        })
    '''
    The connectivity node container to which the toplogical node belongs.
    '''
    ConnectivityNodes: list[ str | ConnectivityNode ] = field(
        default_factory = list,
        metadata = {
            'type': 'Aggregate Of',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'ConnectivityNode.TopologicalNode'
        })
    '''
    The connectivity nodes combine together to form this topological node.
    May depend on the current state of switches in the network.
    '''
    Terminal: list[ str | Terminal ] = field(
        default_factory = list,
        metadata = {
            'type': 'Aggregate Of',
            'minOccurs': '0',
            'maxOccurs': 'unbounded',
            'inverse': 'Terminal.TopologicalNode'
        })
    '''
    The terminals associated with the topological node. This can be used as
    an alternative to the connectivity node path to terminal, thus making it
    unneccesary to model connectivity nodes in some cases. Note that if connectivity
    nodes are in the model, this association would probably not be used as
    an input specification.
    '''
class BatteryStateKind( Enum ):
    '''
    unable to Charge, and not Discharging
    '''
class ConverterControlModeKind( Enum ):
    '''
    Holds constant Q; may change both P and Q by dispatch commands
    '''
@dataclass
class ActivePower():
    value: float = field(default=None)
    '''
    Product of RMS value of the voltage and the RMS value of the in-phase component
    of the current.
    '''
@dataclass
class PerCent():
    value: float = field(default=None)
    '''
    Percentage on a defined base. For example, specify as 100 to indicate at
    the defined base.
    '''
@dataclass
class CurrentFlow():
    value: float = field(default=None)
    '''
    Electrical current with sign convention: positive flow is out of the conducting
    equipment into the connectivity node. Can be both AC and DC.
    '''
@dataclass
class PU():
    value: float = field(default=None)
    '''
    Per Unit - a positive or negative value referred to a defined base. Values
    typically range from -10 to +10.
    '''
@dataclass
class RealEnergy():
    value: float = field(default=None)
    '''
    Real electrical energy.
    '''
@dataclass
class Voltage():
    value: float = field(default=None)
    '''
    Electrical voltage, can be both AC and DC.
    '''
@dataclass
class Frequency():
    value: float = field(default=None)
    '''
    Cycles per second.
    '''
@dataclass
class Seconds():
    value: float = field(default=None)
    '''
    Time, in seconds.
    '''
@dataclass
class ReactivePower():
    value: float = field(default=None)
    '''
    Product of RMS value of the voltage and the RMS value of the quadrature
    component of the current.
    '''
@dataclass
class ApparentPower():
    value: float = field(default=None)
    '''
    Product of the RMS value of the voltage and the RMS value of the current.
    '''
